{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/scanpy_cluster_reduce_dimension/scanpy_cluster_reduce_dimension/1.10.2+galaxy0", "name": "Scanpy cluster, embed", "version": "1.10.2+galaxy0", "description": "and infer trajectories", "labels": [], "edam_operations": ["operation_3223"], "edam_topics": ["topic_2229", "topic_3053", "topic_0203"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "scanpy", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "scanpy_cluster_reduce_dimension", "owner": "iuc", "changeset_revision": "178242b82297", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "adata", "argument": null, "type": "data", "label": "Annotated data matrix", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["h5ad"], "edam": {"edam_formats": ["format_3590"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "tl.louvain", "inputs": [{"model_class": "Conditional", "name": "flavor", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "vtraag", "inputs": [{"model_class": "FloatToolParameter", "name": "resolution", "argument": "resolution", "type": "float", "label": "Resolution", "help": "Higher resolution means finding more and smaller clusters, which defaults to 1.0. See \u201cTime as a resolution parameter\u201d in Lambiotte et al, 2014", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "igraph", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "flavor", "argument": "flavor", "type": "select", "label": "Flavor for the clustering", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "vtraag", "options": [["vtraag (much more powerful than igraph)", "vtraag", true], ["Built in igraph method", "igraph", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key under which to add the cluster labels", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "louvain", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "directed", "argument": "directed", "type": "boolean", "label": "Interpret the adjacency matrix as directed graph?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "BooleanToolParameter", "name": "use_weights", "argument": "use_weights", "type": "boolean", "label": "Use weights from knn graph?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.leiden", "inputs": [{"model_class": "FloatToolParameter", "name": "resolution", "argument": "resolution", "type": "float", "label": "Coarseness of the clusterin", "help": "Higher values lead to more clusters", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key under which to add the cluster labels", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "leiden", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "directed", "argument": "directed", "type": "boolean", "label": "Treat the graph as directed or undirected?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "None"}, {"model_class": "BooleanToolParameter", "name": "use_weights", "argument": "use_weights", "type": "boolean", "label": "Use weights from knn graph?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "n_iterations", "argument": "n_iterations", "type": "integer", "label": "How many iterations of the Leiden clustering algorithm to perform.", "help": "Positive values above 2 define the total number of iterations to perform, -1 has the algorithm run until it reaches its optimal clustering.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "-1", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "flavor", "argument": "flavor", "type": "select", "label": "Flavor for the clustering", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "leidenalg", "options": [["leidenalg", "leidenalg", true], ["Built in igraph method", "igraph", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "pp.pca", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": "n_comps", "type": "integer", "label": "Number of principal components to compute", "help": "If the value is larger than the number of observations the number of observations is used instead", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "layer", "argument": "layer", "type": "text", "label": "If provided, which element of layers to use for PCA", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "dtype", "argument": "dtype", "type": "select", "label": "Numpy data type string to which to convert the result", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "float32", "options": [["float32", "float32", true], ["int32", "int32", false], ["int64", "int64", false], ["uint32", "uint32", false], ["uint64", "uint64", false], ["float16", "float16", false], ["float64", "float64", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "pca", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "IntegerToolParameter", "name": "chunk_size", "argument": "chunk_size", "type": "integer", "label": "chunk_size", "help": "Number of observations to include in each chunk", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": [{"model_class": "BooleanToolParameter", "name": "zero_center", "argument": "zero_center", "type": "boolean", "label": "Compute standard PCA from covariance matrix?", "help": "If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "svd_solver", "argument": null, "type": "select", "label": "SVD solver to use", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["Automatically chosen depending on the size of the problem", "auto", false], ["ARPACK wrapper in SciPy", "arpack", false], ["Randomized algorithm due to Halko (2009)", "randomized", false], ["An alternative SciPy solver. Not available with dask arrays.", "lobpcg", false], ["Only available with dask arrays. \u201ctsqr\u201d algorithm from Benson et. al. (2013).", "tsqr", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Change to use different initial states for the optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "chunked", "argument": "chunked", "type": "select", "label": "Type of PCA?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "False", "options": [["Full PCA", "False", true], ["Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of 'random_seed' and 'svd_solver')", "True", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "TextToolParameter", "name": "mask_var", "argument": "mask_var", "type": "text", "label": "To run only on a certain set of genes given by a string referring to an array in", "help": "By default, uses .var['highly_variable'] if available, else everything", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.diffmap", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": "n_comps", "type": "integer", "label": "Number of dimensions of the representation", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Seed used by the random number generator", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.tsne", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_pcs", "argument": "n_pcs", "type": "integer", "label": "Number of PCs to use", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "use_rep", "argument": "use_rep", "type": "text", "label": "Use the indicated representation", "help": "If not set, the representation is chosen automatically: for n_vars below 50, X is used, otherwise X_pca (uns) is used. If X_pca is not present, it's computed with default parameter", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "perplexity", "argument": "perplexity", "type": "float", "label": "Perplexity", "help": "The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "30.0", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "metric", "argument": "metric", "type": "select", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "euclidean", "options": [["euclidean", "euclidean", true], ["braycurtis", "braycurtis", false], ["canberra", "canberra", false], ["chebyshev", "chebyshev", false], ["cityblock", "cityblock", false], ["correlation", "correlation", false], ["cosine", "cosine", false], ["mahalanobis", "mahalanobis", false], ["matching", "matching", false], ["minkowski", "minkowski", false], ["seuclidean", "seuclidean", false], ["sqeuclidean", "sqeuclidean", false], ["wminkowski", "wminkowski", false], ["dice", "dice", false], ["hamming", "hamming", false], ["jaccard", "jaccard", false], ["kulsinski", "kulsinski", false], ["rogerstanimoto", "rogerstanimoto", false], ["russellrao", "russellrao", false], ["sokalmichener", "sokalmichener", false], ["sokalsneath", "sokalsneath", false], ["yule", "yule", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "FloatToolParameter", "name": "early_exaggeration", "argument": "early_exaggeration", "type": "float", "label": "Early exaggeration", "help": "Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "12.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "learning_rate", "argument": "learning_rate", "type": "float", "label": "Learning rate", "help": "The learning rate can be a critical parameter. It should be between 100 and 1000. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high. If the cost function gets stuck in a bad local minimum increasing the learning rate helps sometimes.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change this to use different intial states for the optimization", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.umap", "inputs": [{"model_class": "FloatToolParameter", "name": "min_dist", "argument": "min_dist", "type": "float", "label": "Effective minimum distance between embedded points", "help": "Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the 'spread' value, which determines the scale at which embedded points will be spread out. The default of in the 'umap-learn' package is 0.1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "Effective scale of embedded points", "help": "In combination with 'min_dist' this determines how clustered/clumped the embedded points are.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_components", "argument": "n_components", "type": "integer", "label": "Number of dimensions of the embedding", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxiter", "argument": "maxiter", "type": "integer", "label": "Number of iterations (epochs) of the optimization", "help": "Called 'n_epochs' in the original UMAP.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Initial learning rate for the embedding optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "gamma", "argument": "gamma", "type": "float", "label": "Weighting applied to negative samples in low dimensional embedding optimization", "help": "Values higher than one will result in greater weight being given to negative samples.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "negative_sample_rate", "argument": "negative_sample_rate", "type": "integer", "label": "The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "init_pos", "argument": "init_pos", "type": "select", "label": "How to initialize the low dimensional embedding", "help": "Called 'init' in the original UMAP", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "spectral", "options": [["Spectral embedding of the graph", "spectral", true], ["Position from paga", "paga", false], ["Initial embedding positions at random", "random", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Seed used by the random number generator", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.draw_graph", "inputs": [{"model_class": "SelectToolParameter", "name": "layout", "argument": "layout", "type": "select", "label": "Plotting layout", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "fa", "options": [["fa: ForceAtlas2", "fa", true], ["drl: Distributed Recursive Layout, pretty fast", "drl", false], ["fr: Fruchterman-Reingold", "fr", false], ["grid_fr: Grid Fruchterman Reingold, faster than \"fr\"", "grid_fr", false], ["kk: Kamadi Kawai\u2019, slower than \"fr\"", "kk", false], ["Large Graph, very fast", "lgl", false], ["rt: Reingold Tilford tree layout", "rt", false], ["rt_circular: Reingold Tilford tree circular", "rt_circular", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "root", "argument": "root", "type": "integer", "label": "Root for tree layouts", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "For layouts with random initialization like 'fr', change this to use different intial states for the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "adjacency", "argument": "adjacency", "type": "data", "label": "Sparse adjacency matrix of the graph", "help": "If not set, it uses the unstructured annotation (uns) / neighbors / connectivities", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["mtx"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "TextToolParameter", "name": "key_added_ext", "argument": "key_added_ext", "type": "text", "label": "External key", "help": "If not set, it appends 'layout'", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "init_pos", "argument": "init_pos", "type": "text", "label": "Precomputed coordinates for initialization", "help": "It should be a valid 2d observation (e.g. paga)", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.dpt", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_dcs", "argument": "n_dcs", "type": "integer", "label": "Number of diffusion components to use", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_branchings", "argument": "n_branchings", "type": "integer", "label": "Number of branchings to detect", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "min_group_size", "argument": "min_group_size", "type": "float", "label": "Min group size", "help": "During recursive splitting of branches ('dpt groups') for 'n_branchings' > 1, do not consider groups that contain less than 'min_group_size' data points. If a float, 'min_group_size' refers to a fraction of the total number of data points.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.01", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "allow_kendall_tau_shift", "argument": "allow_kendall_tau_shift", "type": "boolean", "label": "Allow Kendal tau shift?", "help": "If a very small branch is detected upon splitting, shift away from maximum correlation in Kendall tau criterion of Haghverdi et al (2016) to stabilize the splitting.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.paga", "inputs": [{"model_class": "TextToolParameter", "name": "groups", "argument": "groups", "type": "text", "label": "Key for categorical in the input", "help": "You can pass your predefined groups by choosing any categorical annotation of observations ('adata.obs').", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_rna_velocity", "argument": "use_rna_velocity", "type": "boolean", "label": "Use RNA velocity to orient edges in the abstracted graph and estimate transitions?", "help": "Requires that 'adata.uns' contains a directed single-cell graph with key '['velocyto_transitions']'. This feature might be subject to change in the future.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "model", "argument": "model", "type": "select", "label": "PAGA connectivity model", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "v1.2", "options": [["v1.2", "v1.2", true], ["v1.0", "v1.0", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "neighbors_key", "argument": "neighbors_key", "type": "text", "label": "Key to look for neighbors settings and connectivities", "help": "If not specified, looks .uns[\u2018neighbors\u2019] for neighbors settings and .obsp[\u2018connectivities\u2019] for connectivities (default storage places for pp.neighbors).", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.embedding_density", "inputs": [{"model_class": "TextToolParameter", "name": "basis", "argument": "basis", "type": "text", "label": "The embedding over which the density will be calculated.", "help": "This embedded representation should be found in adata.obsm['X_[basis]']", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "umap", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "groupby", "argument": "groupby", "type": "text", "label": "Key for categorical observation/cell annotation for which densities are calculated per category.", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Name of the .obs covariate that will be added with the density estimates.", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method used", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "tl.louvain", "options": [["Cluster cells into subgroups, using 'tl.louvain'", "tl.louvain", false], ["Cluster cells into subgroups, using 'tl.leiden'", "tl.leiden", false], ["Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using 'pp.pca'", "pp.pca", false], ["Diffusion Maps, using 'tl.diffmap'", "tl.diffmap", false], ["t-distributed stochastic neighborhood embedding (tSNE), using 'tl.tsne'", "tl.tsne", false], ["Embed the neighborhood graph using UMAP, using 'tl.umap'", "tl.umap", false], ["Force-directed graph drawing, using 'tl.draw_graph'", "tl.draw_graph", false], ["Infer progression of cells through geodesic distance along the graph, using 'tl.dpt'", "tl.dpt", false], ["Generate cellular maps of differentiation manifolds with complex topologies, using 'tl.paga'", "tl.paga", false], ["Calculate the density of cells in an embedding (per condition), using 'tl.embedding_density'", "tl.embedding_density", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "advanced_common", "type": "section", "title": "Advanced Options", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "show_log", "argument": null, "type": "boolean", "label": "Output Log?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}]}], "outputs": [{"model_class": "ToolOutput", "name": "anndata_out", "format": "h5ad", "label": "${tool.name} (${method.method}) on ${on_string}: Annotated data matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "anndata.h5ad", "edam_format": "format_3590", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "hidden_output", "format": "txt", "label": "Log file", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "single-cell", "panel_section_name": "Single-cell", "form_style": "regular"}