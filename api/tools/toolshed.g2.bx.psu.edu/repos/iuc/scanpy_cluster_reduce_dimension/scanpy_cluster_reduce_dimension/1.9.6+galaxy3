{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/scanpy_cluster_reduce_dimension/scanpy_cluster_reduce_dimension/1.9.6+galaxy3", "name": "Cluster, infer trajectories and embed", "version": "1.9.6+galaxy3", "description": "with scanpy", "labels": [], "edam_operations": ["operation_3223"], "edam_topics": ["topic_3053", "topic_0203", "topic_2229"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "scanpy", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "scanpy_cluster_reduce_dimension", "owner": "iuc", "changeset_revision": "4d8f983cd751", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "adata", "argument": null, "type": "data", "label": "Annotated data matrix", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["h5ad"], "edam": {"edam_formats": ["format_3590"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "tl.louvain", "inputs": [{"model_class": "Conditional", "name": "flavor", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "vtraag", "inputs": [{"model_class": "FloatToolParameter", "name": "resolution", "argument": "resolution", "type": "float", "label": "Resolution", "help": "Higher resolution means finding more and smaller clusters, which defaults to 1.0. See \u201cTime as a resolution parameter\u201d in Lambiotte et al, 2009", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "igraph", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "flavor", "argument": "flavor", "type": "select", "label": "Flavor for the clustering", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "vtraag", "options": [["vtraag (much more powerful)", "vtraag", false], ["igraph", "igraph", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key under which to add the cluster labels", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "louvain", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "directed", "argument": "directed", "type": "boolean", "label": "Interpret the adjacency matrix as directed graph?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "BooleanToolParameter", "name": "use_weights", "argument": "use_weights", "type": "boolean", "label": "Use weights from knn graph?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.leiden", "inputs": [{"model_class": "FloatToolParameter", "name": "resolution", "argument": "resolution", "type": "float", "label": "Coarseness of the clusterin", "help": "Higher values lead to more clusters", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key under which to add the cluster labels", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "leiden", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_weights", "argument": "use_weights", "type": "boolean", "label": "Use weights from knn graph?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "n_iterations", "argument": "n_iterations", "type": "integer", "label": "How many iterations of the Leiden clustering algorithm to perform.", "help": "Positive values above 2 define the total number of iterations to perform, -1 has the algorithm run until it reaches its optimal clustering.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "-1", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.pca", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": "n_comps", "type": "integer", "label": "Number of principal components to compute", "help": "If the value is larger than the number of observations the number of observations is used instead", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "dtype", "argument": "dtype", "type": "text", "label": "Numpy data type string to which to convert the result", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "float32", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "pca", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "IntegerToolParameter", "name": "chunk_size", "argument": "chunk_size", "type": "integer", "label": "chunk_size", "help": "Number of observations to include in each chunk", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": [{"model_class": "BooleanToolParameter", "name": "zero_center", "argument": "zero_center", "type": "boolean", "label": "Compute standard PCA from covariance matrix?", "help": "If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "svd_solver", "argument": null, "type": "select", "label": "SVD solver to use", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatically chosen depending on the size of the problem", "auto", false], ["ARPACK wrapper in SciPy", "arpack", false], ["Randomized algorithm due to Halko (2009)", "randomized", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Initial states for the optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "chunked", "argument": "chunked", "type": "select", "label": "Type of PCA?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "False", "options": [["Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of 'random_seed' and 'svd_solver')", "True", false], ["Full PCA", "False", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "use_highly_variable", "argument": "use_highly_variable", "type": "boolean", "label": "Use highly variable genes only?", "help": "They should be use if they have been determined beforehand.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.pca", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": "n_comps", "type": "integer", "label": "Number of principal components to compute", "help": "If the value is larger than the number of observations the number of observations is used instead", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "dtype", "argument": "dtype", "type": "text", "label": "Numpy data type string to which to convert the result", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "float32", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "pca", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "IntegerToolParameter", "name": "chunk_size", "argument": "chunk_size", "type": "integer", "label": "chunk_size", "help": "Number of observations to include in each chunk", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": [{"model_class": "BooleanToolParameter", "name": "zero_center", "argument": "zero_center", "type": "boolean", "label": "Compute standard PCA from covariance matrix?", "help": "If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "svd_solver", "argument": null, "type": "select", "label": "SVD solver to use", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatically chosen depending on the size of the problem", "auto", false], ["ARPACK wrapper in SciPy", "arpack", false], ["Randomized algorithm due to Halko (2009)", "randomized", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Initial states for the optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "chunked", "argument": "chunked", "type": "select", "label": "Type of PCA?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "False", "options": [["Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of 'random_seed' and 'svd_solver')", "True", false], ["Full PCA", "False", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "use_highly_variable", "argument": "use_highly_variable", "type": "boolean", "label": "Use highly variable genes only?", "help": "They should be use if they have been determined beforehand.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.diffmap", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": "n_comps", "type": "integer", "label": "Number of dimensions of the representation", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.tsne", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_pcs", "argument": null, "type": "integer", "label": "Number of PCs to use", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "perplexity", "argument": null, "type": "float", "label": "Perplexity", "help": "The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "30.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "early_exaggeration", "argument": null, "type": "float", "label": "Early exaggeration", "help": "Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "12.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "learning_rate", "argument": null, "type": "float", "label": "Learning rate", "help": "The learning rate can be a critical parameter. It should be between 100 and 1000. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high. If the cost function gets stuck in a bad local minimum increasing the learning rate helps sometimes.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": null, "type": "integer", "label": "Random state", "help": "Change this to use different intial states for the optimization", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_fast_tsne", "argument": "use_fast_tsne", "type": "boolean", "label": "Use the MulticoreTSNE package if possible?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.umap", "inputs": [{"model_class": "FloatToolParameter", "name": "min_dist", "argument": "min_dist", "type": "float", "label": "Effective minimum distance between embedded points", "help": "Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the 'spread' value, which determines the scale at which embedded points will be spread out. The default of in the 'umap-learn' package is 0.1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "Effective scale of embedded points", "help": "In combination with 'min_dist' this determines how clustered/clumped the embedded points are.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_components", "argument": "n_components", "type": "integer", "label": "Number of dimensions of the embedding", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxiter", "argument": "maxiter", "type": "integer", "label": "Number of iterations (epochs) of the optimization", "help": "Called 'n_epochs' in the original UMAP.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Initial learning rate for the embedding optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "gamma", "argument": "gamma", "type": "float", "label": "Weighting applied to negative samples in low dimensional embedding optimization", "help": "Values higher than one will result in greater weight being given to negative samples.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "negative_sample_rate", "argument": "negative_sample_rate", "type": "integer", "label": "The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "init_pos", "argument": "init_pos", "type": "select", "label": "How to initialize the low dimensional embedding", "help": "Called 'init' in the original UMAP", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "spectral", "options": [["Position from paga", "paga", false], ["Spectral embedding of the graph", "spectral", true], ["Initial embedding positions at random", "random", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.draw_graph", "inputs": [{"model_class": "SelectToolParameter", "name": "layout", "argument": "layout", "type": "select", "label": "Plotting layout", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "fa", "options": [["fa: ForceAtlas2", "fa", false], ["fr: Fruchterman-Reingold", "fr", false], ["grid_fr: Grid Fruchterman Reingold, faster than \"fr\"", "grid_fr", false], ["kk: Kamadi Kawai\u2019, slower than \"fr\"", "kk", false], ["drl: Distributed Recursive Layout, pretty fast", "drl", false], ["rt: Reingold Tilford tree layout", "rt", false], ["eq_tree: Equally spaced tree", "eq_tree", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "root", "argument": "root", "type": "text", "label": "Comma-separated roots", "help": "If choosing a tree layout, this is the index of the root node or a list of root node indices. If this is a non-empty vector then the supplied node IDs are used as the roots of the trees (or a single tree if the graph is connected). If this is 'None' or an empty list, the root vertices are automatically calculated based on topological sorting.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "init_pos", "argument": "init_pos", "type": "text", "label": "Precomputed coordinates for initialization", "help": "It should be a valid 2d observation (e.g. paga)", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "adjacency", "argument": "adjacency", "type": "data", "label": "Sparse adjacency matrix of the graph", "help": "If not set, it uses the unstructured annotation (uns) / neighbors / connectivities", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["mtx"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "TextToolParameter", "name": "key_ext", "argument": "key_ext", "type": "text", "label": "External key", "help": "If not set, it appends 'layout'", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.dpt", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_dcs", "argument": "n_dcs", "type": "integer", "label": "Number of diffusion components to use", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_branchings", "argument": "n_branchings", "type": "integer", "label": "Number of branchings to detect", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "min_group_size", "argument": "min_group_size", "type": "float", "label": "Min group size", "help": "During recursive splitting of branches ('dpt groups') for 'n_branchings' > 1, do not consider groups that contain less than 'min_group_size' data points. If a float, 'min_group_size' refers to a fraction of the total number of data points.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.01", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "allow_kendall_tau_shift", "argument": "allow_kendall_tau_shift", "type": "boolean", "label": "Allow Kendal tau shift?", "help": "If a very small branch is detected upon splitting, shift away from maximum correlation in Kendall tau criterion of Haghverdi et al (2016) to stabilize the splitting.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.paga", "inputs": [{"model_class": "TextToolParameter", "name": "groups", "argument": "groups", "type": "text", "label": "Key for categorical in the input", "help": "You can pass your predefined groups by choosing any categorical annotation of observations ('adata.obs').", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "louvain", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_rna_velocity", "argument": "use_rna_velocity", "type": "boolean", "label": "Use RNA velocity to orient edges in the abstracted graph and estimate transitions?", "help": "Requires that 'adata.uns' contains a directed single-cell graph with key '['velocyto_transitions']'. This feature might be subject to change in the future.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "model", "argument": "model", "type": "select", "label": "PAGA connectivity model", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "v1.2", "options": [["v1.2", "v1.2", false], ["v1.0", "v1.0", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "tl.embedding_density", "inputs": [{"model_class": "TextToolParameter", "name": "basis", "argument": "basis", "type": "text", "label": "The embedding over which the density will be calculated.", "help": "This embedded representation should be found in adata.obsm['X_[basis]']", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "umap", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "groupby", "argument": "groupby", "type": "text", "label": "Key for categorical observation/cell annotation for which densities are calculated per category.", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Name of the .obs covariate that will be added with the density estimates.", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method used", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "tl.louvain", "options": [["Cluster cells into subgroups, using 'tl.louvain'", "tl.louvain", false], ["Cluster cells into subgroups, using 'tl.leiden'", "tl.leiden", false], ["Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using 'pp.pca'", "pp.pca", false], ["Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using 'tl.pca'", "tl.pca", false], ["Diffusion Maps, using 'tl.diffmap'", "tl.diffmap", false], ["t-distributed stochastic neighborhood embedding (tSNE), using 'tl.tsne'", "tl.tsne", false], ["Embed the neighborhood graph using UMAP, using 'tl.umap'", "tl.umap", false], ["Force-directed graph drawing, using 'tl.draw_graph'", "tl.draw_graph", false], ["Infer progression of cells through geodesic distance along the graph, using 'tl.dpt'", "tl.dpt", false], ["Generate cellular maps of differentiation manifolds with complex topologies, using 'tl.paga'", "tl.paga", false], ["Calculate the density of cells in an embedding (per condition)", "tl.embedding_density", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "advanced_common", "type": "section", "title": "Advanced Options", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "show_log", "argument": null, "type": "boolean", "label": "Output Log?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}]}], "outputs": [{"model_class": "ToolOutput", "name": "anndata_out", "format": "h5ad", "label": "${tool.name} (${method.method}) on ${on_string}: Annotated data matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "anndata.h5ad", "edam_format": "format_3590", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "hidden_output", "format": "txt", "label": "Log file", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "single-cell", "panel_section_name": "Single-cell", "form_style": "regular"}