{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/scanpy_cluster_reduce_dimension/scanpy_cluster_reduce_dimension/1.4+galaxy0", "name": "Cluster and reduce dimension with scanpy", "version": "1.4+galaxy0", "description": "", "labels": [], "edam_operations": [], "edam_topics": [], "hidden": "", "is_workflow_compatible": true, "xrefs": [], "tool_shed_repository": {"name": "scanpy_cluster_reduce_dimension", "owner": "iuc", "changeset_revision": "0e212e42ef88", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "Conditional", "name": "input", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "loom", "inputs": [{"model_class": "DataToolParameter", "name": "adata", "argument": null, "type": "data", "label": "Annotated data matrix", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["loom"], "edam": {"edam_formats": ["format_3590"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "BooleanToolParameter", "name": "sparse", "argument": null, "type": "boolean", "label": "Is the data matrix to read sparse?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "BooleanToolParameter", "name": "cleanup", "argument": null, "type": "boolean", "label": "Cleanup?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "TextToolParameter", "name": "x_name", "argument": null, "type": "text", "label": "X_name", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "spliced", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "obs_names", "argument": null, "type": "text", "label": "obs_names", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "CellID", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "var_names", "argument": null, "type": "text", "label": "var_names", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "Gene", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "h5ad", "inputs": [{"model_class": "DataToolParameter", "name": "adata", "argument": null, "type": "data", "label": "Annotated data matrix", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["h5"], "edam": {"edam_formats": ["format_3590"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "format", "argument": null, "type": "select", "label": "Format for the annotated data matrix", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "loom", "options": [["loom", "loom", false], ["h5ad-formatted hdf5 (anndata)", "h5ad", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "tl.louvain", "inputs": [{"model_class": "Conditional", "name": "flavor", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "vtraag", "inputs": [{"model_class": "FloatToolParameter", "name": "resolution", "argument": "resolution", "type": "float", "label": "Resolution", "help": "Higher resolution means finding more and smaller clusters, which defaults to 1.0. See \u201cTime as a resolution parameter\u201d in Lambiotte et al, 2009", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "igraph", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "flavor", "argument": "flavor", "type": "select", "label": "Flavor for the clustering", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "vtraag", "options": [["vtraag (much more powerful)", "vtraag", false], ["igraph", "igraph", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change the initialization of the optimization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key under which to add the cluster labels", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "louvain", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.pca", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": null, "type": "integer", "label": "Number of principal components to compute", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "dtype", "argument": null, "type": "text", "label": "Numpy data type string to which to convert the result", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "float32", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "pca", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "IntegerToolParameter", "name": "chunk_size", "argument": null, "type": "integer", "label": "chunk_size", "help": "Number of observations to include in each chunk", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": [{"model_class": "BooleanToolParameter", "name": "zero_center", "argument": null, "type": "boolean", "label": "Compute standard PCA from covariance matrix?", "help": "If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "svd_solver", "argument": null, "type": "select", "label": "SVD solver to use", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatically chosen depending on the size of the problem", "auto", false], ["ARPACK wrapper in SciPy", "arpack", false], ["Randomized algorithm due to Halko (2009)", "randomized", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": null, "type": "integer", "label": "Initial states for the optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "chunked", "argument": null, "type": "select", "label": "Type of PCA?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "False", "options": [["Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of `random_seed` and `svd_solver`)", "True", false], ["Full PCA", "False", true]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "tl.pca", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": null, "type": "integer", "label": "Number of principal components to compute", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "dtype", "argument": null, "type": "text", "label": "Numpy data type string to which to convert the result", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "float32", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "pca", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "IntegerToolParameter", "name": "chunk_size", "argument": null, "type": "integer", "label": "chunk_size", "help": "Number of observations to include in each chunk", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": [{"model_class": "BooleanToolParameter", "name": "zero_center", "argument": null, "type": "boolean", "label": "Compute standard PCA from covariance matrix?", "help": "If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "svd_solver", "argument": null, "type": "select", "label": "SVD solver to use", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatically chosen depending on the size of the problem", "auto", false], ["ARPACK wrapper in SciPy", "arpack", false], ["Randomized algorithm due to Halko (2009)", "randomized", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": null, "type": "integer", "label": "Initial states for the optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "chunked", "argument": null, "type": "select", "label": "Type of PCA?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "False", "options": [["Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of `random_seed` and `svd_solver`)", "True", false], ["Full PCA", "False", true]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "tl.diffmap", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_comps", "argument": "n_comps", "type": "integer", "label": "Number of dimensions of the representation", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.tsne", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_pcs", "argument": null, "type": "integer", "label": "Number of PCs to use", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "perplexity", "argument": null, "type": "float", "label": "Perplexity", "help": "The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "30.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "early_exaggeration", "argument": null, "type": "float", "label": "Early exaggeration", "help": "Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "12.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "learning_rate", "argument": null, "type": "float", "label": "Learning rate", "help": "The learning rate can be a critical parameter. It should be between 100 and 1000. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high. If the cost function gets stuck in a bad local minimum increasing the learning rate helps sometimes.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": null, "type": "integer", "label": "Random state", "help": "Change this to use different intial states for the optimization", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.umap", "inputs": [{"model_class": "FloatToolParameter", "name": "min_dist", "argument": "min_dist", "type": "float", "label": "Effective minimum distance between embedded points", "help": "Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the `spread` value, which determines the scale at which embedded points will be spread out. The default of in the `umap-learn` package is 0.1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "Effective scale of embedded points", "help": "In combination with `min_dist` this determines how clustered/clumped the embedded points are.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_components", "argument": "n_components", "type": "integer", "label": "Number of dimensions of the embedding", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxiter", "argument": "maxiter", "type": "integer", "label": "Number of iterations (epochs) of the optimization", "help": "Called `n_epochs` in the original UMAP.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Initial learning rate for the embedding optimization", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "gamma", "argument": "gamma", "type": "float", "label": "Weighting applied to negative samples in low dimensional embedding optimization", "help": "Values higher than one will result in greater weight being given to negative samples.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "negative_sample_rate", "argument": "negative_sample_rate", "type": "integer", "label": "The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "init_pos", "argument": "init_pos", "type": "select", "label": "How to initialize the low dimensional embedding", "help": "Called `init` in the original UMAP", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "spectral", "options": [["Position from paga", "paga", false], ["Spectral embedding of the graph", "spectral", true], ["Initial embedding positions at random", "random", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random state", "help": "Change this to use different intial states for the optimization", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.neighbors", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_neighbors", "argument": "n_neighbors", "type": "integer", "label": "The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation", "help": "Larger values result in more global views of the manifold, while smaller values result in more local data being preserved. In general values should be in the range 2 to 100. If `knn` is `True`, number of nearest neighbors to be searched. If `knn` is `False`, a Gaussian kernel width is set to the distance of the `n_neighbors` neighbor.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_pcs", "argument": "n_pcs", "type": "integer", "label": "Number of PCs to use", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "knn", "argument": "knn", "type": "boolean", "label": "Use a hard threshold to restrict the number of neighbors to n_neighbors?", "help": "If true, it considers a knn graph. Otherwise, it uses a Gaussian Kernel to assign low weights to neighbors more distant than the `n_neighbors` nearest neighbor.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Numpy random seed", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "pp_neighbors_method", "argument": "method", "type": "select", "label": "Method for computing connectivities", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "umap", "options": [["umap (McInnes et al, 2018)", "umap", false], ["gauss: Gauss kernel following (Coifman et al 2005) with adaptive width (Haghverdi et al 2016)", "gauss", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "metric", "argument": "metric", "type": "select", "label": "Distance metric", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "euclidean", "options": [["braycurtis", "braycurtis", false], ["canberra", "canberra", false], ["chebyshev", "chebyshev", false], ["cityblock", "cityblock", false], ["correlation", "correlation", false], ["cosine", "cosine", false], ["euclidean", "euclidean", true], ["mahalanobis", "mahalanobis", false], ["matching", "matching", false], ["minkowski", "minkowski", false], ["seuclidean", "seuclidean", false], ["sqeuclidean", "sqeuclidean", false], ["wminkowski", "wminkowski", false], ["dice", "dice", false], ["hamming", "hamming", false], ["jaccard", "jaccard", false], ["kulsinski", "kulsinski", false], ["rogerstanimoto", "rogerstanimoto", false], ["russellrao", "russellrao", false], ["sokalmichener", "sokalmichener", false], ["sokalsneath", "sokalsneath", false], ["yule", "yule", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "tl.rank_genes_groups", "inputs": [{"model_class": "TextToolParameter", "name": "groupby", "argument": "groupby", "type": "text", "label": "The key of the observations grouping to consider", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_raw", "argument": "use_raw", "type": "boolean", "label": "Use `raw` attribute of input if present", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "TextToolParameter", "name": "groups", "argument": "groups", "type": "text", "label": "Subset of groups to which comparison shall be restricted", "help": "e.g. ['g1', 'g2', 'g3']. If not passed, a ranking will be generated for all groups.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "ref", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "rest", "inputs": []}, {"model_class": "ConditionalWhen", "value": "group_id", "inputs": [{"model_class": "TextToolParameter", "name": "reference", "argument": "reference", "type": "text", "label": "Group identifier with respect to which compare", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "rest", "argument": null, "type": "select", "label": "Comparison", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "rest", "options": [["Compare each group to the union of the rest of the group", "rest", false], ["Compare with respect to a specific group", "group_id", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "n_genes", "argument": "n_genes", "type": "integer", "label": "The number of genes that appear in the returned tables", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "tl_rank_genes_groups_method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "t-test", "inputs": []}, {"model_class": "ConditionalWhen", "value": "wilcoxon", "inputs": []}, {"model_class": "ConditionalWhen", "value": "t-test_overestim_var", "inputs": []}, {"model_class": "ConditionalWhen", "value": "logreg", "inputs": [{"model_class": "Conditional", "name": "solver", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "newton-cg", "inputs": [{"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "max_iter", "argument": "max_iter", "type": "integer", "label": "Maximum number of iterations taken for the solvers to converge", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "ovr", "options": [["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false], ["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "lbfgs", "inputs": [{"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "max_iter", "argument": "max_iter", "type": "integer", "label": "Maximum number of iterations taken for the solvers to converge", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "ovr", "options": [["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false], ["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "liblinear", "inputs": [{"model_class": "Conditional", "name": "penalty", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "l1", "inputs": []}, {"model_class": "ConditionalWhen", "value": "l2", "inputs": [{"model_class": "BooleanToolParameter", "name": "dual", "argument": "dual", "type": "boolean", "label": "Dual (not primal) formulation?", "help": "Prefer primal when n_samples > n_features", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "customized", "inputs": [{"model_class": "TextToolParameter", "name": "pen", "argument": "pen", "type": "text", "label": "Norm used in the penalization", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "penalty", "argument": "penalty", "type": "select", "label": "Norm used in the penalization", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "l1", "options": [["l1", "l1", false], ["l2", "l2", false], ["customized", "customized", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "intercept_scaling", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "FloatToolParameter", "name": "intercept_scaling", "argument": "intercept_scaling", "type": "float", "label": "Intercept scaling", "help": "x becomes [x, self.intercept_scaling], i.e. a 'synthetic' feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "select", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "True", "options": [["Yes", "True", false], ["No", "False", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "The seed of the pseudo random number generator to use when shuffling the data", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "sag", "inputs": [{"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "The seed of the pseudo random number generator to use when shuffling the data", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_iter", "argument": "max_iter", "type": "integer", "label": "Maximum number of iterations taken for the solvers to converge", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "ovr", "options": [["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false], ["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "saga", "inputs": [{"model_class": "Conditional", "name": "penalty", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "l1", "inputs": []}, {"model_class": "ConditionalWhen", "value": "l2", "inputs": []}, {"model_class": "ConditionalWhen", "value": "customized", "inputs": [{"model_class": "TextToolParameter", "name": "pen", "argument": "pen", "type": "text", "label": "Norm used in the penalization", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "penalty", "argument": "penalty", "type": "select", "label": "Norm used in the penalization", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "l1", "options": [["l1", "l1", false], ["l2", "l2", false], ["customized", "customized", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "ovr", "options": [["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false], ["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", false]], "display": null, "multiple": false, "textable": false}]}], "test_param": {"model_class": "SelectToolParameter", "name": "solver", "argument": "solver", "type": "select", "label": "Algorithm to use in the optimization problem", "help": "For small datasets, \u2018liblinear\u2019 is a good choice, whereas \u2018sag\u2019 and \u2018saga\u2019 are faster for large ones. For multiclass problems, only \u2018newton-cg\u2019, \u2018sag\u2019, \u2018saga\u2019 and \u2018lbfgs\u2019 handle multinomial loss; \u2018liblinear\u2019 is limited to one-versus-rest schemes. \u2018newton-cg\u2019, \u2018lbfgs\u2019 and \u2018sag\u2019 only handle L2 penalty, whereas \u2018liblinear\u2019 and \u2018saga\u2019 handle L1 penalty.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "newton-cg", "options": [["newton-cg", "newton-cg", false], ["lbfgs", "lbfgs", false], ["liblinear", "liblinear", false], ["sag", "sag", false], ["saga", "saga", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "FloatToolParameter", "name": "tol", "argument": "tol", "type": "float", "label": "Tolerance for stopping criteria", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0001", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "c", "argument": "c", "type": "float", "label": "Inverse of regularization strength", "help": "It must be a positive float. Like in support vector machines, smaller values specify stronger regularization.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "t-test_overestim_var", "options": [["t-test", "t-test", false], ["Wilcoxon-Rank-Sum", "wilcoxon", false], ["t-test with overestimate of variance of each group", "t-test_overestim_var", true], ["Logistic regression", "logreg", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "only_positive", "argument": "only_positive", "type": "boolean", "label": "Only consider positive differences?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method used for plotting", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "tl.louvain", "options": [["Cluster cells into subgroups, using `tl.louvain`", "tl.louvain", false], ["Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `pp.pca`", "pp.pca", false], ["Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `tl.pca`", "tl.pca", false], ["Diffusion Maps, using `tl.diffmap`", "tl.diffmap", false], ["t-distributed stochastic neighborhood embedding (tSNE), using `tl.tsne`", "tl.tsne", false], ["Embed the neighborhood graph using UMAP, using `tl.umap`", "tl.umap", false], ["Compute a neighborhood graph of observations, using `pp.neighbors`", "pp.neighbors", false], ["Rank genes for characterizing groups, using `tl.rank_genes_groups`", "tl.rank_genes_groups", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "anndata_output_format", "argument": null, "type": "select", "label": "Format to write the annotated data matrix", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "loom", "options": [["loom", "loom", false], ["h5ad-formatted hdf5 (anndata)", "h5ad", false]], "display": null, "multiple": false, "textable": false}], "outputs": [{"model_class": "ToolOutput", "name": "anndata_out_h5ad", "format": "h5", "label": "${tool.name} on ${on_string}: Annotated data matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "anndata.h5ad", "edam_format": "format_3590", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "anndata_out_loom", "format": "loom", "label": "${tool.name} on ${on_string}: Annotated data matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "anndata.loom", "edam_format": "format_3590", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "X_pca", "format": "tabular", "label": "${tool.name} on ${on_string}: PCA representation of data", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "PCs", "format": "tabular", "label": "${tool.name} on ${on_string}: Principal components containing the loadings", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "variance_ratio", "format": "tabular", "label": "${tool.name} on ${on_string}: Ratio of explained variance", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "variance", "format": "tabular", "label": "${tool.name} on ${on_string}: Explained variance, equivalent to the eigenvalues of the covariance matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "X_diffmap", "format": "tabular", "label": "${tool.name} on ${on_string}: Diffusion map representation", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "X_tsne", "format": "tabular", "label": "${tool.name} on ${on_string}: tSNE coordinates", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "X_umap", "format": "tabular", "label": "${tool.name} on ${on_string}: UMAP coordinates", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "names", "format": "tabular", "label": "${tool.name} on ${on_string}: Gene names", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "scores", "format": "tabular", "label": "${tool.name} on ${on_string}: Scores", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "single-cell", "panel_section_name": "Single-cell", "form_style": "regular"}