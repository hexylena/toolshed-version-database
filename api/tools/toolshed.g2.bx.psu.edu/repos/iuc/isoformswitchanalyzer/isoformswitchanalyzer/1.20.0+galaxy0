{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/isoformswitchanalyzer/isoformswitchanalyzer/1.20.0+galaxy5", "name": "IsoformSwitchAnalyzeR", "version": "1.20.0+galaxy5", "description": "statistical identification of isoform switching", "labels": [], "edam_operations": [], "edam_topics": [], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "IsoformSwitchAnalyzeR", "reftype": "bio.tools"}, {"value": "isoformswitchanalyzer", "reftype": "bioconductor"}], "tool_shed_repository": {"name": "isoformswitchanalyzer", "owner": "iuc", "changeset_revision": "298d81e5e138", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "Conditional", "name": "functionMode", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "data_import", "inputs": [{"model_class": "Conditional", "name": "tool_source", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "salmon", "inputs": [{"model_class": "Section", "name": "first_factor", "type": "section", "title": "1: Factor level", "help": null, "expanded": true, "inputs": [{"model_class": "TextToolParameter", "name": "factorLevel", "argument": null, "type": "text", "label": "First factor level", "help": "Only letters, numbers and underscores will be retained in this field", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "FactorLevel", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "trans_counts", "argument": null, "type": "data", "label": "Transcript-level expression measurements", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "Section", "name": "second_factor", "type": "section", "title": "2: Factor level", "help": null, "expanded": true, "inputs": [{"model_class": "TextToolParameter", "name": "factorLevel", "argument": null, "type": "text", "label": "Second factor level", "help": "Only letters, numbers and underscores will be retained in this field", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "FactorLevel", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "trans_counts", "argument": null, "type": "data", "label": "Transcript-level expression measurements", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}]}, {"model_class": "ConditionalWhen", "value": "kallisto", "inputs": [{"model_class": "Section", "name": "first_factor", "type": "section", "title": "1: Factor level", "help": null, "expanded": true, "inputs": [{"model_class": "TextToolParameter", "name": "factorLevel", "argument": null, "type": "text", "label": "First factor level", "help": "Only letters, numbers and underscores will be retained in this field", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "FactorLevel", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "trans_counts", "argument": null, "type": "data", "label": "Transcript-level expression measurements", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "Section", "name": "second_factor", "type": "section", "title": "2: Factor level", "help": null, "expanded": true, "inputs": [{"model_class": "TextToolParameter", "name": "factorLevel", "argument": null, "type": "text", "label": "Second factor level", "help": "Only letters, numbers and underscores will be retained in this field", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "FactorLevel", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "trans_counts", "argument": null, "type": "data", "label": "Transcript-level expression measurements", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}]}, {"model_class": "ConditionalWhen", "value": "stringtie", "inputs": [{"model_class": "Section", "name": "first_factor", "type": "section", "title": "1: Factor level", "help": null, "expanded": true, "inputs": [{"model_class": "TextToolParameter", "name": "factorLevel", "argument": null, "type": "text", "label": "First factor level", "help": "Only letters, numbers and underscores will be retained in this field", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "FactorLevel", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "trans_counts", "argument": null, "type": "data", "label": "Transcript-level expression measurements", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "Section", "name": "second_factor", "type": "section", "title": "2: Factor level", "help": null, "expanded": true, "inputs": [{"model_class": "TextToolParameter", "name": "factorLevel", "argument": null, "type": "text", "label": "Second factor level", "help": "Only letters, numbers and underscores will be retained in this field", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "FactorLevel", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "trans_counts", "argument": null, "type": "data", "label": "Transcript-level expression measurements", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "IntegerToolParameter", "name": "averageSize", "argument": null, "type": "integer", "label": "Average read length", "help": "Must be the number of base pairs sequenced. e.g. if the data                          quantified is 75 bp paired ends the the user should supply readLength=75", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "150", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "fixStringTieAnnotationProblem", "argument": "fixStringTieAnnotationProblem", "type": "boolean", "label": "Fix StringTie annotation problem", "help": "This option will automatically try and correct some of the annoation problems created when                                  doing transcript assembly (unassigned transcripts and merged genes)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--fixStringTieAnnotationProblem", "falsevalue": ""}, {"model_class": "Conditional", "name": "novoisoforms", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "novel", "inputs": [{"model_class": "DataToolParameter", "name": "stringtieAnnotation", "argument": null, "type": "data", "label": "Annotation generated by StringTie merge", "help": "The merged GTF is used to recalculate expression estimates using the merged, novel transcripts.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["gtf", "gtf.gz"], "edam": {"edam_formats": ["format_2306", null], "edam_data": ["data_1255", null]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "ConditionalWhen", "value": "reference", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Analysis mode", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "novel", "options": [["Include novel isoforms in analysis", "novel", false], ["Reference-only analysis", "reference", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Quantification data source", "help": "IsoformSwitchAnalyzeR has different functions for importing data from different sources.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "stringtie", "options": [["StringTie", "stringtie", false], ["Salmon", "salmon", false], ["Kallisto", "kallisto", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "DataToolParameter", "name": "genomeAnnotation", "argument": null, "type": "data", "label": "Genome annotation", "help": "It is used to integrate the coding sequence (CDS) regions from in the GTF file as the ORF regions used by IsoformSwitchAnalyzeR.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["gtf", "gtf.gz"], "edam": {"edam_formats": ["format_2306", null], "edam_data": ["data_1255", null]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "DataToolParameter", "name": "transcriptome", "argument": null, "type": "data", "label": "Transcriptome", "help": "Please note this different from a fasta file with the sequences of the entire genome.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta", "fasta.gz"], "edam": {"edam_formats": ["format_1929", "format_1929"], "edam_data": ["data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "BooleanToolParameter", "name": "removeNonConvensionalChr", "argument": "removeNonConvensionalChr", "type": "boolean", "label": "Remove non-conventional chromosomes", "help": "These regions are typically used to annotate regions that cannot be associated to a specific region.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--removeNonConvensionalChr", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "pairedSamples", "argument": "pairedSamples", "type": "boolean", "label": "Paired samples between factors", "help": "Samples                      from different factors belong to the same individual (e.g. samples from same patient from health and cancerous tissues or different parts from the same plant)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--pairedSamples", "falsevalue": ""}, {"model_class": "SelectToolParameter", "name": "countFiles", "argument": null, "type": "select", "label": "Generate count matrix files", "help": "If IsoformSwitchAnalyzeR is used for fixing Stringtie annotation                     problem, it can generate count files for analyzing differential expression with DESeq2 (when selecting collection) or CEMiTool (when secting the expression matrix format).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "disabled", "options": [["Disabled", "disabled", false], ["Collection of count files", "collection", false], ["Expression matrix", "matrix", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "first_step", "inputs": [{"model_class": "DataToolParameter", "name": "robject", "argument": null, "type": "data", "label": "IsoformSwitchAnalyzeR R object", "help": "It is generated when running the analysis part 1.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["rdata"], "edam": {"edam_formats": ["format_2333"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Alpha value", "help": "The cutoff which the FDR correct p-values must be smaller              than for calling significant switches.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dIFcutoff", "argument": "dIFcutoff", "type": "float", "label": "dIFcutoff", "help": "The cutoff which the changes in (absolute) isoform usage              must be larger than before an isoform is considered switching. This cutoff can remove cases where isoforms with (very) low dIF values are deemed              significant and thereby included in the downstream analysis. This cutoff is analogous to having a cutoff on log2 fold change in a normal differential             expression analysis of genes to ensure the genes have a certain effect size. Default is 0.1 (10%)", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.1", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "onlySigIsoforms", "argument": "onlySigIsoforms", "type": "boolean", "label": "Only significantly differential              used isoforms", "help": "This parameter indicates whether both isoforms the pairs considered if reduceFurtherToGenesWithConsequenshould be significantly              differential used (as indicated by the alpha and dIFcutoff parameters). Default is disabled (aka only one of the isoforms in a pair should be             significantly differential used)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--onlySigIsoforms", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "filterForConsequences", "argument": "filterForConsequences", "type": "boolean", "label": "Filter for consquences", "help": "Filter for genes with functional consequences. The output will then be the number of significant genes                      and isoforms originating from genes with predicted consequences", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--filterForConsequences", "falsevalue": ""}, {"model_class": "Section", "name": "prefilter", "type": "section", "title": "Pre-filter parameters", "help": "SwitchAnalyzeR will remove genes/isoforms with the aim of allowing faster                     processing time as well as more trustworthy results.", "expanded": false, "inputs": [{"model_class": "FloatToolParameter", "name": "geneExpressionCutoff", "argument": "geneExpressionCutoff", "type": "float", "label": "Gene expression cutoff", "help": "The expression cutoff (most                          likely in TPM/RPKM/FPKM) which the average expression in BOTH condisions must be higher than.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "isoformExpressionCutoff", "argument": "isoformExpressionCutoff", "type": "float", "label": "Isoform expresion cutoff", "help": "The expression cutoff (most                          likely in RPKM/FPKM) which isoforms must be expressed more than, in at least one conditions of a comparison. Default is 0 (which removes                          completely unused isoforms).", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "IFcutoff", "argument": "IFcutoff", "type": "float", "label": "IFcutoff", "help": "The cutoff on isoform usage (measured as Isoform Fraction) which isoforms must be used more                          than in at least one conditions of a comparison", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.01", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "removeSingleIsformGenes", "argument": "removeSingleIsformGenes", "type": "boolean", "label": "Remove single isoform genes", "help": "Only keep genes containing more than one isoform (in any comparison, after the other filters have been applied)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--removeSingleIsformGenes", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "keepIsoformInAllConditions", "argument": "keepIsoformInAllConditions", "type": "boolean", "label": "Keep isoforms in all conditions", "help": "This parameter indicates whether an isoform should be kept in all comparisons even if it is only deemed significant (as defined by the              alpha and dIFcutoff parameters) in one comparison", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--keepIsoformInAllConditions", "falsevalue": ""}]}, {"model_class": "Section", "name": "dexseq", "type": "section", "title": "DEXseq parameters", "help": "DEXSeq is used to test isoforms (isoform resolution) for differential isoform usage.", "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "correctForConfoundingFactors", "argument": "correctForConfoundingFactors", "type": "boolean", "label": "Correct for confounding factors", "help": "A logic indicating whether IsoformSwitchAnalyzeR to use limma to correct for any confounding effects (e.g. batch effects) as indicated in the                          design matrix (as additional columns (apart from the two default columns)) ", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--correctForConfoundingFactors", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "overwriteIFvalues", "argument": "overwriteIFvalues", "type": "boolean", "label": "Overwrite IF values", "help": "It indicates                          whether to overwrite the IF and dIF stored in the switchAnalyzeRlist with the corrected IF and dIF values - if no confounding effects are                         present in the design matrix this will not change anything", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--overwriteIFvalues", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "reduceToSwitchingGenes", "argument": "reduceToSwitchingGenes", "type": "boolean", "label": "Reduce to switch genes", "help": "Reduced to the                         genes which contains at least one isoform significantly differential used (as indicated by the alpha and dIFcutoff parameters", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--reduceToSwitchingGenes", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "reduceFurtherToGenesWithConsequencePotential", "argument": "reduceFurtherToGenesWithConsequencePotential", "type": "boolean", "label": "Reduce to genes with consequence potential", "help": "This argument is a more strict version of reduceToSwitchingGenes                             as it not only requires that at least one isoform is significantly differential used (as indicated by the alpha and dIFcutoff parameters) but also that there is an isoform                              with the opposite effect size (e.g. used less if the first isoform is used more). The minimum effect size of the opposing isoform usage is also controlled by dIFcutoff.                              The existence of such an opposing isoform means a switch pair can be formed", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--reduceFurtherToGenesWithConsequencePotential", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "keepIsoformInAllConditions", "argument": "keepIsoformInAllConditions", "type": "boolean", "label": "Keep isoforms in all conditions", "help": "This parameter indicates whether an isoform should be kept in all comparisons even if it is only deemed significant (as defined by the              alpha and dIFcutoff parameters) in one comparison", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--keepIsoformInAllConditions", "falsevalue": ""}]}, {"model_class": "Section", "name": "novel_isoform", "type": "section", "title": "Novel isoform analysis parameters", "help": "For the subset of isoforms not already annotated with ORFs this                      function predicts the most likely Open Reading Frame (ORF) and the NMD sensitivity. This function is made to help annotate                     isoforms if you have performed (guided) de-novo isoform reconstruction (isoform deconvolution).", "expanded": false, "inputs": [{"model_class": "IntegerToolParameter", "name": "minORFlength", "argument": "minORFlength", "type": "integer", "label": "Minimum ORF length", "help": "The minimum size (in nucleotides) an                          ORF must be to be considered (and reported). Default is 100 nucleotides, which around 97.5% of Gencode coding isoforms in both human and mouse have.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "orfMethod", "argument": "orfMethod", "type": "select", "label": "ORF identification method", "help": "More information in the help section", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "longest.AnnotatedWhenPossible", "options": [["Longest and annotated when possible", "longest.AnnotatedWhenPossible", false], ["Longest", "longest", false], ["Most upstream", "mostUpstream", false], ["Longest annotated", "longestAnnotated", false], ["Most upstream annotated", "mostUpstreamAnnoated", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "PTCDistance", "argument": "PTCDistance", "type": "integer", "label": "Maximal allowed premature termination codon-distance", "help": "The minimum                          distance (number of nucleotides) from the STOP codon to the final exon-exon junction. If the distance from the STOP to the final exon-exon                         junction is larger than this the isoform to be marked as NMD-sensitive. ", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}]}, {"model_class": "Section", "name": "extract_sequence", "type": "section", "title": "Sequence extraction parameters", "help": "switchAnalyzeR will extracts the nucleotide (NT) sequence of transcripts by                      extracting and concatenating the sequences of a reference genome corresponding to the genomic coordinates of the isoforms. ", "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "onlySwitchingGenes", "argument": "onlySwitchingGenes", "type": "boolean", "label": "Only switching genes", "help": "Only              analyze genes with isoform switches (as indicated by the alpha and dIFcutoff parameters)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--onlySwitchingGenes", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "removeShortAAseq", "argument": "removeShortAAseq", "type": "boolean", "label": "Remove short aminoacid sequences", "help": "This                          option exist to allows for easier usage of the Pfam and SignalP web servers which both currently have restrictions on allowed sequence lengths. If                          enabled AA sequences are filtered to be > 5 AA. This will only affect the sequences written to the FASTA file not the sequences added to the switchAnalyzeRlist", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--removeShortAAseq", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "removeLongAAseq", "argument": "removeLongAAseq", "type": "boolean", "label": "Remove long aminoacid sequences", "help": "A                          logical indicating whether to removesequences based on their length. This option exist to allows for easier usage of the Pfam and SignalP web servers                         which both currently have restrictions on allowed sequence lengths. If enabled AA sequences are filtered to be smaller 1000 AA. This will only affect the                          sequences written to the fasta file (if writeToFile=TRUE) not the sequences added to the switchAnalyzeRlist. ", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--removeLongAAseq", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "removeORFwithStop", "argument": "removeORFwithStop", "type": "boolean", "label": "Remove ORFs containint STOP codons", "help": "ORFs                          containing stop codons, defined as * when the ORF nucleotide sequences is translated to the amino acid sequence, should be A) removed from the ORF                          annotation in the switchAnalyzeRlist and B) removed from the sequences added to the switchAnalyzeRlist and/or written to FASTA files. This is only                          necessary if you are analyzing quantified known annotated data where you supplied a GTF file to the import function", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--removeORFwithStop", "falsevalue": ""}]}, {"model_class": "SelectToolParameter", "name": "outputs_first", "argument": null, "type": "select", "label": "Outputs selector", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": ["nt", "aa", "summary"], "options": [["Nucleotide sequences", "nt", true], ["Aminoacid sequences", "aa", true], ["Gene switch summary", "summary", true]], "display": "checkboxes", "multiple": true, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "second_step", "inputs": [{"model_class": "DataToolParameter", "name": "robject", "argument": null, "type": "data", "label": "IsoformSwitchAnalyzeR R object", "help": "It is generated when running the analysis part 2.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["rdata"], "edam": {"edam_formats": ["format_2333"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "analysis_mode", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "top", "inputs": [{"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Alpha value", "help": "The cutoff which the FDR correct p-values must be smaller              than for calling significant switches.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dIFcutoff", "argument": "dIFcutoff", "type": "float", "label": "dIFcutoff", "help": "The cutoff which the changes in (absolute) isoform usage              must be larger than before an isoform is considered switching. This cutoff can remove cases where isoforms with (very) low dIF values are deemed              significant and thereby included in the downstream analysis. This cutoff is analogous to having a cutoff on log2 fold change in a normal differential             expression analysis of genes to ensure the genes have a certain effect size. Default is 0.1 (10%)", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "Number of top switching features (genes/isoforms) to plot", "help": "This parameters allows to specify the number of top genes/isoforms to plot", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "Section", "name": "advanced_options", "type": "section", "title": "Full analysis advanced options", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "filterForConsequences", "argument": "filterForConsequences", "type": "boolean", "label": "Filter genes with functional consequences", "help": "The output will then be the number of significant genes and isoforms originating from genes with predicted consequences", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--filterForConsequences", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "sortByQvals", "argument": "sortByQvals", "type": "boolean", "label": "Sorting mode", "help": "A logic indicating                                  whether to the top n features are sorted by decreasing significance (increasing q-values) (if enabled) or decreasing switch size                                  (absolute dIF, which are still significant as defined by alpha) (if disabled). The dIF values for genes are considered as the total                                  change within the gene calculated as sum(abs(dIF)) for each gene", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--sortByQvals", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "onlySigIsoforms", "argument": "onlySigIsoforms", "type": "boolean", "label": "Only significantly differential              used isoforms", "help": "This parameter indicates whether to only consider significant isoforms, meaning only analyzing genes where at least two isoforms              which both have significant usage changes in opposite direction (quite strict). Naturally this only works if the isoform switch test used have isoform              resolution (which the build in *isoformSwitchTestDEXSeq* has). If disabled all isoforms with an absolute dIF value larger than dIFcutoff in a gene with              significant switches (defined by alpha and dIFcutoff) are included in the pairwise comparison", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--onlySigIsoforms", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "onlySwitchingGenes", "argument": "onlySwitchingGenes", "type": "boolean", "label": "Only switching genes", "help": "Only              analyze genes with isoform switches (as indicated by the alpha and dIFcutoff parameters)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--onlySwitchingGenes", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "countGenes", "argument": "countGenes", "type": "boolean", "label": "Number genes or isoform switches counts", "help": "This parameter indicates                                  whether it is the number of genes (if enabled) or isoform switches (if disabled) which primary result in gain/loss that are counted", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--countGenes", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "asFractionTotal", "argument": "asFractionTotal", "type": "boolean", "label": "Summary as numbers of as fraction", "help": "The consequences/splicing events                                  should be summarized calculated as numbers (if disabled) or as a fraction of the total number of switches/genes", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--asFractionTotal", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "plotGenes", "argument": "plotGenes", "type": "boolean", "label": "Plot number/fraction of genes or isoforms", "help": "Plot the number/fraction of genes with                                  (if enabled) or isoforms (if disabled) involved with isoform switches with functional consequences  (both filtered via alpha and dIFcutoff)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--plotGenes", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "simplifyLocation", "argument": "simplifyLocation", "type": "boolean", "label": "Simplify location", "help": "Simplify the switches involved in changes                                  in subcellular localizations (due the the hundreds of possible combinations)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--simplifyLocation", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "removeEmptyConsequences", "argument": "removeEmptyConsequences", "type": "boolean", "label": "Remove empty consequences", "help": "Remove consequenses analyzed                                  but where no differences was found (those showing zero in the plot)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--removeEmptyConsequences", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "analysisOppositeConsequence", "argument": "analysisOppositeConsequence", "type": "boolean", "label": "Analysis opposite consequences in enrichment analysis", "help": "Reverse the analysis meaning if 'Domain gains' are analyze will case the analysis to be performed on 'Domain loss'.                                      The main effect is for the visual appearance of plot which will be mirrored (around the 0.5 fraction)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--analysisOppositeConsequence", "falsevalue": ""}]}]}, {"model_class": "ConditionalWhen", "value": "single", "inputs": [{"model_class": "TextToolParameter", "name": "gene", "argument": "gene", "type": "text", "label": "Gene name", "help": "Either the gene_id or the gene name of the gene to plot", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Alpha value", "help": "The cutoff which the FDR correct p-values must be smaller              than for calling significant switches.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dIFcutoff", "argument": "dIFcutoff", "type": "float", "label": "dIFcutoff", "help": "The cutoff which the changes in (absolute) isoform usage              must be larger than before an isoform is considered switching. This cutoff can remove cases where isoforms with (very) low dIF values are deemed              significant and thereby included in the downstream analysis. This cutoff is analogous to having a cutoff on log2 fold change in a normal differential             expression analysis of genes to ensure the genes have a certain effect size. Default is 0.1 (10%)", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.1", "area": false, "datalist": []}, {"model_class": "Section", "name": "advanced_options", "type": "section", "title": "Single gene mode advanced options", "help": null, "expanded": false, "inputs": [{"model_class": "FloatToolParameter", "name": "IFcutoff", "argument": "IFcutoff", "type": "float", "label": "IFcutoff", "help": "The cutoff used for the minimum contribution to gene expression (in at least one                                  condition) for an isoforms must have to be plotted (measured as Isoform Fraction (IF) values)", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "rescaleTranscripts", "argument": "rescaleTranscripts", "type": "boolean", "label": "Rescale transcripts", "help": "All the isoforms should be resealed to the square root of their original sizes. This feature is implemented because                                      introns usually are much larger than exons making it difficult to see structural changes. This is very useful for structural                                      visualization but the scaling might distort actual intron and exon sizes", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--rescaleTranscripts", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "reverseMinus", "argument": "reverseMinus", "type": "boolean", "label": "Isoforms on minus strand                                  should be inverted", "help": "Isoforms on minus strand should be inverted so they are visualized as going from left to right                                  instead of right to left", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--reverseMinus", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "addErrorbars", "argument": "addErrorbars", "type": "boolean", "label": "Add error bars", "help": "Error                                  bars should be added to the expression plots to show uncertainty in estimates", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--addErrorbars", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "onlySwitchingGenes", "argument": "onlySwitchingGenes", "type": "boolean", "label": "Only switching genes", "help": "Only              analyze genes with isoform switches (as indicated by the alpha and dIFcutoff parameters)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--onlySwitchingGenes", "falsevalue": ""}]}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Analysis mode", "help": "This selector allows so specify if you want to analyze a specific gene or                          the (top) switching genes/isoforms ", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "top", "options": [["Full analysis", "top", true], ["Analyze specific gene", "single", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "coding_potential", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "disabled", "inputs": []}, {"model_class": "ConditionalWhen", "value": "cpat", "inputs": [{"model_class": "DataToolParameter", "name": "analyzeCPAT", "argument": "analyzeCPAT", "type": "data", "label": "CPAT result file", "help": " Use default parameters and the nucleotide fasta file (_nt.fasta). If the webserver was used, download the tab-delimited                                  result file (available at the bottom of the result page). If a stand-alone version was used, just supply the path to the result file", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "FloatToolParameter", "name": "codingCutoff", "argument": "codingCutoff", "type": "float", "label": "Coding cutoff", "help": "cutoff used by CPAT for distinguishing between                              coding and non-coding transcripts. The cutoff is dependent on species analyzed. IsoformSwitchAnalyzerR developers suggest that the optimal cutoff                              for overlapping coding and noncoding isoforms are 0.725 for human and 0.721 for mouse. However the suggested cutoffs from the CPAT develpers                              derived by comparing known genes to random non-coding regions of the genome is 0.364 for human and 0.44 for mouse", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.725", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "cpc2", "inputs": [{"model_class": "DataToolParameter", "name": "analyzeCPC2", "argument": "analyzeCPC2", "type": "data", "label": "CPC2 result file", "help": "Use default parameters and if required select the most similar species. If the webserver (batch submission) was used,                                  download the tab-delimited result file (via the \u201cDownload the result\u201d button). If a stand-alone version was just just supply the path to the result file", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "BooleanToolParameter", "name": "removeNoncodingORFs", "argument": "removeNoncodingORFs", "type": "boolean", "label": "Remove non-coding ORFs", "help": "Remove ORF information                              from the isoforms which the CPC2 analysis classifies as non-coding. This can be particular useful if the isoform (and ORF) was predicted de-novo but is not                              recommended if ORFs was imported from a GTF file", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--removeNoncodingORFs", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "codingCutoff", "argument": "codingCutoff", "type": "float", "label": "Coding cutoff", "help": "Numeric indicating the cutoff used by CPC2 for distinguishing                              between coding and non-coding transcripts. The cutoff appears to be species independent.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Include prediction of coding potential information", "help": "Integrate in the analysis de output from CPAT or CPC2.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "disabled", "options": [["Disabled", "disabled", false], ["CPAT", "cpat", false], ["CPC2", "cpc2", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "protein_domains", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "disabled", "inputs": []}, {"model_class": "ConditionalWhen", "value": "enabled", "inputs": [{"model_class": "DataToolParameter", "name": "analyzePFAM", "argument": "analyzePFAM", "type": "data", "label": "Include Pfam results (sequence analysis of protein domains)", "help": "Use default                              parameters and the amino acid fasta file (_AA.fasta). If the webserver is used you need to copy/paste the result part of the mail you receive into an empty plain text                              document (notepad, sublimetext, TextEdit or similar (not Word)) and save that to a plain text (txt) file. The path to that file should be supplied. If a stand-alone                              version was used, just supply the path to the result file", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Include Pfam information", "help": "Pfam is a database of protein families that includes their annotations and multiple sequence                          alignments generated using hidden Markov models.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "disabled", "options": [["Disabled", "disabled", false], ["Enabled", "enabled", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "signal_peptides", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "disabled", "inputs": []}, {"model_class": "ConditionalWhen", "value": "enabled", "inputs": [{"model_class": "DataToolParameter", "name": "analyzeSignalP", "argument": "analyzeSignalP", "type": "data", "label": "SignalP", "help": "Use the amino acid fasta file (_AA.fasta). If using the webserver SignalP                              should be run with the parameter 'Short output (no figures)' under 'Output format' and one should select the appropriate 'Organism group'. When                              using a stand-alone version SignalP should be run with the '-f summary' option. If using the webserver the results can be downloaded using the                              'Downloads' button in the top-right corner where the user should select 'Prediction summary' and supply the path to the resulting file to the                              'pathToSignalPresultFile' argument. If a stand-alone version was just supply the path to the summary result file.", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "FloatToolParameter", "name": "minSignalPeptideProbability", "argument": "minSignalPeptideProbability", "type": "float", "label": "Minimum probability for calling a signal peptide", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Include SignalP results", "help": "Integration of the result of SignalP (external sequence analysis of signal peptides)", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "disabled", "options": [["Disabled", "disabled", false], ["Enabled", "enabled", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "disordered_regions", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "disabled", "inputs": []}, {"model_class": "ConditionalWhen", "value": "iupred2a", "inputs": [{"model_class": "DataToolParameter", "name": "AanalyzeIUPred2A", "argument": "AanalyzeIUPred2A", "type": "data", "label": "IUPred2A result file", "help": "Can be gziped. If                             multiple result files were created (multiple web-server runs) just supply all of them.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt", "gz"], "edam": {"edam_formats": ["format_2330", "format_2333"], "edam_data": ["data_0006", "data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "smoothingWindowSize", "argument": "smoothingWindowSize", "type": "integer", "label": "Smoothing window size", "help": "An integer indicating how              large a sliding window should be used to calculate a smoothed (via mean) disordered probability score of a particular position in             a peptide. This has as a smoothing effect which prevents IDRs from not being detected (or from being split into sub-IDRs) by a              single residue with low probability. The trade off is worse accuracy of detecting the exact edges of the IDRs. To turn it off              smoothing simply set to 1.", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "probabilityCutoff", "argument": "probabilityCutoff", "type": "float", "label": "Probability cutoff", "help": "Cutoff applied to the (smoothed)              disordered probability score for calling a residue as disordered. The default, 30 amino acids, is an accepted standard for long IDRs", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "minIdrSize", "argument": "minIdrSize", "type": "integer", "label": "Minimum IDR size", "help": "How long a stretch of disordered amino acid              constitute the region part of the Intrinsically Disordered Region (IDR) definition. The default, 30 amino acids, is an accepted              standard for long IDRs", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "30", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "annotateBindingSites", "argument": "annotateBindingSites", "type": "boolean", "label": "Annotate binding sites", "help": "Integrate the ANCHOR2 prediction of Intrinsically Disordered Binding Regions (IDBRs)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--annotateBindingSites", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "minIdrBindingSize", "argument": "minIdrBindingSize", "type": "integer", "label": "Minimum IDBR binding size", "help": "How long a stretch of                              binding site the region part of the Intrinsically Disordered Binding Regions (IDBR)", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "minIdrBindingOverlapFrac", "argument": "minIdrBindingOverlapFrac", "type": "float", "label": "Minimum fraction of a predicted IDBR", "help": "Minimum                              fraction of a predicted IDBR must also be within a IDR before the IDR is considered as a an IDR with a binding region", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.8", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "netsurfp", "inputs": [{"model_class": "DataToolParameter", "name": "analyzeNetSurfP2", "argument": "analyzeNetSurfP2", "type": "data", "label": "NetSurfP-2 result file", "help": "Can be gziped. If                             multiple result files were created (multiple web-server runs) just supply all of them.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt", "gz"], "edam": {"edam_formats": ["format_2330", "format_2333"], "edam_data": ["data_0006", "data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "smoothingWindowSize", "argument": "smoothingWindowSize", "type": "integer", "label": "Smoothing window size", "help": "An integer indicating how              large a sliding window should be used to calculate a smoothed (via mean) disordered probability score of a particular position in             a peptide. This has as a smoothing effect which prevents IDRs from not being detected (or from being split into sub-IDRs) by a              single residue with low probability. The trade off is worse accuracy of detecting the exact edges of the IDRs. To turn it off              smoothing simply set to 1.", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "probabilityCutoff", "argument": "probabilityCutoff", "type": "float", "label": "Probability cutoff", "help": "Cutoff applied to the (smoothed)              disordered probability score for calling a residue as disordered. The default, 30 amino acids, is an accepted standard for long IDRs", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "minIdrSize", "argument": "minIdrSize", "type": "integer", "label": "Minimum IDR size", "help": "How long a stretch of disordered amino acid              constitute the region part of the Intrinsically Disordered Region (IDR) definition. The default, 30 amino acids, is an accepted              standard for long IDRs", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "30", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Include prediction of intrinsically disordered Regions (IDR) information", "help": "Integrate in the analysis de output from IUPred2A or NetSurfP-2", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "disabled", "options": [["Disabled", "disabled", false], ["IUPred2A", "iupred2a", false], ["NetSurfP-2", "netsurfp", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "analyzeSwitchConsequences", "type": "section", "title": "Analyze switch consequences parameters", "help": null, "expanded": false, "inputs": [{"model_class": "IntegerToolParameter", "name": "ntCutoff", "argument": "ntCutoff", "type": "integer", "label": "Nucleotide length cutoff", "help": "The length difference (in nucleotides) a                          comparison must be larger than for reporting differences", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "ntFracCutoff", "argument": "ntFracCutoff", "type": "float", "label": "Nucleotide length fraction cutoff", "help": "The cutoff in length                          difference, measured as a fraction of the length of the downregulated isoform, a comparison must be larger than for                         reporting differences. For example does 0.05 mean the upregulated isoform must be 5% longer/shorter before it is reported. ", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "ntJCsimCutoff", "argument": "ntJCsimCutoff", "type": "float", "label": "Cutoff on Jaccard similarity between the overlap of two nucloetide sequences", "help": " If the                         measured JCsim is smaller than this cutoff the sequences are considered different and reported as such", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.8", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "AaCutoff", "argument": "AaCutoff", "type": "integer", "label": "Aminoacid lenght cutoff", "help": "Length difference (in AA) a comparison must be larger                         than for reporting differences when evaluating \u2019ORF_seq_similarity\u2019, primarily implemented to avoid differences in very short AA sequences being                          classified as different", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "AaFracCutoff", "argument": "AaFracCutoff", "type": "float", "label": "Aminoacid length fraction cutoff", "help": "Cutoff of length difference of                          the protein domain or IDR. The difference is measured as a fraction of the longest region, a comparison must be larger than before reporting it", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "AaJCsimCutoff", "argument": "AaJCsimCutoff", "type": "float", "label": "Cutoff between the overlap of two aminoacid sequences", "help": "If the                         measured JCsim is smaller than this cutoff the sequences are considered different and reported as such", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.9", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "removeNonConseqSwitches", "argument": "removeNonConseqSwitches", "type": "boolean", "label": "Remove the comparison of isoforms                          where no consequences were found", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--removeNonConseqSwitches", "falsevalue": ""}]}]}], "test_param": {"model_class": "SelectToolParameter", "name": "selector", "argument": null, "type": "select", "label": "Tool function mode", "help": "The first step of a IsoformSwitchAnalyzeR workflow is to import and integrate the isoform quantification                      with its basic annotation. Once you have all the relevant data imported into R (IsoformSwitchAnalyzeR will                      also help you with that), the workflow for identification and analysis of isoform switches with functional                      consequences can be divided into two parts.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "data_import", "options": [["Import data", "data_import", false], ["Analysis part one: Extract isoform switches and their sequences", "first_step", false], ["Analysis part two: Plot all isoform switches and their annotation", "second_step", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutputCollection", "name": "collection_counts_factor1", "format": null, "label": "${tool.name} on ${on_string}: gene counts factor1", "hidden": false, "output_type": "collection", "default_format": "data", "default_format_source": null, "default_metadata_source": null, "inherit_format": false, "inherit_metadata": false, "structure": {"collection_type": "list", "collection_type_source": null, "collection_type_from_rules": null, "structured_like": null, "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": "tabular", "visible": false, "assign_primary_output": false, "directory": "count_files/factor1", "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "(?P<designation>.*)\\.(?P<ext>[^\\._]+)?", "sort_by": "filename"}]}}, {"model_class": "ToolOutputCollection", "name": "collection_counts_factor2", "format": null, "label": "${tool.name} on ${on_string}: gene counts factor2", "hidden": false, "output_type": "collection", "default_format": "data", "default_format_source": null, "default_metadata_source": null, "inherit_format": false, "inherit_metadata": false, "structure": {"collection_type": "list", "collection_type_source": null, "collection_type_from_rules": null, "structured_like": null, "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": "tabular", "visible": false, "assign_primary_output": false, "directory": "count_files/factor2", "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "(?P<designation>.*)\\.(?P<ext>[^\\._]+)?", "sort_by": "filename"}]}}, {"model_class": "ToolOutputCollection", "name": "plots_summary", "format": null, "label": "${tool.name} on ${on_string}: genome wide plots", "hidden": false, "output_type": "collection", "default_format": "data", "default_format_source": null, "default_metadata_source": null, "inherit_format": false, "inherit_metadata": false, "structure": {"collection_type": "list", "collection_type_source": null, "collection_type_from_rules": null, "structured_like": null, "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": "pdf", "visible": false, "assign_primary_output": false, "directory": "pdf_outputs", "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "(?P<designation>.*)\\.(?P<ext>[^\\._]+)?", "sort_by": "filename"}]}}, {"model_class": "ToolOutputCollection", "name": "genes_consequences", "format": null, "label": "${tool.name} on ${on_string}: isoform switches with predicted functional consequences plots", "hidden": false, "output_type": "collection", "default_format": "data", "default_format_source": null, "default_metadata_source": null, "inherit_format": false, "inherit_metadata": false, "structure": {"collection_type": "list", "collection_type_source": null, "collection_type_from_rules": null, "structured_like": null, "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": "pdf", "visible": false, "assign_primary_output": false, "directory": "gene_plots/with_consequences", "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "(?P<designation>.*)\\.(?P<ext>[^\\._]+)?", "sort_by": "filename"}]}}, {"model_class": "ToolOutputCollection", "name": "genes_wo_consequences", "format": null, "label": "${tool.name} on ${on_string}: isoform switches without predicted functional consequences plots", "hidden": false, "output_type": "collection", "default_format": "data", "default_format_source": null, "default_metadata_source": null, "inherit_format": false, "inherit_metadata": false, "structure": {"collection_type": "list", "collection_type_source": null, "collection_type_from_rules": null, "structured_like": null, "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": "pdf", "visible": false, "assign_primary_output": false, "directory": "gene_plots/without_consequences", "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "(?P<designation>.*)\\.(?P<ext>[^\\._]+)?", "sort_by": "filename"}]}}, {"model_class": "ToolOutput", "name": "matrix_counts", "format": "tabular", "label": "${tool.name} on ${on_string}: gene counts matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "count_files/matrix.tabular", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "sample_annotation", "format": "tabular", "label": "${tool.name} on ${on_string}: samples annotation", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "count_files/samples.tabular", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "switchList", "format": "rdata", "label": "${tool.name} on ${on_string}: SwitchList (RData)", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "SwitchList.Rda", "edam_format": "format_2333", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "isoformAA", "format": "fasta", "label": "${tool.name} on ${on_string}: aminoacid sequences", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "isoformSwitchAnalyzeR_isoform_AA.fasta", "edam_format": "format_1929", "edam_data": "data_2044", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "isoformNT", "format": "fasta", "label": "${tool.name} on ${on_string}: nucleotide sequences", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "isoformSwitchAnalyzeR_isoform_nt.fasta", "edam_format": "format_1929", "edam_data": "data_2044", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "switchSummary", "format": "tabular", "label": "${tool.name} on ${on_string}: summary", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "switchSummary.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "mostSwitching", "format": "tabular", "label": "${tool.name} on ${on_string}: switching gene/isoforms", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "mostSwitchingGene.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "consequencesSummary", "format": "tabular", "label": "${tool.name} on ${on_string}: consequences summary", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "consequencesSummary.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "consequencesEnrichment", "format": "tabular", "label": "${tool.name} on ${on_string}: consequences enrichment", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "consequencesEnrichment.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "splicingSummary", "format": "tabular", "label": "${tool.name} on ${on_string}: splicing summary", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "splicingSummary.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "splicingEnrichment", "format": "tabular", "label": "${tool.name} on ${on_string}: splicing enrichment", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "splicingEnrichment.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "splicing_fulldata", "format": "tabular", "label": "${tool.name} on ${on_string}: alternative splicing full data", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "switchSplicing_fulldata.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "consequences_fulldata", "format": "tabular", "label": "${tool.name} on ${on_string}: funcional consequences full data", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "switchConsequence_fulldata.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "isoformFeatures", "format": "tabular", "label": "${tool.name} on ${on_string}: isoform features", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "IsoformFeatures.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "single_gene", "format": "pdf", "label": "${tool.name} on ${on_string}: single gene analysis", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "single_gene.pdf", "edam_format": "format_3508", "edam_data": "data_2968", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "rna_analysis", "panel_section_name": "RNA Analysis", "form_style": "regular"}