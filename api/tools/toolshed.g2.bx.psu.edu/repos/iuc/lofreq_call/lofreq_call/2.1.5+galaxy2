{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/lofreq_call/lofreq_call/2.1.5+galaxy2", "name": "Call variants", "version": "2.1.5+galaxy2", "description": "with LoFreq", "labels": [], "edam_operations": ["operation_3227"], "edam_topics": ["topic_0199", "topic_0622"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "lofreq", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "lofreq_call", "owner": "iuc", "changeset_revision": "4805fe3d8fda", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "reads", "argument": null, "type": "data", "label": "Input reads in BAM format", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam"], "edam": {"edam_formats": ["format_2572"], "edam_data": ["data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "reference_source", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "cached", "inputs": [{"model_class": "SelectToolParameter", "name": "ref", "argument": "--ref", "type": "select", "label": "Reference genome", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": true, "value": null, "options": [], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "history", "inputs": [{"model_class": "DataToolParameter", "name": "ref", "argument": "--ref", "type": "data", "label": "Reference", "help": "Reference sequence", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta"], "edam": {"edam_formats": ["format_1929"], "edam_data": ["data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "ref_selector", "argument": null, "type": "select", "label": "Choose the source for the reference genome", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "cached", "options": [["Locally cached", "cached", false], ["History", "history", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "regions", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "genome", "inputs": []}, {"model_class": "ConditionalWhen", "value": "regions_from_file", "inputs": [{"model_class": "DataToolParameter", "name": "bed", "argument": "--bed", "type": "data", "label": "BED dataset with regions to examine", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bed"], "edam": {"edam_formats": ["format_3003"], "edam_data": ["data_3002"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "restrict_to_region", "argument": null, "type": "select", "label": "Call variants across", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "genome", "options": [["Whole reference", "genome", false], ["Regions specified in BED", "regions_from_file", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "variant_types", "argument": null, "type": "select", "label": "Types of variants to call", "help": "Note: To have indels included in the called variants you HAVE to preprocess your input data using lofreq indelqual to include indel qualities. In addition, it is highly recommended that you calculate and make use of indel alignment qualities. See the detailed tool help below.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["SNVs and indels", "--call-indels", false], ["Only SNVs", "", true], ["Only indels", "--call-indels --only-indels", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "call_control", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "Section", "name": "coverage", "type": "section", "title": "Coverage", "help": null, "expanded": true, "inputs": [{"model_class": "IntegerToolParameter", "name": "min_cov", "argument": "--min-cov", "type": "integer", "label": "Minimal coverage", "help": "Do not attempt variant calling at sites that are not covered by at least this number of reads (default: 1)", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_depth", "argument": "--max-depth", "type": "integer", "label": "Coverage cap", "help": "For efficiency, don not consider more than this number of reads at any site (default: 1,000,000)", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000000", "area": false, "datalist": []}]}, {"model_class": "Section", "name": "pe", "type": "section", "title": "Paired reads", "help": null, "expanded": true, "inputs": [{"model_class": "BooleanToolParameter", "name": "use_orphan", "argument": "--use-orphan", "type": "boolean", "label": "Use reads from anomalously mapped pairs", "help": "Applies to paired-end reads only. If set to true, reads from pairs that are flagged as non-proper pairs (SAM/BAM FLAG field 2) will be used in variant calling. The default is to ignore such reads.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--use-orphan", "falsevalue": ""}]}, {"model_class": "Section", "name": "bc_quals", "type": "section", "title": "Base-calling quality", "help": null, "expanded": true, "inputs": [{"model_class": "IntegerToolParameter", "name": "min_bq", "argument": "--min-bq", "type": "integer", "label": "Minimum baseQ", "help": "For variant calling at any given site, do not consider reads for which the base at that site has a base quality less than this value (default: 6)", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "6", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_alt_bq", "argument": "--min-alt-bq", "type": "integer", "label": "Minimum baseQ for alternate bases", "help": "For variant calling at any given site, do not consider reads that support a non-reference allele at the site if that base has a base quality less than this value (default: 6). Note: this setting will have no effect if the specified value is less than the general Minimum baseQ above.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "6", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "alt_bq", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "", "inputs": []}, {"model_class": "ConditionalWhen", "value": "avg", "inputs": [{"model_class": "HiddenToolParameter", "name": "def_alt_bq", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "-1"}]}, {"model_class": "ConditionalWhen", "value": "custom", "inputs": [{"model_class": "IntegerToolParameter", "name": "def_alt_bq", "argument": "--def-alt-bq", "type": "integer", "label": "Overwrite original base qualities with this value", "help": "", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "modify", "argument": null, "type": "select", "label": "Base quality to use for alternate bases", "help": "After filtering reads according to the Minimum baseQ settings above, you can choose to modify the base qualities of the non-reference bases in the surviving reads before performing further calculations.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Use original base qualities", "", false], ["Use the median of the reference base qualities at the site", "avg", false], ["Use a fixed custom value", "custom", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "align_quals", "type": "section", "title": "Base alignment quality", "help": "Choose here whether you want to incorporate base and/or indel alignment qualities into lofreq's joint quality model. If you have previously computed and stored (using lofreq alnqual) any of these quality scores into your input dataset, you can tell the tool to reuse them. Alternatively, the tool can calculate the necessary scores on the fly.", "expanded": true, "inputs": [{"model_class": "Conditional", "name": "alnqual", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "", "inputs": [{"model_class": "Conditional", "name": "alnqual_choice", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "-B", "inputs": [{"model_class": "HiddenToolParameter", "name": "extended_baq", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": ""}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": [{"model_class": "BooleanToolParameter", "name": "extended_baq", "argument": "-e", "type": "boolean", "label": "If BAQ needs to be computed, calculate extended BAQ?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "-e"}]}, {"model_class": "ConditionalWhen", "value": "-A", "inputs": [{"model_class": "BooleanToolParameter", "name": "extended_baq", "argument": "-e", "type": "boolean", "label": "If BAQ needs to be computed, calculate extended BAQ?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "-e"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "alnquals_to_use", "argument": null, "type": "select", "label": "Use the following alignment quality scores", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Base and indel alignment qualities (BAQ and IDAQ)", "", false], ["Only base alignment qualities (BAQ)", "-A", false], ["Only indel alignment qualities (IDAQ)", "-B", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "--del-baq", "inputs": [{"model_class": "Conditional", "name": "alnqual_choice", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "-B", "inputs": [{"model_class": "HiddenToolParameter", "name": "extended_baq", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": ""}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": [{"model_class": "BooleanToolParameter", "name": "extended_baq", "argument": "-e", "type": "boolean", "label": "Use extended BAQ?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "-e"}]}, {"model_class": "ConditionalWhen", "value": "-A", "inputs": [{"model_class": "BooleanToolParameter", "name": "extended_baq", "argument": "-e", "type": "boolean", "label": "Use extended BAQ?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "-e"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "alnquals_to_use", "argument": null, "type": "select", "label": "Add and use the following alignment quality scores", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Base and indel alignment qualities (BAQ and IDAQ)", "", false], ["Only base alignment qualities (BAQ)", "-A", false], ["Only indel alignment qualities (IDAQ)", "-B", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "-A -B", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "use_alnqual", "argument": null, "type": "select", "label": "Consider base/indel alignment qualities during variant calling?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Yes, and prefer existing alignment qualities encoded in input", "", false], ["Yes, (re)calculate alignment qualities on the fly and use them", "--del-baq", false], ["No, don't make use of alignment qualities", "-A -B", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "map_quals", "type": "section", "title": "Mapping quality", "help": null, "expanded": true, "inputs": [{"model_class": "IntegerToolParameter", "name": "min_mq", "argument": "--min-mq", "type": "integer", "label": "Minimum mapping quality", "help": "For variant calling at any given site, do not consider reads with a mapping quality (MAPQ) less than this value (default: 0 = do not filter on read mapping quality).", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "use_mq", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "", "inputs": [{"model_class": "IntegerToolParameter", "name": "max_mq", "argument": "--max-mq", "type": "integer", "label": "Maximum mapping quality", "help": "For the joint quality model at any site, cap the mapping quality of reads at this value (default: 255 = do not cap mapping qualities). Notes: 1) You cannot cap mapping qualities at less than the minimum MAPQ defined above. If you try, MAPQs will be capped at that minimum quality instead. 2) The special MAPQ value 255 is used by many tools to indicate undefined mapping quality, and lofreq call will ignore such reads during variant calling. Capping, however, will turn 255 into a regular MAPQ score. Thus, if you need to avoid using such reads, you should filter out MAPQ 255 reads from your input data with other tools before using lofreq call with MAPQ capping.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "255", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "--no-mq", "inputs": [{"model_class": "HiddenToolParameter", "name": "max_mq", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "no_mq", "argument": "--no-mq", "type": "select", "label": "Consider mapping quality during variant calling?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Yes, incorporate MAPQ into joint quality score", "", false], ["No, ignore MAPQ scores during variant calling", "--no-mq", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "source_qual", "type": "section", "title": "Source quality", "help": null, "expanded": true, "inputs": [{"model_class": "Conditional", "name": "use_src_qual", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "", "inputs": []}, {"model_class": "ConditionalWhen", "value": "--src-qual", "inputs": [{"model_class": "IntegerToolParameter", "name": "def_nm_q", "argument": "--def-nm-q", "type": "integer", "label": "Replace non-match base qualities with this value", "help": "For the calculation of the source quality, replace all base qualities of non-match bases with this value (default: -1 = use original base qualities).", "refresh_on_change": false, "min": -1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "-1", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "ign_vcf", "argument": "--ign-vcf", "type": "data", "label": "VCF input(s) with variants to ignore for source quality computation", "help": "Mismatches caused by known true variants in your samples should not lower the source quality estimate. If any read in your input has a base that is non-reference, but supports one of the known variants in the specified VCF datasets, that base will not be treated as a mismatch.", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["vcf", "vcf_bgzip"], "edam": {"edam_formats": ["format_3016", "format_3016"], "edam_data": ["data_0006", "data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "src_qual", "argument": "--src-qual", "type": "select", "label": "Compute source quality and consider it during variant calling", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["No, don't incorporate source quality into joint quality score", "", false], ["Yes, compute source quality and merge it into joint quality score", "--src-qual", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "joint_qual", "type": "section", "title": "Joint quality", "help": null, "expanded": true, "inputs": [{"model_class": "IntegerToolParameter", "name": "min_jq", "argument": "--min-jq", "type": "integer", "label": "Minimum joinedQ", "help": "At any site, do not use reads for variant calling, if their calculated joint quality at that site is lower than this value (default: 0 = do not filter based on joint quality)", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_alt_jq", "argument": "--min-alt-jq", "type": "integer", "label": "Minimum joinedQ for alternate bases", "help": "At any site, do not use reads for variant calling, if they support a non-reference allele at that site and their calculated joint quality at the site is lower than this value (default: 0 = do not filter based on joint quality). Note: this setting has no effect if the specified value is smaller than the general Minimum joinedQ set above.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "def_alt_jq", "argument": "--def-alt-jq", "type": "integer", "label": "Overwrite joinedQs of alternate bases with this value", "help": "After filtering according to the Minimum joinedQ settings above, set the joint quality values for all reads surviving filtering and supporting a non-reference allele to this value (default: 0 = use the original calculated joint quality).", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}]}], "test_param": {"model_class": "SelectToolParameter", "name": "set_call_options", "argument": null, "type": "select", "label": "Variant calling parameters", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Use default settings", "no", false], ["Configure settings", "yes", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "filter_control", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "set_all_off", "inputs": [{"model_class": "HiddenToolParameter", "name": "sig", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "1"}, {"model_class": "HiddenToolParameter", "name": "bonf", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "1"}, {"model_class": "HiddenToolParameter", "name": "others", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "--no-default-filter"}]}, {"model_class": "ConditionalWhen", "value": "set_no_default", "inputs": [{"model_class": "HiddenToolParameter", "name": "sig", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "0.01"}, {"model_class": "HiddenToolParameter", "name": "bonf", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "dynamic"}, {"model_class": "HiddenToolParameter", "name": "others", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "--no-default-filter"}]}, {"model_class": "ConditionalWhen", "value": "set_lofreq_standard", "inputs": [{"model_class": "HiddenToolParameter", "name": "sig", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "0.01"}, {"model_class": "HiddenToolParameter", "name": "bonf", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "dynamic"}, {"model_class": "HiddenToolParameter", "name": "others", "argument": null, "type": "hidden", "label": "", "help": "", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": ""}]}, {"model_class": "ConditionalWhen", "value": "set_custom", "inputs": [{"model_class": "FloatToolParameter", "name": "sig", "argument": null, "type": "float", "label": "Significance threshold for calls", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.01", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "bonf", "argument": null, "type": "integer", "label": "Bonferroni correction factor for multiple testing", "help": "Set to zero to determine dynamically from actual number of variant tests performed. Dynamic detection will calculate separate correction factors for SNVs and indels", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "others", "argument": null, "type": "boolean", "label": "Apply default coverage and strand-bias filter?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "--no-default-filter"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "filter_type", "argument": null, "type": "select", "label": "Variant filter parameters", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "set_lofreq_standard", "options": [["Strictly no filtering", "set_all_off", false], ["Preset QUAL score-based filtering", "set_no_default", false], ["Preset filtering on QUAL score + coverage + strand bias (lofreq call default)", "set_lofreq_standard", true], ["Custom filter settings/combinations", "set_custom", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutput", "name": "variants", "format": "vcf", "label": "", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "variants.vcf", "edam_format": "format_3016", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "variant_calling", "panel_section_name": "Variant Calling", "form_style": "regular"}