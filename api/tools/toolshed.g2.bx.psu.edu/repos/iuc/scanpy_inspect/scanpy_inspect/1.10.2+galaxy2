{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/scanpy_inspect/scanpy_inspect/1.10.2+galaxy2", "name": "Scanpy Inspect and manipulate", "version": "1.10.2+galaxy2", "description": "", "labels": [], "edam_operations": ["operation_3223"], "edam_topics": ["topic_0203", "topic_2229", "topic_3053"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "scanpy", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "scanpy_inspect", "owner": "iuc", "changeset_revision": "3b5ef3b00cdd", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "adata", "argument": null, "type": "data", "label": "Annotated data matrix", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["h5ad"], "edam": {"edam_formats": ["format_3590"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "pp.calculate_qc_metrics", "inputs": [{"model_class": "TextToolParameter", "name": "expr_type", "argument": "expr_type", "type": "text", "label": "Name of kind of values in X", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "counts", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "var_type", "argument": "var_type", "type": "text", "label": "The kind of thing the variables are", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "genes", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "qc_vars", "argument": "qc_vars", "type": "text", "label": "Keys for boolean columns of '.var' which identify variables you could want to control for", "help": "Keys separated by a comma", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "percent_top", "argument": "percent_top", "type": "text", "label": "Proportions of top genes to cover", "help": " Values (integers) are considered 1-indexed, '50' finds cumulative proportion to the 50th most expressed genes. Values separated by a comma. If empty don't calculate", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "layer", "argument": "layer", "type": "text", "label": "If provided, use adata.layers[layer] for expression values instead of adata.X.", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_raw", "argument": "use_raw", "type": "boolean", "label": "Use 'raw' attribute of input if present", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "BooleanToolParameter", "name": "log1p", "argument": "log1p", "type": "boolean", "label": "Compute log1p transformed annotations", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "pp.neighbors", "inputs": [{"model_class": "IntegerToolParameter", "name": "n_neighbors", "argument": "n_neighbors", "type": "integer", "label": "The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation", "help": "Larger values result in more global views of the manifold, while smaller values result in more local data being preserved. In general values should be in the range 2 to 100. If 'knn' is 'True', number of nearest neighbors to be searched. If 'knn' is 'False', a Gaussian kernel width is set to the distance of the 'n_neighbors' neighbor.", "help_format": "html", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_pcs", "argument": "n_pcs", "type": "integer", "label": "Number of PCs to use", "help": "", "help_format": "html", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "use_rep", "argument": "use_rep", "type": "text", "label": "Use the indicated representation", "help": "If not set, the representation is chosen automatically: for n_vars below 50, X is used, otherwise X_pca (uns) is used. If X_pca is not present, it's computed with default parameter", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "knn", "argument": "knn", "type": "boolean", "label": "Use a hard threshold to restrict the number of neighbors to n_neighbors?", "help": "If true, it considers a knn graph. Otherwise, it uses a Gaussian Kernel to assign low weights to neighbors more distant than the 'n_neighbors' nearest neighbor.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "pp_neighbors_method", "argument": "method", "type": "select", "label": "Method for computing connectivities", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "umap", "options": [["umap (McInnes et al, 2018)", "umap", true], ["gauss: Gauss kernel following (Coifman et al 2005) with adaptive width (Haghverdi et al 2016)", "gauss", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "metric", "argument": "metric", "type": "select", "label": "Distance metric", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "euclidean", "options": [["euclidean", "euclidean", true], ["braycurtis", "braycurtis", false], ["canberra", "canberra", false], ["chebyshev", "chebyshev", false], ["cityblock", "cityblock", false], ["correlation", "correlation", false], ["cosine", "cosine", false], ["mahalanobis", "mahalanobis", false], ["matching", "matching", false], ["minkowski", "minkowski", false], ["seuclidean", "seuclidean", false], ["sqeuclidean", "sqeuclidean", false], ["wminkowski", "wminkowski", false], ["dice", "dice", false], ["hamming", "hamming", false], ["jaccard", "jaccard", false], ["kulsinski", "kulsinski", false], ["rogerstanimoto", "rogerstanimoto", false], ["russellrao", "russellrao", false], ["sokalmichener", "sokalmichener", false], ["sokalsneath", "sokalsneath", false], ["yule", "yule", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Numpy random seed", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key to store neighbors, distances and connectivities", "help": "If specified, the neighbors data is added to .uns[key_added], distances are stored in .obsp[key_added+'_distances'] and connectivities in .obsp[key_added+'_connectivities']", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.score_genes", "inputs": [{"model_class": "TextToolParameter", "name": "gene_list", "argument": "gene_list", "type": "text", "label": "The list of gene names used for score calculation", "help": "Genes separated by a comma", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "ctrl_size", "argument": "ctrl_size", "type": "integer", "label": "Number of reference genes to be sampled", "help": "If 'len(gene_list)' is not too low, you can set 'ctrl_size=len(gene_list)'.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "gene_pool", "argument": "gene_pool", "type": "text", "label": "Genes for sampling the reference set", "help": "Default is all genes. Genes separated by a comma", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "score_name", "argument": "score_name", "type": "text", "label": "Name of the field to be added in '.obs'", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "score", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_bins", "argument": "n_bins", "type": "integer", "label": "Number of expression level bins for sampling", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "25", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random seed for sampling", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_raw", "argument": "use_raw", "type": "boolean", "label": "Use 'raw' attribute of input if present", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.score_genes_cell_cycle", "inputs": [{"model_class": "Conditional", "name": "s_genes", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "text", "inputs": [{"model_class": "TextToolParameter", "name": "text", "argument": null, "type": "text", "label": "List of genes associated with S phase", "help": "Genes separated by a comma", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "file", "inputs": [{"model_class": "DataToolParameter", "name": "file", "argument": null, "type": "data", "label": "File with the list of genes associated with S phase", "help": "One gene per line", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "format", "argument": null, "type": "select", "label": "Format for the list of genes associated with S phase", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "text", "options": [["Text", "text", true], ["File", "file", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "g2m_genes", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "text", "inputs": [{"model_class": "TextToolParameter", "name": "text", "argument": null, "type": "text", "label": "List of genes associated with G2M phase", "help": "Genes separated by a comma", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "file", "inputs": [{"model_class": "DataToolParameter", "name": "file", "argument": null, "type": "data", "label": "File with the list of genes associated with G2M phase", "help": "One gene per line", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "format", "argument": null, "type": "select", "label": "Format for the list of genes associated with G2M phase", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "text", "options": [["Text", "text", true], ["File", "file", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "n_bins", "argument": "n_bins", "type": "integer", "label": "Number of expression level bins for sampling", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "25", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "Random seed for sampling", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_raw", "argument": "use_raw", "type": "boolean", "label": "Use 'raw' attribute of input if present", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "tl.rank_genes_groups", "inputs": [{"model_class": "Conditional", "name": "get_df", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "False", "inputs": []}, {"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "TextToolParameter", "name": "key", "argument": "key", "type": "text", "label": "Key differential expression groups were stored under", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "pval_cutoff", "argument": "pval_cutoff", "type": "float", "label": "Return only adjusted p-values below the cutoff.", "help": "", "help_format": "html", "refresh_on_change": false, "min": 0.0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "log2fc_min", "argument": "log2fc_min", "type": "float", "label": "Minimum logfc to return.", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "log2fc_max", "argument": "log2fc_max", "type": "float", "label": "Maximum logfc to return.", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "gene_symbols", "argument": "gene_symbols", "type": "text", "label": "Column name in [.var] DataFrame that stores gene symbols.", "help": "By default 'var_names' refer to the index column of the '.var' DataFrame", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "get_df_select", "argument": null, "type": "select", "label": "Get ranked genes as a Tabular file?", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "False", "options": [["False", "False", true], ["True", "True", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "TextToolParameter", "name": "groupby", "argument": "groupby", "type": "text", "label": "The key of the observations grouping to consider", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "use_raw", "argument": "use_raw", "type": "boolean", "label": "Use 'raw' attribute of input if present", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}, {"model_class": "TextToolParameter", "name": "groups", "argument": "groups", "type": "text", "label": "Subset of groups to which comparison shall be restricted", "help": "e.g. ['g1', 'g2', 'g3']. If not passed, a ranking will be generated for all groups.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "layer", "argument": "layer", "type": "text", "label": "Key from adata.layers whose value will be used to perform tests on", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "ref", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "rest", "inputs": []}, {"model_class": "ConditionalWhen", "value": "group_id", "inputs": [{"model_class": "TextToolParameter", "name": "reference", "argument": "reference", "type": "text", "label": "Group identifier with respect to which compare", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "rest", "argument": null, "type": "select", "label": "Comparison", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "rest", "options": [["Compare each group to the union of the rest of the group", "rest", true], ["Compare with respect to a specific group", "group_id", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "n_genes", "argument": "n_genes", "type": "integer", "label": "The number of genes that appear in the returned tables", "help": "Defaults to all genes", "help_format": "html", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "Conditional", "name": "tl_rank_genes_groups_method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "t-test", "inputs": [{"model_class": "SelectToolParameter", "name": "corr_method", "argument": "corr_method", "type": "select", "label": "P-value correction method", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "benjamini-hochberg", "options": [["Benjamini-Hochberg", "benjamini-hochberg", true], ["Bonferroni", "bonferroni", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "wilcoxon", "inputs": [{"model_class": "SelectToolParameter", "name": "corr_method", "argument": "corr_method", "type": "select", "label": "P-value correction method", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "benjamini-hochberg", "options": [["Benjamini-Hochberg", "benjamini-hochberg", true], ["Bonferroni", "bonferroni", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "tie_correct", "argument": "tie_correct", "type": "boolean", "label": "Use tie correction for 'wilcoxon' scores", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}, {"model_class": "ConditionalWhen", "value": "t-test_overestim_var", "inputs": [{"model_class": "SelectToolParameter", "name": "corr_method", "argument": "corr_method", "type": "select", "label": "P-value correction method", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "benjamini-hochberg", "options": [["Benjamini-Hochberg", "benjamini-hochberg", true], ["Bonferroni", "bonferroni", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "logreg", "inputs": [{"model_class": "Conditional", "name": "solver", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "lbfgs", "inputs": [{"model_class": "BooleanToolParameter", "name": "penalty", "argument": null, "type": "boolean", "label": "use l2 penalty?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "l2", "falsevalue": "None"}, {"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "max_iter", "argument": "max_iter", "type": "integer", "label": "Maximum number of iterations taken for the solvers to converge", "help": "", "help_format": "html", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", true], ["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "newton-cg", "inputs": [{"model_class": "BooleanToolParameter", "name": "penalty", "argument": null, "type": "boolean", "label": "use l2 penalty?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "l2", "falsevalue": "None"}, {"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "max_iter", "argument": "max_iter", "type": "integer", "label": "Maximum number of iterations taken for the solvers to converge", "help": "", "help_format": "html", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", true], ["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "liblinear", "inputs": [{"model_class": "Conditional", "name": "penalty", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "l1", "inputs": []}, {"model_class": "ConditionalWhen", "value": "l2", "inputs": [{"model_class": "BooleanToolParameter", "name": "dual", "argument": "dual", "type": "boolean", "label": "Dual (not primal) formulation?", "help": "Prefer primal when n_samples > n_features", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "True", "falsevalue": "False"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "penalty", "argument": "penalty", "type": "select", "label": "Norm used in the penalization", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "l2", "options": [["l2", "l2", true], ["l1", "l1", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "intercept_scaling", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "True", "inputs": [{"model_class": "FloatToolParameter", "name": "intercept_scaling", "argument": "intercept_scaling", "type": "float", "label": "Intercept scaling", "help": "x becomes [x, self.intercept_scaling], i.e. a 'synthetic' feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "False", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "select", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "True", "options": [["Yes", "True", true], ["No", "False", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "The seed of the pseudo random number generator to use when shuffling the data", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "sag", "inputs": [{"model_class": "BooleanToolParameter", "name": "penalty", "argument": null, "type": "boolean", "label": "use l2 penalty?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "l2", "falsevalue": "None"}, {"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "IntegerToolParameter", "name": "random_state", "argument": "random_state", "type": "integer", "label": "The seed of the pseudo random number generator to use when shuffling the data", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_iter", "argument": "max_iter", "type": "integer", "label": "Maximum number of iterations taken for the solvers to converge", "help": "", "help_format": "html", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", true], ["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "saga", "inputs": [{"model_class": "Conditional", "name": "penalty", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "l1", "inputs": []}, {"model_class": "ConditionalWhen", "value": "l2", "inputs": []}, {"model_class": "ConditionalWhen", "value": "elasticnet", "inputs": []}, {"model_class": "ConditionalWhen", "value": "None", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "penalty", "argument": "penalty", "type": "select", "label": "Norm used in the penalization", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "l2", "options": [["l2", "l2", true], ["l1", "l1", false], ["elasticnet", "elasticnet", false], ["None", "None", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "fit_intercept", "argument": "fit_intercept", "type": "boolean", "label": "Should a constant (a.k.a. bias or intercept) be added to the decision function?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "SelectToolParameter", "name": "multi_class", "argument": "multi_class", "type": "select", "label": "Multi class", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["auto: selects \u2018ovr\u2019 if the data is binary and otherwise selects \u2018multinomial\u2019", "auto", true], ["ovr: a binary problem is fit for each label", "ovr", false], ["multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary", "multinomial", false]], "display": null, "multiple": false, "textable": false}]}], "test_param": {"model_class": "SelectToolParameter", "name": "solver", "argument": "solver", "type": "select", "label": "Algorithm to use in the optimization problem", "help": "For small datasets, \u2018liblinear\u2019 is a good choice, whereas \u2018sag\u2019 and \u2018saga\u2019 are faster for large ones. For multiclass problems, only \u2018newton-cg\u2019, \u2018sag\u2019, \u2018saga\u2019 and \u2018lbfgs\u2019 handle multinomial loss; \u2018liblinear\u2019 is limited to one-versus-rest schemes. \u2018newton-cg\u2019, \u2018lbfgs\u2019 and \u2018sag\u2019 only handle L2 penalty, whereas \u2018liblinear\u2019 and \u2018saga\u2019 handle L1 penalty.", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "lbfgs", "options": [["lbfgs", "lbfgs", true], ["newton-cg", "newton-cg", false], ["liblinear", "liblinear", false], ["sag", "sag", false], ["saga", "saga", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "FloatToolParameter", "name": "tol", "argument": "tol", "type": "float", "label": "Tolerance for stopping criteria", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0001", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "c", "argument": "c", "type": "float", "label": "Inverse of regularization strength", "help": "It must be a positive float. Like in support vector machines, smaller values specify stronger regularization.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "t-test", "options": [["t-test", "t-test", true], ["Wilcoxon-Rank-Sum", "wilcoxon", false], ["t-test with overestimate of variance of each group", "t-test_overestim_var", false], ["Logistic regression", "logreg", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "The key in adata.uns information is saved to", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "tl.marker_gene_overlap", "inputs": [{"model_class": "Repeat", "name": "reference_markers", "type": "repeat", "title": "Marker genes", "help": null, "default": 0, "min": 0, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "key", "argument": null, "type": "text", "label": "Cell identity name", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "values", "argument": null, "type": "text", "label": "List of genes", "help": "Comma-separated names from 'var'", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "TextToolParameter", "name": "key", "argument": "key", "type": "text", "label": "Key in adata.uns where the rank_genes_groups output is stored", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "rank_genes_groups", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "overlap", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "overlap_count", "inputs": [{"model_class": "SelectToolParameter", "name": "normalize", "argument": "normalize", "type": "select", "label": "Normalization option for the marker gene overlap output", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "None", "options": [["None", "None", true], ["reference: Normalization of the data by the total number of marker genes given in the reference annotation per group", "reference", false], ["data: Normalization of the data by the total number of marker genes used for each cluster", "data", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "overlap_coef", "inputs": []}, {"model_class": "ConditionalWhen", "value": "jaccard", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method to calculate marker gene overlap", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "overlap_count", "options": [["overlap_count: Intersection of the gene set", "overlap_count", true], ["overlap_coef: Overlap coefficient", "overlap_coef", false], ["jaccard: Jaccard index", "jaccard", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "top_n_markers", "argument": "top_n_markers", "type": "integer", "label": "Number of top data-derived marker genes to use", "help": "By default all calculated marker genes are used. If adj_pval_threshold is set along with top_n_markers, then adj_pval_threshold is ignored.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "adj_pval_threshold", "argument": "adj_pval_threshold", "type": "float", "label": "Significance threshold on the adjusted p-values to select marker genes", "help": " This can only be used when adjusted p-values are calculated by 'tl.rank_genes_groups'. If adj_pval_threshold is set along with top_n_markers, then adj_pval_threshold is ignored.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "key_added", "argument": "key_added", "type": "text", "label": "Key that will contain the marker overlap scores in 'uns'", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.log1p", "inputs": [{"model_class": "IntegerToolParameter", "name": "base", "argument": "base", "type": "integer", "label": "Base of the logarithm.", "help": "Natural logarithm is used by default.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "layer", "argument": "layer", "type": "text", "label": "Entry of layers to transform", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "obsm", "argument": "obsm", "type": "text", "label": "Entry of obsm to transform", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.scale", "inputs": [{"model_class": "BooleanToolParameter", "name": "zero_center", "argument": "zero_center", "type": "boolean", "label": "Zero center?", "help": "If not, it omits zero-centering variables, which allows to handle sparse input efficiently.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "FloatToolParameter", "name": "max_value", "argument": "max_value", "type": "float", "label": "Maximum value", "help": "Clip (truncate) to this value after scaling. If not set, it does not clip.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "layer", "argument": "layer", "type": "text", "label": "Which element of layers to scale", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "obsm", "argument": "obsm", "type": "text", "label": "Which element of obsm to scale", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "mask_obs", "argument": "mask_obs", "type": "text", "label": "Restrict both the derivation of scaling parameters and the scaling itself to a certain set of observations.", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.sqrt", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method used for inspecting", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "pp.calculate_qc_metrics", "options": [["Calculate quality control metrics, using 'pp.calculate_qc_metrics'", "pp.calculate_qc_metrics", false], ["Compute a neighborhood graph of observations, using 'pp.neighbors'", "pp.neighbors", false], ["Score a set of genes, using 'tl.score_genes'", "tl.score_genes", false], ["Score cell cycle genes, using 'tl.score_genes_cell_cycle'", "tl.score_genes_cell_cycle", false], ["Rank genes for characterizing groups, using 'tl.rank_genes_groups'", "tl.rank_genes_groups", false], ["Calculate an overlap score between data-deriven marker genes and provided markers, using 'tl.marker_gene_overlap'", "tl.marker_gene_overlap", false], ["Logarithmize the data matrix, using 'pp.log1p'", "pp.log1p", false], ["Scale data to unit variance and zero mean, using 'pp.scale'", "pp.scale", false], ["Square root the data matrix, using 'pp.sqrt'", "pp.sqrt", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "advanced_common", "type": "section", "title": "Advanced Options", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "show_log", "argument": null, "type": "boolean", "label": "Output Log?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}]}], "outputs": [{"model_class": "ToolOutput", "name": "anndata_out", "format": "h5ad", "label": "${tool.name} (${method.method}) on ${on_string}: Annotated data matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "anndata.h5ad", "edam_format": "format_3590", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "hidden_output", "format": "txt", "label": "Log file", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "ranked_gene", "format": "tabular", "label": "${tool.name} (${method.method}) on ${on_string}: Ranked genes", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "DEG.tsv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "single-cell", "panel_section_name": "Single-cell", "form_style": "regular"}