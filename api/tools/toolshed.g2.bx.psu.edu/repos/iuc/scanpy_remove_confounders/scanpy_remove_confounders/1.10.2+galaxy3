{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/scanpy_remove_confounders/scanpy_remove_confounders/1.10.2+galaxy3", "name": "Scanpy remove confounders", "version": "1.10.2+galaxy3", "description": "with scanpy", "labels": [], "icon": null, "edam_operations": ["operation_3223"], "edam_topics": ["topic_3053", "topic_2229", "topic_0203"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "scanpy", "type": "bio.tools"}], "tool_shed_repository": {"name": "scanpy_remove_confounders", "owner": "iuc", "changeset_revision": "be0d45c46e97", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "adata", "argument": null, "type": "data", "label": "Annotated data matrix", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["h5ad"], "edam": {"edam_formats": ["format_3590"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "pp.regress_out", "inputs": [{"model_class": "TextToolParameter", "name": "layer", "argument": "layer", "type": "text", "label": "Which element of layers to regress on", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "keys", "argument": "keys", "type": "text", "label": "Keys for observation annotation on which to regress on", "help": "Keys separated by a comma", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pp.combat", "inputs": [{"model_class": "TextToolParameter", "name": "key", "argument": "key", "type": "text", "label": "Key to a categorical annotation from adata.obs that will be used for batch effect removal", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "batch", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "covariates", "argument": "covariates", "type": "text", "label": "Additional covariates besides the batch variable such as adjustment variables or biological condition.", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "external.pp.bbknn", "inputs": [{"model_class": "TextToolParameter", "name": "batch_key", "argument": "batch_key", "type": "text", "label": "Batch key for the concatenate", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "batch", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "use_rep", "argument": "use_rep", "type": "text", "label": "The dimensionality reduction in .obsm to use for neighbour detection", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "X_pca", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "approx", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "annoy", "inputs": [{"model_class": "IntegerToolParameter", "name": "annoy_n_trees", "argument": "annoy_n_trees", "type": "integer", "label": "The number of trees to construct in the annoy forest", "help": "More trees give higher precision when querying, at the cost of increased run time and resource intensity", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pyNNDescent", "inputs": [{"model_class": "IntegerToolParameter", "name": "pynndescent_n_neighbors", "argument": "pynndescent_n_neighbors", "type": "integer", "label": "The number of neighbours to include in the approximate neighbour graph", "help": "More neighbours give higher precision when querying, at the cost of increased run time and resource intensity", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "30", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "pynndescent_random_state", "argument": "pynndescent_random_state", "type": "integer", "label": "The RNG seed to use when creating the graph", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "approx_method", "argument": null, "type": "select", "label": "Approximate neighbour finding", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "annoy", "options": [["Yes, using ANNOY algorithm", "annoy", true], ["Yes, using pyNNDescent", "pyNNDescent", false], ["Do not use approximate neighbor finding", "no", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "metric", "argument": null, "type": "select", "label": "Distance metric to use for the data", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "euclidean", "options": [["euclidean", "euclidean", true], ["braycurtis", "braycurtis", false], ["canberra", "canberra", false], ["chebyshev", "chebyshev", false], ["cityblock", "cityblock", false], ["correlation", "correlation", false], ["cosine", "cosine", false], ["mahalanobis", "mahalanobis", false], ["matching", "matching", false], ["minkowski", "minkowski", false], ["seuclidean", "seuclidean", false], ["sqeuclidean", "sqeuclidean", false], ["wminkowski", "wminkowski", false], ["dice", "dice", false], ["hamming", "hamming", false], ["jaccard", "jaccard", false], ["kulsinski", "kulsinski", false], ["rogerstanimoto", "rogerstanimoto", false], ["russellrao", "russellrao", false], ["sokalmichener", "sokalmichener", false], ["sokalsneath", "sokalsneath", false], ["yule", "yule", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "neighbors_within_batch", "argument": "neighbors_within_batch", "type": "integer", "label": "Number of top neighbours to report for each batch", "help": "total number of neighbours in the initial k-nearest-neighbours computation will be this number times the number of batches. This then serves as the basis for the construction of a symmetrical matrix of connectivities", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "3", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n_pcs", "argument": "n_pcs", "type": "integer", "label": "Number of dimensions to use in the analysis", "help": "in case of PCA, principal components", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "trim", "argument": "trim", "type": "integer", "label": "Trim the neighbours of each cell to these many top connectivities", "help": " The lower the value the more independent the individual populations, at the cost of more conserved batch effect. If not set, sets the parameter value automatically to 10 times neighbors_within_batch times the number of batches. Set to 0 to skip.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "set_op_mix_ratio", "argument": "set_op_mix_ratio", "type": "float", "label": "UMAP connectivity computation parameter", "help": "controlling the blend between a connectivity matrix formed exclusively from mutual nearest neighbour pairs (0) and a union of all observed neighbour relationships with the mutual pairs emphasised (1)", "help_format": "html", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "local_connectivity", "argument": "local_connectivity", "type": "integer", "label": "Number of nearest neighbors of each cell are assumed to be fully connected", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "external.pp.harmony_integrate", "inputs": [{"model_class": "TextToolParameter", "name": "key", "argument": "key", "type": "text", "label": "The name of the column in adata.obs that differentiates among experiments/batches", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "batch", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "basis", "argument": "basis", "type": "text", "label": "The name of the field in adata.obsm where the PCA table is stored", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "X_pca", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "adjusted_basis", "argument": "adjusted_basis", "type": "text", "label": "The name of the field in adata.obsm where the adjusted PCA table will be stored after running this function", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "X_pca_harmony", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "theta", "argument": "theta", "type": "integer", "label": "Diversity clustering penalty parameter", "help": "Default theta=2. theta=0 does not encourage any diversity. Larger values of theta result in more diverse clusters.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "lamb", "argument": "lamb", "type": "integer", "label": "Ridge regression penalty parameter", "help": "Default lamb=1. Lambda must be strictly positive. Smaller values result in more aggressive correction.", "help_format": "html", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "sigma", "argument": "sigma", "type": "float", "label": "Width of soft kmeans clusters", "help": "Sigma scales the distance from a cell to cluster centroids. Larger values of sigma result in cells assigned to more clusters. Smaller values of sigma make soft kmeans cluster approach hard clustering.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "nclust", "argument": "nclust", "type": "integer", "label": "Number of clusters in model", "help": "nclust=1 equivalent to simple linear regression.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "tau", "argument": "tau", "type": "integer", "label": "Expected number of cells per cluster", "help": "Protection against overclustering small datasets with large ones", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "block_size", "argument": "block_size", "type": "float", "label": "Proportion of cells to update during clustering", "help": "Larger values may be faster but less accurate", "help_format": "html", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_iter_harmony", "argument": "max_iter_harmony", "type": "integer", "label": "Maximum number of rounds to run Harmony", "help": "One round of Harmony involves one clustering and one correction step", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_iter_kmeans", "argument": "max_iter_kmeans", "type": "integer", "label": "Maximum number of rounds to run clustering at each round of Harmony", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "20", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "epsilon_cluster", "argument": "epsilon_cluster", "type": "float", "label": "Convergence tolerance for clustering round of Harmony", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1e-05", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "epsilon_harmony", "argument": "epsilon_harmony", "type": "float", "label": "Convergence tolerance for Harmony", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0001", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "external.pp.scanorama_integrate", "inputs": [{"model_class": "TextToolParameter", "name": "key", "argument": "key", "type": "text", "label": "The name of the column in adata.obs that differentiates among experiments/batches", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "batch", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "basis", "argument": "basis", "type": "text", "label": "The name of the field in adata.obsm where the PCA table is stored", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "X_pca", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "adjusted_basis", "argument": "adjusted_basis", "type": "text", "label": "The name of the field in adata.obsm where the adjusted PCA table will be stored after running this function", "help": "", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "X_scanorama", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "knn", "argument": "knn", "type": "integer", "label": "Number of nearest neighbors to use for matching", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "20", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "sigma", "argument": "sigma", "type": "integer", "label": "Correction smoothing parameter on Gaussian kernel", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "15", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "approx", "argument": "approx", "type": "boolean", "label": "Use approximate nearest neighbors with Python annoy", "help": "greatly speeds up matching runtime", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "True", "falsevalue": "False"}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Alignment score minimum cutoff", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "batch_size", "argument": "batch_size", "type": "integer", "label": "The batch size used in the alignment vector computation", "help": "Useful when integrating very large (>100k samples) datasets. Set to large value that runs within available memory.", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5000", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Method used for plotting", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "pp.regress_out", "options": [["Regress out unwanted sources of variation, using 'pp.regress_out'", "pp.regress_out", false], ["Correct batch effects with ComBat function, using 'pp.combat'", "pp.combat", false], ["Batch effect removal with Batch balanced KNN (BBKNN), using 'external.pp.bbknn'", "external.pp.bbknn", false], ["Integrate multiple single-cell experiments with Harmony, using 'external.pp.harmony_integrate'", "external.pp.harmony_integrate", false], ["Integrate multiple single-cell experiments with Scanorama, using 'external.pp.scanorama_integrate'", "external.pp.scanorama_integrate", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "advanced_common", "type": "section", "title": "Advanced Options", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "show_log", "argument": null, "type": "boolean", "label": "Output Log?", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}]}], "outputs": [{"model_class": "ToolOutput", "name": "anndata_out", "format": "h5ad", "label": "${tool.name} (${method.method}) on ${on_string}: Annotated data matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": null, "parent": null, "count": 1, "from_work_dir": "anndata.h5ad", "edam_format": "format_3590", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "hidden_output", "format": "txt", "label": "Log file", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": null, "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "single-cell", "panel_section_name": "Single-cell", "form_style": "regular"}