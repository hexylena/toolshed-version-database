{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/featurecounts/featurecounts/2.0.3+galaxy1", "name": "featureCounts", "version": "2.0.3+galaxy1", "description": "Measure gene expression in RNA-Seq experiments from SAM or BAM files", "labels": [], "edam_operations": ["operation_3793"], "edam_topics": ["topic_3168"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "featurecounts", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "featurecounts", "owner": "iuc", "changeset_revision": "6f66ae7c5f7a", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "alignment", "argument": null, "type": "data", "label": "Alignment file", "help": "The input alignment file(s) where the gene expression has to be counted. The file can have a SAM or BAM format; but ALL files must be in the same format. Unless you are using a Gene annotation file from the History, these files must have the database/genome attribute already specified e.g. hg38, not the default: ?", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam", "sam"], "edam": {"edam_formats": ["format_2572", "format_2573"], "edam_data": ["data_0863", "data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "SelectToolParameter", "name": "strand_specificity", "argument": "-s", "type": "select", "label": "Specify strand information", "help": "Indicate if the data is stranded and if strand-specific read counting should be performed. Strand setting must be the same as the strand settings used to produce the mapped BAM input(s)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "options": [["Unstranded", "0", true], ["Stranded (Forward)", "1", false], ["Stranded (Reverse)", "2", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "anno", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "builtin", "inputs": [{"model_class": "SelectToolParameter", "name": "bgenome", "argument": null, "type": "select", "label": "Select built-in genome", "help": "Built-in gene annotations for genomes hg38, hg19, mm10 and mm9 are included in featureCounts", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": true, "value": null, "options": [], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "cached", "inputs": [{"model_class": "SelectToolParameter", "name": "reference_gene_sets_cached", "argument": null, "type": "select", "label": "Using locally cached annotation", "help": "If the annotation file you require is not listed here, please contact the Galaxy administrator.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": true, "value": null, "options": [], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "gff_feature_type", "argument": "-t", "type": "text", "label": "GFF feature type filter", "help": "Specify the feature type. Only rows which have the matched matched feature type in the provided GTF annotation file will be included for read counting. `exon' by default.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "exon", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "gff_feature_attribute", "argument": "-g", "type": "text", "label": "GFF gene identifier", "help": "Specify the attribute type used to group features (eg. exons) into meta-features (eg. genes), when GTF annotation is provided. `gene_id' by default. This attribute type is usually the gene identifier. This argument is useful for the meta-feature level summarization. Ex: if the 9th column is 'gene_id \"ENSG00000223972\"; gene_name \"DDX11L1\" gene_source \"havana\"' (GTF) or 'gene_id=ENSG00000223972; gene_name=DDX11L1; gene_source=havana' (GFF), the available attributes for this feature are 'gene_id', 'gene_name' and 'gene_source'.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "gene_id", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "summarization_level", "argument": "-f", "type": "boolean", "label": "On feature level", "help": "If specified, read summarization will be performed at the feature level. By default (-f is not specified), the read summarization is performed at the meta-feature level.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -f", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "history", "inputs": [{"model_class": "DataToolParameter", "name": "reference_gene_sets", "argument": null, "type": "data", "label": "Gene annotation file", "help": "The program assumes that the provided annotation file is in GFF/GTF format. Make sure that the gene annotation file corresponds to the same reference genome as used for the alignment.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["gff", "gtf", "gff3"], "edam": {"edam_formats": ["format_2305", "format_2306", "format_1975"], "edam_data": ["data_1255", "data_1255", "data_1255"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "TextToolParameter", "name": "gff_feature_type", "argument": "-t", "type": "text", "label": "GFF feature type filter", "help": "Specify the feature type. Only rows which have the matched matched feature type in the provided GTF annotation file will be included for read counting. `exon' by default.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "exon", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "gff_feature_attribute", "argument": "-g", "type": "text", "label": "GFF gene identifier", "help": "Specify the attribute type used to group features (eg. exons) into meta-features (eg. genes), when GTF annotation is provided. `gene_id' by default. This attribute type is usually the gene identifier. This argument is useful for the meta-feature level summarization. Ex: if the 9th column is 'gene_id \"ENSG00000223972\"; gene_name \"DDX11L1\" gene_source \"havana\"' (GTF) or 'gene_id=ENSG00000223972; gene_name=DDX11L1; gene_source=havana' (GFF), the available attributes for this feature are 'gene_id', 'gene_name' and 'gene_source'.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "gene_id", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "summarization_level", "argument": "-f", "type": "boolean", "label": "On feature level", "help": "If specified, read summarization will be performed at the feature level. By default (-f is not specified), the read summarization is performed at the meta-feature level.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -f", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "anno_select", "argument": null, "type": "select", "label": "Gene annotation file", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "cached", "options": [["featureCounts built-in", "builtin", false], ["locally cached", "cached", true], ["A GFF/GTF file in your history", "history", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "format", "argument": null, "type": "select", "label": "Output format", "help": "The output format will be tabular, select the preferred columns here", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "tabdel_short", "options": [["Gene-ID \"\\t\" read-count (MultiQC/DESeq2/edgeR/limma-voom compatible)", "tabdel_short", false], ["Gene-ID \"\\t\" read-count \"\\t\" gene-length", "tabdel_medium", false], ["featureCounts 1.4.0+ default (includes regions provided by the GTF file)", "tabdel_full", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "include_feature_length_file", "argument": null, "type": "boolean", "label": "Create gene-length file", "help": "Creates a tabular file that contains the effective (nucleotides used for counting reads) length of the feature; might be useful for estimating FPKM/RPKM", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}, {"model_class": "Conditional", "name": "pe_parameters", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "single_end", "inputs": []}, {"model_class": "ConditionalWhen", "value": "PE_individual", "inputs": [{"model_class": "BooleanToolParameter", "name": "only_both_ends", "argument": "-B", "type": "boolean", "label": "Only allow fragments with both reads aligned", "help": "If specified, only fragments that have both ends successfully aligned will be considered for summarization. This option is only applicable for paired-end reads.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -B", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "exclude_chimerics", "argument": "-C", "type": "boolean", "label": "Exclude chimeric fragments", "help": "If specified, the chimeric fragments (those fragments that have their two ends aligned to different chromosomes) will NOT be included for summarization. This option is only applicable for paired-end read data.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": " -C", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "PE_fragments", "inputs": [{"model_class": "Conditional", "name": "check_distance_enabled", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "true", "inputs": [{"model_class": "IntegerToolParameter", "name": "minimum_fragment_length", "argument": "-d", "type": "integer", "label": "Minimum fragment/template length.", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maximum_fragment_length", "argument": "-D", "type": "integer", "label": "Maximum fragment/template length.", "help": "", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "600", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "false", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "checkFragLength", "argument": "--checkFragLength", "type": "select", "label": "Check paired-end distance", "help": "If specified, paired-end distance will be checked when assigning fragments to meta-features or features. This option is only applicable when -p (Count fragments instead of reads) is specified. The distance thresholds can be specified using -d and -D (minimum and maximum fragment/template length) options.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "false", "options": [["Check the distance between paired reads", "true", false], ["Do not check", "false", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "only_both_ends", "argument": "-B", "type": "boolean", "label": "Only allow fragments with both reads aligned", "help": "If specified, only fragments that have both ends successfully aligned will be considered for summarization. This option is only applicable for paired-end reads.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -B", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "exclude_chimerics", "argument": "-C", "type": "boolean", "label": "Exclude chimeric fragments", "help": "If specified, the chimeric fragments (those fragments that have their two ends aligned to different chromosomes) will NOT be included for summarization. This option is only applicable for paired-end read data.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": " -C", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "paired_end_status", "argument": null, "type": "select", "label": "Does the input have read pairs?", "help": "Were the bam files generated by aligning the output of a paired-end sequencing experiment? If yes, the tool can consider 2 reads = 1 read pair as 1 entity to count. Alternatively, you can opt to consider treating the read pairs as 2 individual reads to count seperately.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "single_end", "options": [["No, single-end.", "single_end", true], ["Yes, paired-end but still count them as if individual reads.", "PE_individual", false], ["Yes, paired-end and count them as 1 single fragment.", "PE_fragments", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "read_filtering_parameters", "type": "section", "title": "Read filtering options", "help": null, "expanded": false, "inputs": [{"model_class": "IntegerToolParameter", "name": "mapping_quality", "argument": "-Q", "type": "integer", "label": "Minimum mapping quality per read", "help": "The minimum mapping quality score a read must satisfy in order to be counted. For paired-end reads, at least one end should satisfy this criteria. 0 by default.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "splitonly", "argument": null, "type": "select", "label": "Filter split alignments", "help": "Split alignments are alignments with CIGAR string containing 'N', e.g. exon spanning reads in RNASeq.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["No filtering: count split and non-split alignments", "", false], ["Count only split alignments (--splitOnly)", "--splitOnly", false], ["Count only non-split alignments (--nonSplitOnly)", "--nonSplitOnly", false]], "display": "radio", "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "primary", "argument": "--primary", "type": "boolean", "label": "Only count primary alignments", "help": "If specified, only primary alignments will be counted. Primary and secondary alignments are identified using bit 0x100 in theFlag field of SAM/BAM files. All primary alignments in a dataset will be counted regardless of whether they are from multi-mapping reads or not ('-M' is ignored).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --primary", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "ignore_dup", "argument": "--ignoreDup", "type": "boolean", "label": "Ignore reads marked as duplicate", "help": "If specified, reads that were marked as duplicates will be ignored. Bit Ox400 in the FLAG field of a SAM/BAM file is used for identifying duplicate reads. In paired end data, the entire read pair will be ignored if at least one end is found to be a duplicate read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --ignoreDup", "falsevalue": ""}]}, {"model_class": "Section", "name": "extended_parameters", "type": "section", "title": "Advanced options", "help": null, "expanded": false, "inputs": [{"model_class": "Conditional", "name": "multifeatures", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "", "inputs": []}, {"model_class": "ConditionalWhen", "value": "-M", "inputs": [{"model_class": "BooleanToolParameter", "name": "fraction", "argument": "--fraction", "type": "boolean", "label": "Assign fractions to multi-mapping reads", "help": "If specified, a fractional count 1/x will be generated for each multi-mapping read, where x is the number of alignments (indicated by 'NH' tag) reported for the read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--fraction", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "-O", "inputs": [{"model_class": "BooleanToolParameter", "name": "fraction", "argument": "--fraction", "type": "boolean", "label": "Assign fractions to multi-overlapping features", "help": "If specified, a fractional count 1/y will be generated for each multi-overlapping feature, where y is the number of features overlapping with the read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--fraction", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "-O -M", "inputs": [{"model_class": "BooleanToolParameter", "name": "fraction", "argument": "--fraction", "type": "boolean", "label": "Assign fractions to both multi-mapping reads and multi-overlapping features", "help": "If specified, a fractional count 1/(x*y) will be generated, where x is the number of alignments (indicated by 'NH' tag) and y the number of overlapping features.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--fraction", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "multifeat", "argument": null, "type": "select", "label": "Allow reads to map to multiple features", "help": "Setting -O, -M and --fraction", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Disabled: reads that align to multiple features or overlapping features are excluded", "", true], ["Enabled: multi-mapping reads are included (-M)", "-M", false], ["Enabled: multi-overlapping features are included (-O)", "-O", false], ["Enabled: both multi-mapping and multi-overlapping features are included (-M -O)", "-O -M", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "exon_exon_junction_read_counting_enabled", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "-J", "inputs": [{"model_class": "DataToolParameter", "name": "genome", "argument": "-G", "type": "data", "label": "Reference sequence file", "help": "The FASTA-format file that contains the reference sequences used in read mapping can be used to improve read counting for junctions", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta"], "edam": {"edam_formats": ["format_1929"], "edam_data": ["data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "count_exon_exon_junction_reads", "argument": "-J", "type": "select", "label": "Exon-exon junctions", "help": "Junctions are identified from those exon-spanning reads (containing \u2018N\u2019 in CIGAR string) in input data. The output result includes names of primary and secondary genes that overlap at least one of the two splice sites of a junction.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Count reads supporting each exon-exon junction.", "-J", false], ["Do not count", "", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "long_reads", "argument": "-L", "type": "boolean", "label": "Long reads", "help": "If specified, long reads such as Nanopore and PacBio reads will be counted. Long read counting can only run in one thread and only reads (not read-pairs) can be counted.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "-L", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "by_read_group", "argument": "--byReadGroup", "type": "boolean", "label": "Count reads by read group", "help": "If specified, reads are counted for each read group separately. The 'RG' tag must be present in the input BAM/SAM alignment files.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--byReadGroup", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "largest_overlap", "argument": "--largestOverlap", "type": "boolean", "label": "Largest overlap", "help": "If specified, reads (or fragments) will be assigned to the target that has the largest number of overlapping bases", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --largestOverlap", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "min_overlap", "argument": "--minOverlap", "type": "integer", "label": "Minimum bases of overlap", "help": "Specify the minimum required number of overlapping bases between a read (or a fragment) and a feature. 1 by default. If a negative value is provided, the read will be extended from both ends.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "frac_overlap", "argument": "--fracOverlap", "type": "integer", "label": "Minimum fraction (of read) overlapping a feature", "help": "Specify the minimum required fraction of overlapping bases between a read (or a fragment) and a feature. Value should be within range [0,1]. 0 by default. Number of overlapping bases is counted from both reads if paired end. Both this option and '--minOverlap' need to be satisfied for read assignment.", "refresh_on_change": false, "min": 0, "max": 1, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "frac_overlap_feature", "argument": "--fracOverlapFeature", "type": "integer", "label": "Minimum fraction (of feature) overlapping a read", "help": "Specify the minimum required fraction of bases included in a feature overlapping bases between a read (or a read-pair). Value should be within range [0,1]. 0 by default.", "refresh_on_change": false, "min": 0, "max": 1, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "read_extension_5p", "argument": "--readExtension5", "type": "integer", "label": "Read 5' extension", "help": "Reads are extended upstream by ... bases from their 5' end", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "read_extension_3p", "argument": "--readExtension3", "type": "integer", "label": "Read 3' extension", "help": "Reads are extended upstream by ... bases from their 3' end", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "read_reduction", "argument": "--read2pos", "type": "select", "label": "Reduce read to single position", "help": "The read is reduced to its 5' most base or 3'most base. Read summarization is then performed based on the single base the the read is reduced to.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Leave the read as it is", "", true], ["Reduce it to the 5' end", "--read2pos 5", false], ["Reduce it to the 3' end", "--read2pos 3", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "R", "argument": "-R", "type": "boolean", "label": "Annotates the alignment file with 'XS:Z:'-tags to described per read or read-pair the corresponding assigned feature(s).", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "-R BAM", "falsevalue": ""}]}], "outputs": [{"model_class": "ToolOutput", "name": "output_medium", "format": "tabular", "label": "${tool.name} on ${on_string}: Counts (with length)", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_bam", "format": "bam", "label": "${tool.name} on ${on_string}: Alignment file", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_2572", "edam_data": "data_0863", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_short", "format": "tabular", "label": "${tool.name} on ${on_string}: Counts", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_full", "format": "tabular", "label": "${tool.name} on ${on_string}: Counts (with location)", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_summary", "format": "tabular", "label": "${tool.name} on ${on_string}: Summary", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_feature_lengths", "format": "tabular", "label": "${tool.name} on ${on_string}: Feature lengths", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_jcounts", "format": "tabular", "label": "${tool.name} on ${on_string}: Junction counts", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "rna_analysis", "panel_section_name": "RNA Analysis", "form_style": "regular"}