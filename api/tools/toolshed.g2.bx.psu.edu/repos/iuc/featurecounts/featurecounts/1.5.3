{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/featurecounts/featurecounts/1.5.3", "name": "featureCounts", "version": "1.5.3", "description": "Measure gene expression in RNA-Seq experiments from SAM or BAM files.", "labels": [], "edam_operations": [], "edam_topics": [], "hidden": "", "is_workflow_compatible": true, "xrefs": [], "tool_shed_repository": {"name": "featurecounts", "owner": "iuc", "changeset_revision": "3ce1c701b0df", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "alignment", "argument": null, "type": "data", "label": "Alignment file", "help": "The input alignment file(s) where the gene expression has to be counted. The file can have a SAM or BAM format; but ALL files must be in the same format", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam", "sam"], "edam": {"edam_formats": ["format_2572", "format_2573"], "edam_data": ["data_0863", "data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "gtf_source", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "cached", "inputs": [{"model_class": "SelectToolParameter", "name": "reference_gene_sets_builtin", "argument": null, "type": "select", "label": "Using locally cached annotation", "help": "If the annotation file you require is not listed here, please contact the Galaxy administrator", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": true, "value": null, "options": [], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "history", "inputs": [{"model_class": "DataToolParameter", "name": "reference_gene_sets", "argument": null, "type": "data", "label": "Gene annotation file", "help": "The program assumes that the provided annotation file is in GTF format. Make sure that the gene annotation file corresponds to the same reference genome as used for the alignment", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["gff", "gtf", "gff3"], "edam": {"edam_formats": ["format_2305", "format_2306", "format_1975"], "edam_data": ["data_1255", "data_1255", "data_1255"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "ref_source", "argument": null, "type": "select", "label": "Gene annotation file", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "cached", "options": [["locally cached", "cached", false], ["in your history", "history", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "format", "argument": null, "type": "select", "label": "Output format", "help": "The output format will be tabular, select the preferred columns here", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "tabdel_short", "options": [["Gene-ID \"\\t\" read-count (DESeq2 IUC wrapper compatible)", "tabdel_short", true], ["Gene-ID \"\\t\" read-count \"\\t\" gene-length", "tabdel_medium", false], ["featureCounts 1.4.0+ default (includes regions provided by the GTF file)", "tabdel_full", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "include_feature_length_file", "argument": null, "type": "boolean", "label": "Create gene-length file", "help": "Creates a tabular file that contains the effective (nucleotides used for counting reads) length of the feature; might be useful for estimating FPKM/RPKM", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}, {"model_class": "Section", "name": "pe_parameters", "type": "section", "title": "Options for paired-end reads", "help": null, "expanded": false, "inputs": [{"model_class": "Conditional", "name": "fragment_counting_enabled", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": " -p", "inputs": [{"model_class": "Conditional", "name": "check_distance_enabled", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": " -P", "inputs": [{"model_class": "IntegerToolParameter", "name": "minimum_fragment_length", "argument": "-d", "type": "integer", "label": "Minimum fragment/template length.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maximum_fragment_length", "argument": "-D", "type": "integer", "label": "Maximum fragment/template length.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "600", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "BooleanToolParameter", "name": "check_distance", "argument": "-P", "type": "boolean", "label": "Check paired-end distance", "help": "If specified, paired-end distance will be checked when assigning fragments to meta-features or features. This option is only applicable when -p (Count fragments instead of reads) is specified. The distance thresholds should be specified using -d and -D (minimum and maximum fragment/template length) options.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -P", "falsevalue": ""}}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "fragment_counting", "argument": "-p", "type": "select", "label": "Count fragments instead of reads", "help": "If specified, fragments (or templates) will be counted instead of reads.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Disabled; all reads/mates will be counted individually", "", true], ["Enabled; fragments (or templates) will be counted instead of reads", " -p", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "only_both_ends", "argument": "-B", "type": "boolean", "label": "Only allow fragments with both reads aligned", "help": "If specified, only fragments that have both ends successfully aligned will be considered for summarization. This option is only applicable for paired-end reads.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -B", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "exclude_chimerics", "argument": "-C", "type": "boolean", "label": "Exclude chimeric fragments", "help": "If specified, the chimeric fragments (those fragments that have their two ends aligned to different chromosomes) will NOT be included for summarization. This option is only applicable for paired-end read data.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": " -C", "falsevalue": ""}]}, {"model_class": "Section", "name": "extended_parameters", "type": "section", "title": "Advanced options", "help": null, "expanded": false, "inputs": [{"model_class": "TextToolParameter", "name": "gff_feature_type", "argument": "-t", "type": "text", "label": "GFF feature type filter", "help": "Specify the feature type. Only rows which have the matched matched feature type in the provided GTF annotation file will be included for read counting. `exon' by default.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "exon", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "gff_feature_attribute", "argument": "-g", "type": "text", "label": "GFF gene identifier", "help": "Specify the attribute type used to group features (eg. exons) into meta-features (eg. genes), when GTF annotation is provided. `gene_id' by default. This attribute type is usually the gene identifier. This argument is useful for the meta-feature level summarization.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "gene_id", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "summarization_level", "argument": "-f", "type": "boolean", "label": "On feature level", "help": "If specified, read summarization will be performed at the feature level. By default (-f is not specified), the read summarization is performed at the meta-feature level.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -f", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "contribute_to_multiple_features", "argument": "-O", "type": "boolean", "label": "Allow read to contribute to multiple features", "help": "If specified, reads (or fragments if -p is specified) will be allowed to be assigned to more than one matched meta-feature (or matched feature if -f is specified)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " -O", "falsevalue": ""}, {"model_class": "SelectToolParameter", "name": "strand_specificity", "argument": "-s", "type": "select", "label": "Strand specificity of the protocol", "help": "Indicate if strand-specific read counting should be performed.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "options": [["Unstranded", "0", true], ["Stranded (forwards)", "1", false], ["Stranded (reverse)", "2", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "multimapping_enabled", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": " -M", "inputs": [{"model_class": "BooleanToolParameter", "name": "fraction", "argument": "--fraction", "type": "boolean", "label": "Assign fractions to multimapping reads", "help": "If specified, a fractional count 1/n will be generated for each multi-mapping read, where n is the number of alignments (indica- ted by 'NH' tag) reported for the read. This option must be used together with the '-M' option.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--fraction", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "multimapping_counts", "argument": "-M", "type": "select", "label": "Count multi-mapping reads/fragments", "help": "If specified, multi-mapping reads/fragments will be counted (ie. a multi-mapping read will be counted up to N times if it has N reported mapping locations). The program uses the `NH' tag to find multi-mapping reads.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Disabled; multi-mapping reads are excluded (default)", "", true], ["Enabled; multi-mapping reads are included", " -M", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "mapping_quality", "argument": "-Q", "type": "integer", "label": "Minimum mapping quality per read", "help": "The minimum mapping quality score a read must satisfy in order to be counted. For paired-end reads, at least one end should satisfy this criteria. 12 by default.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "12", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "exon_exon_junction_read_counting_enabled", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "-J", "inputs": [{"model_class": "DataToolParameter", "name": "genome", "argument": "-G", "type": "data", "label": "Reference sequence file", "help": "The FASTA-format file that contains the reference sequences used in read mapping can be used to improve read counting for junctions", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta"], "edam": {"edam_formats": ["format_1929"], "edam_data": ["data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "BooleanToolParameter", "name": "count_exon_exon_junction_reads", "argument": "-J", "type": "boolean", "label": "Exon-exon junctions", "help": "If specified, reads supporting each exon-exon junction will be counted", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "-J", "falsevalue": ""}}, {"model_class": "BooleanToolParameter", "name": "long_reads", "argument": "-L", "type": "boolean", "label": "Long reads", "help": "If specified, long reads such as Nanopore and PacBio reads will be counted. Long read counting can only run in one thread and only reads (not read-pairs) can be counted.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "-L", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "largest_overlap", "argument": "--largestOverlap", "type": "boolean", "label": "Largest overlap", "help": "If specified, reads (or fragments) will be assigned to the target that has the largest number of overlapping bases", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --largestOverlap", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "min_overlap", "argument": "--minOverlap", "type": "integer", "label": "Minimum overlap", "help": "Specify the minimum required number of overlapping bases between a read (or a fragment) and a feature. 1 by default. If a negative value is provided, the read will be extended from both ends.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "read_extension_5p", "argument": "--readExtension5", "type": "integer", "label": "Read 5' extension", "help": "Reads are extended upstream by ... bases from their 5' end", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "read_extension_3p", "argument": "--readExtension3", "type": "integer", "label": "Read 3' extension", "help": "Reads are extended upstream by ... bases from their 3' end", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "read_reduction", "argument": "--read2pos", "type": "select", "label": "Reduce read to single position", "help": "The read is reduced to its 5' most base or 3'most base. Read summarization is then performed based on the single base the the read is reduced to.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Leave the read as it is", "", true], ["Reduce it to the 5' end", "--read2pos 5", false], ["Reduce it to the 3' end", "--read2pos 3", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "primary", "argument": "--primary", "type": "boolean", "label": "Only count primary alignments", "help": "If specified, only primary alignments will be counted. Primary and secondary alignments are identified using bit 0x100 in theFlag field of SAM/BAM files. All primary alignments in a dataset will be counted regardless of whether they are from multi-mapping reads or not ('-M' is ignored).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --primary", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "ignore_dup", "argument": "--ignoreDup", "type": "boolean", "label": "Ignore reads marked as duplicate", "help": "If specified, reads that were marked as duplicates will be ignored. Bit Ox400 in the FLAG field of a SAM/BAM file is used for identifying duplicate reads. In paired end data, the entire read pair will be ignored if at least one end is found to be a duplicate read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --ignoreDup", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "count_split_alignments_only", "argument": "--countSplitAlignmentsOnly", "type": "boolean", "label": "Ignore unspliced alignments", "help": "If specified, only split alignments (CIGAR strings containing the letter `N') will be counted. All the other alignments will be ignored. An example of split alignments are exon-spanning reads in RNA-seq data.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": " --countSplitAlignmentsOnly", "falsevalue": ""}]}], "outputs": [{"model_class": "ToolOutput", "name": "output_medium", "format": "tabular", "label": "${tool.name} on ${on_string}", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_short", "format": "tabular", "label": "${tool.name} on ${on_string}", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_full", "format": "tabular", "label": "${tool.name} on ${on_string}: count table", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_summary", "format": "tabular", "label": "${tool.name} on ${on_string}: summary", "hidden": true, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_feature_lengths", "format": "tabular", "label": "${tool.name} on ${on_string}: feature lengths", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_jcounts", "format": "tabular", "label": "${tool.name} on ${on_string}: junction counts", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "rna_analysis", "panel_section_name": "RNA Analysis", "form_style": "regular"}