{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/iuc/qiime_split_libraries/qiime_split_libraries/1.9.1.0", "name": "Split libraries", "version": "1.9.1.0", "description": "according to barcodes specified in mapping file (split_libraries)", "labels": [], "edam_operations": ["operation_2945"], "edam_topics": ["topic_3070"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "qiime", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "qiime_split_libraries", "owner": "iuc", "changeset_revision": "481efc8a2fe2", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "map", "argument": "--map", "type": "data", "label": "Metadata mapping filepath", "help": "The file must contain header line indicating SampleID in the first column and BarcodeSequence in the second, LinkerPrimerSequence in the third. It is recommended to check the mapping file using the dedicated file", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular", "txt", "tsv", "csv"], "edam": {"edam_formats": ["format_3475", "format_2330", "format_3475", "format_3475"], "edam_data": ["data_0006", "data_0006", "data_0006", "data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "DataToolParameter", "name": "fasta", "argument": "--fasta", "type": "data", "label": "Input fasta files", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta"], "edam": {"edam_formats": ["format_1929"], "edam_data": ["data_2044"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "add_qual", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "true", "inputs": [{"model_class": "DataToolParameter", "name": "qual", "argument": "--qual", "type": "data", "label": "Input quality files (optional)", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["qual", "qual454", "qualillumina", "qualsolexa", "qualsolid"], "edam": {"edam_formats": ["format_3606", "format_3611", "format_3609", "format_3608", "format_3610"], "edam_data": ["data_2048", "data_2048", "data_2048", "data_2048", "data_2048"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "min_qual_score", "argument": "--min_qual_score", "type": "integer", "label": "Minimum average quality score allowed in read", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "25", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "qual_score_window", "argument": "--qual_score_window", "type": "integer", "label": "Size of the sliding window", "help": "If the average score of a continuous set of w nucleotides falls below the threshold, the sequence is discarded. A good value would be 50. 0 (zero) means no filtering. Must pass a .qual file (see -q parameter) if this functionality is enabled. Default behavior for this function is to truncate the sequence at the beginning of the poor quality window, and test for minimal length (-l parameter) of the resulting sequence", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "discard_bad_windows", "argument": "--discard_bad_windows", "type": "boolean", "label": "Discard any sequences where a bad window is found?", "help": "It will work if the sliding window length is bigger than 0", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--discard_bad_windows", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "record_qual_scores", "argument": "--record_qual_scores", "type": "boolean", "label": "Record quality scores for all sequences that are recorded?", "help": "If this option is enabled, a file named seqs_filtered.qual will be created in the output directory, and will contain the same sequence IDs in the seqs.fna file and sequence quality scores matching the bases present in the seqs.fna file", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--record_qual_scores", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "false", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "add_qual_test", "argument": null, "type": "select", "label": "Add quality files", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "false", "options": [["Yes", "true", false], ["No", "false", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "min_seq_length", "argument": "--min_seq_length", "type": "integer", "label": "Minimum sequence length", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "200", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_seq_length", "argument": "--max_seq_length", "type": "integer", "label": "Maximum sequence length", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "trim_seq_length", "argument": "--trim_seq_length", "type": "boolean", "label": "Compute sequence lengths after trimming and barcodes?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--trim_seq_length", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "keep_primer", "argument": "--keep_primer", "type": "boolean", "label": "Remove primer from sequences?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "--keep_primer"}, {"model_class": "BooleanToolParameter", "name": "keep_barcode", "argument": "--keep_barcode", "type": "boolean", "label": "Remove barcode from sequences?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "", "falsevalue": "--keep_barcode"}, {"model_class": "IntegerToolParameter", "name": "max_ambig", "argument": "--max_ambig", "type": "integer", "label": "Maximum number of ambiguous bases", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "6", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_homopolymer", "argument": "--max_homopolymer", "type": "integer", "label": "Maximum length of homopolymer run", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "6", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_primer_mismatch", "argument": "--max_primer_mismatch", "type": "integer", "label": "Maximum number of primer mismatch", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "barcode_selector", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "hamming_8", "inputs": []}, {"model_class": "ConditionalWhen", "value": "golay_12", "inputs": []}, {"model_class": "ConditionalWhen", "value": "variable_length", "inputs": []}, {"model_class": "ConditionalWhen", "value": "custom_length", "inputs": [{"model_class": "IntegerToolParameter", "name": "barcode_length", "argument": null, "type": "integer", "label": "Barcode length", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "4", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "barcode_type", "argument": "--barcode_type", "type": "select", "label": "Type of barcode", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "golay_12", "options": [["hamming_8", "hamming_8", false], ["golay_12", "golay_12", true], ["variable_length (disable any barcode correction)", "variable_length", false], ["Custom length", "custom_length", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "FloatToolParameter", "name": "max_barcode_errors", "argument": "--max_barcode_errors", "type": "float", "label": "Maximum number of errors in barcode", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "start_numbering_at", "argument": "--start_numbering_at", "type": "integer", "label": "Sequence id to use for the first sequence", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "retain_unassigned_reads", "argument": "--retain_unassigned_reads", "type": "boolean", "label": "Retain sequences with are Unassigned in the output sequence file?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--retain_unassigned_reads", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "disable_bc_correction", "argument": "--disable_bc_correction", "type": "boolean", "label": "Disable attempts to find nearest corrected barcode?", "help": "It can improve performance", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--disable_bc_correction", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "disable_primers", "argument": "--disable_primers", "type": "boolean", "label": "Disable primer usage when demultiplexing?", "help": "It should be enabled for unusual circumstances, such as analyzing Sanger sequence data generated with different primers", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--disable_primers", "falsevalue": ""}, {"model_class": "Conditional", "name": "reverse_primers_test", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "", "inputs": []}, {"model_class": "ConditionalWhen", "value": "--reverse_primers", "inputs": [{"model_class": "IntegerToolParameter", "name": "reverse_primer_mismatches", "argument": "--reverse_primer_mismatches", "type": "integer", "label": "Number of allowed mismatches for reverse primers", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "reverse_primers", "argument": "--reverse_primers", "type": "select", "label": "Enable removal of the reverse primer and any subsequence sequence from the end of each read?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Yes", "--reverse_primers", false], ["No", "", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "median_length_filtering", "argument": "--median_length_filtering", "type": "integer", "label": "Median length filtering (optional)", "help": "It disables minimum and maximum sequence length filtering, and instead calculates the median sequence length and filters the sequences based upon the number of median absolute deviations specified by this parameter. Any sequences with lengths outside the number of deviations will be removed", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "added_demultiplex_field", "argument": "--added_demultiplex_field", "type": "text", "label": "Field to use in the mapping file as additional demultiplexing (optional)", "help": "It can be used with or without barcodes. All combinations of barcodes/primers and these fields must be unique. The fields must contain values that can be parsed from the fasta labels such as 'plate=R_2008_12_09'. In this case, 'plate' would be the column header and 'R_2008_12_09' would be the field data (minus quotes) in the mapping file. To use the run prefix from the fasta label, such as 'FLP3FBN01ELBSX', where 'FLP3FBN01' is generated from the run ID, use 'run_prefix' and set the run prefix to be used as the data under the column header 'run_prefix'", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "truncate_ambi_bases", "argument": "--truncate_ambi_bases", "type": "boolean", "label": "Enable to truncate at the first N character encountered in the sequences?", "help": "This will disable testing for ambiguous bases", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--truncate_ambi_bases", "falsevalue": ""}], "outputs": [{"model_class": "ToolOutput", "name": "sequences", "format": "fasta", "label": "${tool.name} on ${on_string}: sequences", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "split_libraries/*.fna", "edam_format": "format_1929", "edam_data": "data_2044", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "log", "format": "txt", "label": "${tool.name} on ${on_string}: log", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "split_libraries/split_library_log.txt", "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "histograms", "format": "txt", "label": "${tool.name} on ${on_string}: histograms", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "split_libraries/histograms.txt", "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "quality", "format": "data", "label": "${tool.name} on ${on_string}: quality", "hidden": false, "output_type": "data", "format_source": "qual", "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "split_libraries/*.qual", "edam_format": "format_1915", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "qiime", "panel_section_name": "Qiime", "form_style": "regular"}