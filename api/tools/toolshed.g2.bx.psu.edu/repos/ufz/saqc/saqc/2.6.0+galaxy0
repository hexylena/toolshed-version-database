{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/ufz/saqc/saqc/2.6.0+galaxy0", "name": "SaQC", "version": "2.6.0+galaxy0", "description": "quality control pipelines for environmental sensor data", "labels": [], "icon": null, "edam_operations": [], "edam_topics": [], "hidden": "", "is_workflow_compatible": true, "xrefs": [], "tool_shed_repository": {"name": "saqc", "owner": "ufz", "changeset_revision": "724dcbb35c9a", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "data", "argument": "--data", "type": "data", "label": "Input table(s)", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["csv"], "edam": {"edam_formats": ["format_3475"], "edam_data": ["data_0006"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "HiddenToolParameter", "name": "run_test_mode", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "false"}, {"model_class": "Repeat", "name": "methods_repeat", "type": "repeat", "title": "Methods (add multiple QC steps)", "help": null, "default": 0, "min": 0, "max": "__Infinity__", "inputs": [{"model_class": "Conditional", "name": "module_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "breaks", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "flagIsolated", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "gap_window", "argument": "gap_window", "type": "text", "label": "Minimum gap size required before and after a data group to consider it isolated", "help": "See condition (2) and (3)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "group_window", "argument": "group_window", "type": "text", "label": "Maximum size of a data chunk to consider it a candidate for an isolated group", "help": "Data chunks that are bigger than the `group_window` are ignored. This does not include the possible gaps surrounding it. See condition (1)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagJumps", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "Threshold value by which the mean of data has to jump, to trigger flagging", "help": "Threshold value by which the mean of data has to jump, to trigger flagging", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the two moving windows", "help": "This determines the number of observations used for calculating the mean in every window. The window size should be big enough to yield enough samples for a reliable mean calculation, but it should also not be arbitrarily big, since it also limits the density of jumps that can be detected. More precisely: Jumps that are not distanced to each other by more than three fourth (3/4) of the selected `window` size, will not be detected reliably", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "The minimum number of observations in `window` required to calculate a valid mean value", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dfilter", "argument": "dfilter", "type": "float", "label": "dfilter", "help": "Any, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "-inf", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagMissing", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dfilter", "argument": "dfilter", "type": "float", "label": "dfilter", "help": "Any, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "-inf", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "flagIsolated", "options": [["flagIsolated: Find and flag temporal isolated groups of data", "flagIsolated", false], ["flagJumps: Flag jumps and drops in data", "flagJumps", false], ["flagMissing: Flag NaNs in data", "flagMissing", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "changepoints", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "assignChangePointCluster", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "stat_func", "argument": "stat_func", "type": "text", "label": "A function that assigns a value to every twin window", "help": "Left window content will be passed to first variable, right window content will be passed to the second", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "thresh_func", "argument": "thresh_func", "type": "text", "label": "thresh_func", "help": "A function that determines the value level, exceeding wich qualifies a timestamps func value as denoting a changepoint", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the rolling windows the calculation is performed in", "help": "If it is a single frequency offset, it applies for the backward- and the forward-facing window.  If two offsets (as a tuple) is passed the first defines the size of the backward facing window, the second the size of the forward facing window (String or two comma-separated strings, e.g., val1,val2)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "min_periods", "argument": "min_periods", "type": "text", "label": "min_periods", "help": "Minimum number of observations in a window required to perform the changepoint test. If it is a tuple of two int, the first refer to the backward-, the second to the forward-facing window (Integer or two comma-separated integers, e.g., 1,2)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "reduce_window", "argument": "reduce_window", "type": "text", "label": "reduce_window", "help": "The sliding window search method is not an exact CP search method and usually there won't be detected a single changepoint, but a  region  of change around a changepoint. If `reduce_window` is given, for every window of size `reduce_window`, there will be selected the value with index `reduce_func(x, y)` and the others will be dropped. If `reduce_window` is None, the reduction window size equals the twin window size, the changepoints have been detected with", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "reduce_func", "argument": "reduce_func", "type": "text", "label": "reduce_func", "help": "default argmax A function that must return an index value upon input of two arrays x and y. First input parameter will hold the result from the stat_func evaluation for every reduction window. Second input parameter holds the result from the thresh_func evaluation. The default reduction function just selects the value that maximizes the stat_func", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function ChangepointsMixin.<lambda> at 0x789a868a0e00>", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "model_by_resids", "argument": "model_by_resids", "type": "boolean", "label": "If True, the results of `stat_funcs` are written, otherwise the regime labels", "help": "If True, the results of `stat_funcs` are written, otherwise the regime labels", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "model_by_resids", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "flagChangePoints", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "stat_func", "argument": "stat_func", "type": "text", "label": "A function that assigns a value to every twin window", "help": "The backward-facing window content will be passed as the first array, the forward-facing window content as the second", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "thresh_func", "argument": "thresh_func", "type": "text", "label": "thresh_func", "help": "A function that determines the value level, exceeding wich qualifies a timestamps func value as denoting a change-point", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the moving windows", "help": "This is the number of observations used for calculating the statistic.  If it is a single frequency offset, it applies for the backward- and the forward-facing window.  If two offsets (as a tuple) is passed the first defines the size of the backward facing window, the second the size of the forward facing window (String or two comma-separated strings, e.g., val1,val2)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "min_periods", "argument": "min_periods", "type": "text", "label": "min_periods", "help": "Minimum number of observations in a window required to perform the changepoint test. If it is a tuple of two int, the first refer to the backward-, the second to the forward-facing window (Integer or two comma-separated integers, e.g., 1,2)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "reduce_window", "argument": "reduce_window", "type": "text", "label": "reduce_window", "help": "The sliding window search method is not an exact CP search method and usually there wont be detected a single changepoint, but a  region  of change around a changepoint.  If `reduce_window` is given, for every window of size `reduce_window`, there will be selected the value with index `reduce_func(x, y)` and the others will be dropped.  If `reduce_window` is None, the reduction window size equals the twin window size, the changepoints have been detected with", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "reduce_func", "argument": "reduce_func", "type": "text", "label": "reduce_func", "help": "default argmax A function that must return an index value upon input of two arrays x and y. First input parameter will hold the result from the stat_func evaluation for every reduction window. Second input parameter holds the result from the `thresh_func` evaluation. The default reduction function just selects the value that maximizes the `stat_func`", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function ChangepointsMixin.<lambda> at 0x789a868a0c20>", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "assignChangePointCluster", "options": [["assignChangePointCluster: Label data where it changes significantly", "assignChangePointCluster", false], ["flagChangePoints: Flag values that represent a system state transition", "flagChangePoints", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "constants", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "flagByVariance", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the moving window", "help": "This is the number of observations used for calculating the statistic. Each window will be a fixed size. If its an offset then this will be the time period of each window. Each window will be sized, based on the number of observations included in the time-period", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "Maximum total variance allowed per window", "help": "Maximum total variance allowed per window", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxna", "argument": "maxna", "type": "integer", "label": "Maximum number of NaNs allowed in window", "help": "If more NaNs are present, the window is not flagged", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxna_group", "argument": "maxna_group", "type": "integer", "label": "Same as `maxna` but for consecutive NaNs", "help": "Same as `maxna` but for consecutive NaNs", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagConstants", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "Maximum total change allowed per window", "help": "Maximum total change allowed per window", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the moving window", "help": "This determines the number of observations used for calculating the absolute change per window. Each window will either contain a fixed number of periods (integer defined window), or will have a fixed temporal extension (offset defined window)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "Minimum number of observations in window required to generate a flag", "help": "This can be used to exclude underpopulated *offset* defined windows from flagging. (Integer defined windows will always contain exactly *window* samples). Must be an integer greater or equal `2`, because a single value would always be considered constant. Defaults to `2`", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "flagByVariance", "options": [["flagByVariance: Flag low-variance data", "flagByVariance", false], ["flagConstants: Flag constant data values", "flagConstants", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "curvefit", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "fitLowpassFilter", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "cutoff", "argument": "cutoff", "type": "text", "label": "cutoff", "help": "The cutoff-frequency, either an offset freq string, or expressed in multiples of the sampling rate", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "nyq", "argument": "nyq", "type": "float", "label": "The niquist-frequency", "help": "expressed in multiples if the sampling rate", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "filter_order", "argument": "filter_order", "type": "integer", "label": "filter_order", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "fill_method", "argument": "fill_method", "type": "select", "label": "fill_method", "help": "Fill method to be applied on the data before filtering (butterfilter cant handle ''np.nan''). See documentation of pandas.Series.interpolate method for details on the methods associated with the different keywords", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["linear", "linear", false], ["nearest", "nearest", false], ["zero", "zero", false], ["slinear", "slinear", false], ["quadratic", "quadratic", false], ["cubic", "cubic", false], ["spline", "spline", false], ["barycentric", "barycentric", false], ["polynomial", "polynomial", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "fitPolynomial", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the window you want to use for fitting", "help": "If an integer is passed, the size refers to the number of periods for every fitting window. If an offset string is passed, the size refers to the total temporal extension. The window will be centered around the vaule-to-be-fitted. For regularly sampled data always a odd number of periods will be used for the fit (periods-1 if periods is even)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "order", "argument": "order", "type": "integer", "label": "Degree of the polynomial used for fitting", "help": "Degree of the polynomial used for fitting", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of observations in a window required to perform the fit, otherwise NaNs will be assigned. If ``None``, `min_periods` defaults to 1 for integer windows and to the size of the window for offset based windows. Passing 0, disables the feature and will result in over-fitting for too sparse windows", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "fitLowpassFilter", "options": [["fitLowpassFilter: Fits the data using the butterworth filter", "fitLowpassFilter", false], ["fitPolynomial: Fits a polynomial model to the data", "fitPolynomial", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "drift", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "assignRegimeAnomaly", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "cluster_field", "argument": "cluster_field", "type": "text", "label": "Column in data, holding the cluster labels for the samples in field", "help": "(has to be indexed equal to field)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "A threshold denoting the value level, up to wich clusters a agglomerated", "help": "A threshold denoting the value level, up to wich clusters a agglomerated", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "The linkage method for hierarchical (agglomerative) clustering of the variables", "help": "The linkage method for hierarchical (agglomerative) clustering of the variables", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["single", "single", false], ["complete", "complete", false], ["average", "average", false], ["weighted", "weighted", false], ["centroid", "centroid", false], ["median", "median", false], ["ward", "ward", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "metric", "argument": "metric", "type": "text", "label": "A metric function for calculating the dissimilarity between 2 regimes", "help": "Defaults to the absolute difference in mean", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function DriftMixin.<lambda> at 0x789a8308d800>", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "frac", "argument": "frac", "type": "float", "label": "frac", "help": "The minimum percentage of samples, the  normal  group has to comprise to actually be the normal group. Must be in the closed interval `[0,1]`, otherwise a ValueError is raised", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "correctDrift", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "maintenance_field", "argument": "maintenance_field", "type": "text", "label": "Column holding the support-points information", "help": "The data is expected to have the following form: The index of the series represents the beginning of a maintenance event, wheras the values represent its endings", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "model_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "linear", "inputs": [{"model_class": "HiddenToolParameter", "name": "model", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "linear"}]}, {"model_class": "ConditionalWhen", "value": "exponential", "inputs": [{"model_class": "HiddenToolParameter", "name": "model", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "exponential"}]}, {"model_class": "ConditionalWhen", "value": "custom", "inputs": [{"model_class": "TextToolParameter", "name": "model", "argument": "model", "type": "text", "label": "A model function describing the drift behavior, that is to be corrected (Custom Callable Name)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "model_select_type", "argument": null, "type": "select", "label": "A model function describing the drift behavior, that is to be corrected Model Type", "help": "Either use built-in exponential or linear drift model by passing a string, or pass a custom callable. The model function must always contain the keyword parameters 'origin' and 'target'. The starting parameter must always be the parameter, by wich the data is passed to the model. After the data parameter, there can occure an arbitrary number of model calibration arguments in the signature. See the Notes section for an extensive description", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "linear", "options": [["Linear Model", "linear", false], ["Exponential Model", "exponential", false], ["Custom Callable", "custom", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "cal_range", "argument": "cal_range", "type": "integer", "label": "cal_range", "help": "Number of values to calculate the mean of, for obtaining the value level directly after and directly before a maintenance event. Needed for shift calibration", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "correctOffset", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "max_jump", "argument": "max_jump", "type": "float", "label": "max_jump", "help": "when searching for changepoints in mean - this is the threshold a mean difference in the sliding window search must exceed to trigger changepoint detection", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "spread", "help": "threshold denoting the maximum, regimes are allowed to abolutely differ in their means to form the  normal group  of values", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the adjacent windows that are used to search for the mean changepoints", "help": "Size of the adjacent windows that are used to search for the mean changepoints", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of periods a search window has to contain, for the result of the changepoint detection to be considered valid", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "tolerance", "argument": "tolerance", "type": "text", "label": "tolerance", "help": "If an offset string is passed, a data chunk of length `offset` right from the start and right before the end of any regime is ignored when calculating a regimes mean for data correcture. This is to account for the unrelyability of data near the changepoints of regimes", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "correctRegimeAnomaly", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "cluster_field", "argument": "cluster_field", "type": "text", "label": "cluster_field", "help": "A string denoting the field in data, holding the cluster label for the data you want to correct", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "model", "argument": "model", "type": "text", "label": "The model function to be fitted to the regimes", "help": "It must be a function of the form :math:`f(x, *p)`, where :math:`x` is the ``numpy.array`` holding the independent variables and :math:`p` are the model parameters that are to be obtained by fitting. Depending on the `x_date` parameter, independent variable x will either be the timestamps of every regime transformed to seconds from epoch, or it will be just seconds, counting the regimes length (Expects a function reference: (...).)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "tolerance", "argument": "tolerance", "type": "text", "label": "tolerance", "help": "If an offset string is passed, a data chunk of length `offset` right at the start and right at the end is ignored when fitting the model. This is to account for the unreliability of data near the changepoints of regimes. Defaults to None", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "epoch", "argument": "epoch", "type": "boolean", "label": "epoch", "help": "If True, use  seconds from epoch  as x input to the model func, instead of  seconds from regime start ", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "epoch", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "flagDriftFromNorm", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Frequency, that split the data in chunks", "help": "Frequency, that split the data in chunks", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "Maximum spread allowed in the group of *normal* data", "help": "See Notes section for more details", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "frac", "argument": "frac", "type": "float", "label": "Fraction defining the normal group", "help": "Use a value from the interval [0,1]. The higher the value, the more stable the algorithm will be. For values below 0.5 the results are undefined", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "metric", "argument": "metric", "type": "text", "label": "metric", "help": "default cityblock Distance function that takes two arrays as input and returns a scalar float. This value is interpreted as the distance of the two input arrays. Defaults to the `averaged manhattan metric` (see Notes)", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function cityblock at 0x789a8308c9a0>", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Linkage method used for hierarchical (agglomerative) clustering of the data", "help": "`method` is directly passed to ``scipy.hierarchy.linkage``. See its documentation [1] for more details. For a general introduction on hierarchical clustering see [2]", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["single", "single", false], ["complete", "complete", false], ["average", "average", false], ["weighted", "weighted", false], ["centroid", "centroid", false], ["median", "median", false], ["ward", "ward", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagDriftFromReference", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "TextToolParameter", "name": "reference", "argument": "reference", "type": "text", "label": "Reference variable, the deviation is calculated from", "help": "Reference variable, the deviation is calculated from", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "Frequency, that split the data in chunks", "help": "Frequency, that split the data in chunks", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "Maximum deviation from reference", "help": "Maximum deviation from reference", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "metric", "argument": "metric", "type": "text", "label": "metric", "help": "default cityblock Distance function. Takes two arrays as input and returns a scalar float. This value is interpreted as the mutual distance of the two input arrays. Defaults to the `averaged manhattan metric` (see Notes)", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function cityblock at 0x789a8308c9a0>", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagRegimeAnomaly", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "cluster_field", "argument": "cluster_field", "type": "text", "label": "Column in data, holding the cluster labels for the samples in field", "help": "(has to be indexed equal to field)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "spread", "argument": "spread", "type": "float", "label": "A threshold denoting the value level, up to wich clusters a agglomerated", "help": "A threshold denoting the value level, up to wich clusters a agglomerated", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "The linkage method for hierarchical (agglomerative) clustering of the variables", "help": "The linkage method for hierarchical (agglomerative) clustering of the variables", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["single", "single", false], ["complete", "complete", false], ["average", "average", false], ["weighted", "weighted", false], ["centroid", "centroid", false], ["median", "median", false], ["ward", "ward", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "metric", "argument": "metric", "type": "text", "label": "A metric function for calculating the dissimilarity between 2 regimes", "help": "Defaults to the absolute difference in mean", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function DriftMixin.<lambda> at 0x789a8308d6c0>", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "frac", "argument": "frac", "type": "float", "label": "frac", "help": "The minimum percentage of samples, the  normal  group has to comprise to actually be the normal group. Must be in the closed interval `[0,1]`, otherwise a ValueError is raised", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "assignRegimeAnomaly", "options": [["assignRegimeAnomaly: A function to detect values belonging to an anomalous regime regarding modelling", "assignRegimeAnomaly", false], ["correctDrift: The function corrects drifting behavior", "correctDrift", false], ["correctOffset: Parameters", "correctOffset", false], ["correctRegimeAnomaly: Function fits the passed model to the different regimes in data[field] and tries to correct", "correctRegimeAnomaly", false], ["flagDriftFromNorm: Flags data that deviates from an avarage data course", "flagDriftFromNorm", false], ["flagDriftFromReference: Flags data that deviates from a reference course. Deviation is measured by a", "flagDriftFromReference", false], ["flagRegimeAnomaly: Flags anomalous regimes regarding to modelling regimes of ``field``", "flagRegimeAnomaly", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "flagtools", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "andGroup", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "group", "argument": "group", "type": "text", "label": "A collection of ``SaQC`` objects", "help": "Flag checks are performed on all ``SaQC`` objects based on the variables specified in ``field``. Whenever all monitored variables are flagged, the associated timestamps will receive a flag", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "clearFlags", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagDummy", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagManual", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "mdata", "argument": "mdata", "type": "text", "label": "Determines which values or intervals will be flagged", "help": "Supported input types:  * ``pd.Series``: Needs a datetime index and values of type:  - datetime, for `method` values `` right-closed ``, `` left-closed ``, `` closed `` - or any scalar, for `method` values `` plain ``, `` ontime ``  * ``str``: Variable holding the manual flag information. * ``pd.DataFrame``, ``DictOfSeries``: Need to provide a ``pd.Series`` with column name `field`. * ``list``, ``np.ndarray``: Only supported with `method` value `` plain `` and `mformat` value `` mflag ``", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "method", "help": "Defines how `mdata` is projected to data:  * `` plain ``: `mdata` must have the same length as `field`, flags are set, where the values in `mdata` equal `mflag`. * `` ontime ``: Expects datetime indexed `mdata` (types ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``). Flags are set, where the values in `mdata` equal `mflag` and the indices of `field` and `mdata` match. * `` right-open ``: Expects datetime indexed `mdata`, which will be interpreted as a number of time intervals ``t_1, t_2``. Flags are set to all timestamps ``t`` of `field` with ``t_1  = t   t_2``. * `` left-open ``: like `` right-open ``, but the interval covers all ``t`` with ``t_1   t  = t_2``. * `` closed ``: like `` right-open ``, but the interval now covers all ``t`` with ``t_1  = t  = t_2``", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["left-open", "left-open", false], ["right-open", "right-open", false], ["closed", "closed", false], ["plain", "plain", false], ["ontime", "ontime", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "mformat", "argument": "mformat", "type": "select", "label": "mformat", "help": "Controls the interval definition in `mdata` (see examples):  * `` start-end ``: expects datetime indexed `mdata` (types ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``) with values of type datetime. Each index-value pair is interpreted as an interval to flag, the index defines the left bound, the respective value the right bound. * `` mflag ``:  - `mdata` of type ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``: Two successive index values ``i_1, i_2`` will be interpreted as an interval ``t_1, t_2`` to flag, if the value of ``t_1`` equals `mflag` - `mdata` of type ``list``, ``np.ndarray``: Flags all `field` where `mdata` euqals `mflag`", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["start-end", "start-end", false], ["mflag", "mflag", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "mflag", "argument": "mflag", "type": "text", "label": "mflag", "help": "Value in `mdata` indicating that a flag should be set at the respective position, timestamp or interval. Ignored if `mformat` is set to `` start-end ``", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagUnflagged", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "forceFlags", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "flag", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "orGroup", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "group", "argument": "group", "type": "text", "label": "A collection of ``SaQC`` objects", "help": "Flag checks are performed on all ``SaQC`` objects based on the variables specified in `field`. Whenever any of monitored variables is flagged, the associated timestamps will receive a flag", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "propagateFlags", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the repetition window", "help": "An integer defines the exact number of repetitions, strings are interpreted as time offsets to fill with", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Direction of repetetion", "help": "With  ffill  the subsequent values receive the flag to repeat, with  bfill  the previous values", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["ffill", "ffill", false], ["bfill", "bfill", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dfilter", "argument": "dfilter", "type": "float", "label": "dfilter", "help": "Any, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "-inf", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "transferFlags", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "squeeze", "argument": "squeeze", "type": "boolean", "label": "squeeze", "help": "Squeeze the history into a single column if ``True``, function specific flag information is lost", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "squeeze", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "overwrite", "argument": "overwrite", "type": "boolean", "label": "Overwrite existing flags if ``True``", "help": "Overwrite existing flags if ``True``", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "overwrite", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "andGroup", "options": [["andGroup: Flag all values, if all the given ``field`` values are already flagged", "andGroup", false], ["clearFlags: Assign UNFLAGGED value to all periods in field", "clearFlags", false], ["flagDummy: Function does nothing but returning data and flags", "flagDummy", false], ["flagManual: Include flags listed in external data", "flagManual", false], ["flagUnflagged: Function sets a flag at all unflagged positions", "flagUnflagged", false], ["forceFlags: Set whole column to a flag value", "forceFlags", false], ["orGroup: Flag all values, if at least one of the given ``field`` values is already flagged", "orGroup", false], ["propagateFlags: Flag values before or after flags set by the last test", "propagateFlags", false], ["transferFlags: Transfer Flags of one variable to another", "transferFlags", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "generic", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "flagGeneric", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "Function to call", "help": "The function needs to accept the same number of arguments (of type pandas.Series) as variables given in ``field`` and return an iterable of array-like objects of data type ``bool`` with the same length as ``target`` (Expects a function reference: (...).)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "processGeneric", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "Function to call on the variables given in ``field``", "help": "The return value will be written to ``target`` or ``field`` if the former is not given. This implies, that the function needs to accept the same number of arguments (of type pandas.Series) as variables given in ``field`` and should return an iterable of array-like objects with the same number of elements as given in ``target`` (or ``field`` if ``target`` is not specified) (Expects a function reference: (...).)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dfilter", "argument": "dfilter", "type": "float", "label": "dfilter", "help": "Any, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "-inf", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "flagGeneric", "options": [["flagGeneric: Flag data based on a given function", "flagGeneric", false], ["processGeneric: Generate/process data with user defined functions", "processGeneric", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "interpolation", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "align", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "Target frequency", "help": "Target frequency", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "method", "argument": "method", "type": "text", "label": "Interpolation technique to use", "help": "One of:  * ``'nshift'``: Shift grid points to the nearest time stamp in the range = +/- 0.5 * ``freq``. * ``'bshift'``: Shift grid points to the first succeeding time stamp (if any). * ``'fshift'``: Shift grid points to the last preceeding time stamp (if any). * ``'linear'``: Ignore the index and treat the values as equally spaced. * ``'time'``, ``'index'``, ``'values'``: Use the actual numerical values of the index. * ``'pad'``: Fill in NaNs using existing values. * ``'spline'``, ``'polynomial'``: Passed to ``scipy.interpolate.interp1d``. These methods use the numerical values of the index.  An ``order`` must be specified, e.g. ``qc.interpolate(method='polynomial', order=5)``. * ``'nearest'``, ``'zero'``, ``'slinear'``, ``'quadratic'``, ``'cubic'``, ``'barycentric'``: Passed to ``scipy.interpolate.interp1d``. These methods use the numerical values of the index. * ``'krogh'``, ``'spline'``, ``'pchip'``, ``'akima'``, ``'cubicspline'``: Wrappers around the SciPy interpolation methods of similar names. * ``'from_derivatives'``: Refers to ``scipy.interpolate.BPoly.from_derivatives``", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "time", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "order", "argument": "order", "type": "integer", "label": "order", "help": "Order of the interpolation method, ignored if not supported by the chosen ``method``", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "overwrite", "argument": "overwrite", "type": "boolean", "label": "If set to `True`, existing flags will be cleared", "help": "If set to `True`, existing flags will be cleared", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "overwrite", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "interpolateByRolling", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "The size of the window, the aggregation is computed from", "help": "An integer define the number of periods to be used, a string is interpreted as an offset. ( see `pandas.rolling` for more information). Integer windows may result in screwed aggregations if called on none-harmonized or irregular data", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "default median The function used for aggregation", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "median", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "center", "argument": "center", "type": "boolean", "label": "Center the window around the value", "help": "Can only be used with integer windows, otherwise it is silently ignored", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "center", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of valid (not np.nan) values that have to be available in a window for its aggregation to be computed", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "-inf", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "align", "options": [["align: Convert time series to specified frequency. Values affected by", "align", false], ["interpolateByRolling: Replace NaN by the aggregation result of the surrounding window", "interpolateByRolling", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "noise", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "flagByScatterLowpass", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "window", "help": "Window (i.e. chunk) size", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "thresh", "help": "Threshold. A given chunk is flagged, if the return value of ``func`` excceeds ``thresh``", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "Either a string, determining the aggregation function applied on every chunk:  * 'std': standard deviation * 'var': variance * 'mad': median absolute deviation  Or a Callable, mapping 1 dimensional array likes onto scalars", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "std", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "sub_window", "argument": "sub_window", "type": "text", "label": "sub_window", "help": "Window size of sub chunks, that are additionally tested for exceeding ``sub_thresh`` with respect to ``func`` (Pandas timedelta string or offset, e.g., '1D', '2H30M')", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "sub_thresh", "argument": "sub_thresh", "type": "float", "label": "sub_thresh", "help": "Threshold. A given sub chunk is flagged, if the return value of ``func` excceeds ``sub_thresh``", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "Minimum number of values needed in a chunk to perfom the test", "help": "Ignored if ``window`` is an integer", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagByStatLowPass", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "window", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "thresh", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "Either a String value, determining the aggregation function applied on every chunk.  * 'std': standard deviation * 'var': variance * 'mad': median absolute deviation  Or a Callable function mapping 1 dimensional arraylikes onto scalars.  window : Window (i.e. chunk) size.  thresh : Threshold. A given chunk is flagged, if the return value of ``func`` excceeds ``thresh``.  sub_window : Window size of sub chunks, that are additionally tested for exceeding ``sub_thresh`` with respect to ``func``.  sub_thresh : Threshold. A given sub chunk is flagged, if the return value of ``func` excceeds ``sub_thresh``.  min_periods : Minimum number of values needed in a chunk to perfom the test. Ignored if ``window`` is an integer", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "std", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "sub_window", "argument": "sub_window", "type": "text", "label": "sub_window", "help": " (Pandas timedelta string or offset, e.g., '1D', '2H30M')", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "sub_thresh", "argument": "sub_thresh", "type": "float", "label": "sub_thresh", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "flag", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "flagByScatterLowpass", "options": [["flagByScatterLowpass: Flag data chunks of length ``window`` dependent on the data deviation", "flagByScatterLowpass", false], ["flagByStatLowPass: Flag data chunks of length ``window`` dependent on the data deviation", "flagByStatLowPass", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "outliers", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "flagByGrubbs", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the testing window", "help": "If an integer, the fixed number of observations used for each window. If an offset string the time period of each window", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "Level of significance, the grubbs test is to be performed at", "help": "Must be between 0 and 1", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of values needed in a `window` in order to perform the grubs test. Ignored if `window` is an integer", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "8", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "pedantic", "argument": "pedantic", "type": "boolean", "label": "If ``True``, every value gets checked twice", "help": "First in the initial rolling `window` and second in a rolling window that is lagging by `window` / 2. Recommended to avoid false positives at the window edges. Ignored if `window` is an offset string", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "pedantic", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagByStray", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "window_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "IntegerToolParameter", "name": "window", "argument": "window", "type": "integer", "label": "window (as number)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "timedelta", "inputs": [{"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "window (as timedelta string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "window", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "window_select_type", "argument": null, "type": "select", "label": "window Input Mode", "help": "Determines the segmentation of the data into partitions, the kNN algorithm is applied onto individually.  * ``None``: Apply Scoring on whole data set at once * ``int``: Apply scoring on successive data chunks of periods with the given length. Must be greater than 0. * offset String : Apply scoring on successive partitions of temporal extension matching the passed offset string", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Number", "number", false], ["Timedelta", "timedelta", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of periods per partition that have to be present for a valid outlier detection to be made in this partition", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "11", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "iter_start", "argument": "iter_start", "type": "float", "label": "iter_start", "help": "Float in ``[0, 1]`` that determines which percentage of data is considered  normal . ``0.5`` results in the stray algorithm to search only the upper 50% of the scores for the cut off point. (See reference section for more information)", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "alpha", "help": "Level of significance by which it is tested, if a score might be drawn from another distribution than the majority of the data", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagLOF", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "Number of neighbors to be included into the LOF calculation", "help": "Defaults to ``20``, which is a value found to be suitable in the literature.  * `n` determines the  locality  of an observation (its `n` nearest neighbors) and sets the upper limit to the number of values in outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n`/2 may not be detected reliably. * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outliers points. Higher values greatly increase numerical costs", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "20", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "thresh_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "auto", "inputs": [{"model_class": "HiddenToolParameter", "name": "thresh", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "auto"}]}, {"model_class": "ConditionalWhen", "value": "float", "inputs": [{"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "The threshold for flagging the calculated LOF (float value)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.5", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "thresh", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "thresh_select_type", "argument": null, "type": "select", "label": "The threshold for flagging the calculated LOF Mode", "help": "A LOF of around ``1`` is considered normal and most likely corresponds to inlier points.  * The  automatic  threshing introduced with the publication of the algorithm defaults to ``1.5``. * In this implementation, `thresh` defaults (``'auto'``) to flagging the scores with a modified 3-sigma rule", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatic ('auto')", "auto", false], ["Specific Value (float)", "float", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "algorithm", "argument": "algorithm", "type": "select", "label": "Algorithm used for calculating the `n`-nearest neighbors", "help": "Algorithm used for calculating the `n`-nearest neighbors", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["ball_tree", "ball_tree", false], ["kd_tree", "kd_tree", false], ["brute", "brute", false], ["auto", "auto", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "p", "argument": "p", "type": "integer", "label": "p", "help": "Degree of the metric ( Minkowski ), according to which the distance to neighbors is determined. Most important values are:  * ``1`` - Manhattan Metric * ``2`` - Euclidian Metric", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagMAD", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "window_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "IntegerToolParameter", "name": "window", "argument": "window", "type": "integer", "label": "Size of the window (as number)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "timedelta", "inputs": [{"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the window (as timedelta string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "window", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "window_select_type", "argument": null, "type": "select", "label": "Size of the window Input Mode", "help": "Either given as an Offset String, denoting the window's temporal extension or as an integer, denoting the window's number of periods. ``NaN`` also count as periods. If ``None``, all data points share the same scoring window, which than equals the whole data", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Number", "number", false], ["Timedelta", "timedelta", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "FloatToolParameter", "name": "z", "argument": "z", "type": "float", "label": "The value the Z-score is tested against", "help": "Defaulting to ``3.5`` (Recommendation of [1])", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "3.5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_residuals", "argument": "min_residuals", "type": "integer", "label": "min_residuals", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of valid meassurements in a scoring window, to consider the resulting score valid", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "center", "argument": "center", "type": "boolean", "label": "Weather or not to center the target value in the scoring window", "help": "If ``False``, the target value is the last value in the window", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "center", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagMVScores", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "TextToolParameter", "name": "trafo", "argument": "trafo", "type": "text", "label": "Transformation to be applied onto every column before scoring", "help": "For more fine-grained control, the data could also be transformed before :py:meth:`~saqc.SaQC.flagMVScores` is called", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "<function OutliersMixin.<lambda> at 0x789a830b5c60>", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "alpha", "argument": "alpha", "type": "float", "label": "alpha", "help": "Level of significance by which it is tested, if an observations score might be drawn from another distribution than the majority of the data", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "Number of neighbors included in the scoring process for every datapoint", "help": "Number of neighbors included in the scoring process for every datapoint", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "Function that aggregates a value's k-smallest distances, returning a scalar score", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "sum", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "iter_start", "argument": "iter_start", "type": "float", "label": "iter_start", "help": "Value in ``[0,1]`` that determines which percentage of data is considered  normal . 0.5 results in the threshing algorithm to search only the upper 50% of the scores for the cut-off point. (See reference section for more information)", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.5", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "window_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "IntegerToolParameter", "name": "window", "argument": "window", "type": "integer", "label": "Only effective if `threshing` is set to ``'stray'`` (as number)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "timedelta", "inputs": [{"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Only effective if `threshing` is set to ``'stray'`` (as timedelta string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "window", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "window_select_type", "argument": null, "type": "select", "label": "Only effective if `threshing` is set to ``'stray'`` Input Mode", "help": "Determines the size of the data partitions, the data is decomposed into. Each partition is checked seperately for outliers. Either given as an Offset String, denoting the windows temporal extension or as an integer, denoting the windows number of periods. ``NaN`` also count as periods. If ``None``, all data points share the same scoring window, which than equals the whole data", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Number", "number", false], ["Timedelta", "timedelta", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Only effective if `threshing` is set to ``'stray'`` and `partition` is an integer. Minimum number of periods per `partition` that have to be present for a valid outlier detection to be made in this partition", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "11", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "stray_range", "argument": "stray_range", "type": "text", "label": "stray_range", "help": "If not ``None``, it is tried to reduce the stray result onto single outlier components of the input `field`. The offset string denotes the range of the temporal surrounding to include into the MAD testing while trying to reduce flags", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "drop_flagged", "argument": "drop_flagged", "type": "boolean", "label": "Only effective when `stray_range` is not ``None``", "help": "Whether or not to drop flagged values from the temporal surroundings", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "drop_flagged", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "Only effective when `stray_range` is not ``None``", "help": "The 'critical' value, controlling wheather the MAD score is considered referring to an outlier or not. Higher values result in less rigid flagging. The default value is widely considered apropriate in the literature", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "3.5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods_r", "argument": "min_periods_r", "type": "integer", "label": "Only effective when `stray_range` is not ``None``", "help": "Minimum number of measurements necessary in an interval to actually perform the reduction step", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagOffset", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "tolerance", "argument": "tolerance", "type": "float", "label": "tolerance", "help": "Maximum difference allowed between the value, directly preceding and the value directly succeeding an offset to trigger flagging of the offsetting values. See condition (4)", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "window", "help": "Maximum length allowed for offset value courses, to trigger flagging of the offsetting values. See condition (5). Integer defined window length are only allowed for regularly sampled timeseries", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "thresh", "help": "Minimum difference between a value and its successors, to consider the successors an anomalous offset group. See condition (1). If ``None``, condition (1) is not tested", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh_relative", "argument": "thresh_relative", "type": "float", "label": "thresh_relative", "help": "Minimum relative change between a value and its successors, to consider the successors an anomalous offset group. See condition (2). If ``None``, condition (2) is not tested", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagRaise", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "thresh", "help": "The threshold, for the total rise (`thresh` ``  0``), or total drop (`thresh` ``  0``), value courses must not exceed within a timespan of length `raise_window`", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "raise_window", "argument": "raise_window", "type": "text", "label": "raise_window", "help": "An offset string, determining the timespan, the rise/drop thresholding refers to. Window is inclusively defined", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "freq", "help": "An offset string, determining the frequency, the timeseries to flag is supposed to be sampled at. The window is inclusively defined", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "average_window", "argument": "average_window", "type": "text", "label": "See condition (2) of the description given in the Notes", "help": "Window is inclusively defined, defaults to 1.5 times the size of `raise_window`", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "raise_factor", "argument": "raise_factor", "type": "float", "label": "See condition (2)", "help": "See condition (2)", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "slope", "argument": "slope", "type": "float", "label": "See condition (3)", "help": "See condition (3)", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "weight", "argument": "weight", "type": "float", "label": "See condition (3)", "help": "See condition (3)", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.8", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagRange", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "min", "argument": "min", "type": "float", "label": "Lower bound for valid data", "help": "Lower bound for valid data", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "-inf", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "max", "argument": "max", "type": "float", "label": "Upper bound for valid data", "help": "Upper bound for valid data", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "inf", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagUniLOF", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "Number of periods to be included into the LOF calculation", "help": "Defaults to `20`, which is a value found to be suitable in the literature.  * `n` determines the  locality  of an observation (its `n` nearest neighbors) and sets the upper limit to the number of values in an outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n`/2 may not be detected reliably. * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outlier points. Higher values greatly increase numerical costs", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "20", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "thresh_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "auto", "inputs": [{"model_class": "HiddenToolParameter", "name": "thresh", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "auto"}]}, {"model_class": "ConditionalWhen", "value": "float", "inputs": [{"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "The threshold for flagging the calculated LOF (float value)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.5", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "thresh", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "thresh_select_type", "argument": null, "type": "select", "label": "The threshold for flagging the calculated LOF Mode", "help": "A LOF of around ``1`` is considered normal and most likely corresponds to inlier points. This parameter is considered the main calibration parameter of the algorithm.  * The threshing defaults to ``1.5``, wich is the default value found to be suitable in the literature. * ``'auto'`` enables flagging the scores with a modified 3-sigma rule, resulting in a thresh around ``4``, which usually greatly mitigates overflagging compared to the literature recommendation, but often is too high. * sensitive range for the parameter may be ``[1,15]``, assuming default settings for the other parameters", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatic ('auto')", "auto", false], ["Specific Value (float)", "float", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "algorithm", "argument": "algorithm", "type": "select", "label": "algorithm", "help": "Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["ball_tree", "ball_tree", false], ["kd_tree", "kd_tree", false], ["brute", "brute", false], ["auto", "auto", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "p", "argument": "p", "type": "integer", "label": "p", "help": "Degree of the metric ( Minkowski ), according to which distance to neighbors is determined. Most important values are:  * ``1`` - Manhatten Metric * ``2`` - Euclidian Metric", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "density_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "auto", "inputs": [{"model_class": "HiddenToolParameter", "name": "density", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "auto"}]}, {"model_class": "ConditionalWhen", "value": "float", "inputs": [{"model_class": "FloatToolParameter", "name": "density", "argument": "density", "type": "float", "label": "How to calculate the temporal distance/density for the variable to flag (float value)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "density", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "density_select_type", "argument": null, "type": "select", "label": "How to calculate the temporal distance/density for the variable to flag Mode", "help": "* ``'auto'`` - introduces linear density with an increment equal to the median of the absolute diff of the variable to flag. * ``float`` - introduces linear density with an increment equal to `density`", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatic ('auto')", "auto", false], ["Specific Value (float)", "float", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "fill_na", "argument": "fill_na", "type": "boolean", "label": "If True, NaNs in the data are filled with a linear interpolation", "help": "If True, NaNs in the data are filled with a linear interpolation", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "fill_na", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "slope_correct", "argument": "slope_correct", "type": "boolean", "label": "slope_correct", "help": "if True, a correction is applied, that removes outlier cluster that actually just seem to be steep slopes", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "slope_correct", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "min_offset", "argument": "min_offset", "type": "float", "label": "min_offset", "help": "If set, only those outlier cluster will be flagged, that are preceeded and succeeeded by sufficiently large value  jumps . Defaults to estimating the sufficient value jumps from the median over the absolute step sizes between data points", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagZScore", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "method", "help": "Which method to use for ZScoring:  * ` standard `: standard Zscoring, using *mean* for the expectation and *standard deviation (std)* as scaling factor * ` modified `: modified Zscoring, using *median* as the expectation and *median absolute deviation (MAD)* as the scaling Factor  See notes section for detailed scoring formula", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["standard", "standard", false], ["modified", "modified", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "window_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "IntegerToolParameter", "name": "window", "argument": "window", "type": "integer", "label": "Size of the window (as number)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "timedelta", "inputs": [{"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the window (as timedelta string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "window", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "window_select_type", "argument": null, "type": "select", "label": "Size of the window Input Mode", "help": "Either determined via an offset string, denoting the windows temporal extension or by an integer, denoting the windows number of periods. ``NaN`` also count as periods. If ``None`` is passed, all data points share the same scoring window, which than equals the whole data", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Number", "number", false], ["Timedelta", "timedelta", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "FloatToolParameter", "name": "thresh", "argument": "thresh", "type": "float", "label": "thresh", "help": "Cutoff level for the Zscores, above which associated points are marked as outliers", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "3.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_residuals", "argument": "min_residuals", "type": "integer", "label": "Minimum residual value points must have to be considered outliers", "help": "Minimum residual value points must have to be considered outliers", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of valid meassurements in a scoring window, to consider the resulting score valid", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "center", "argument": "center", "type": "boolean", "label": "Weather or not to center the target value in the scoring window", "help": "If ``False``, the target value is the last value in the window", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "center", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "axis", "argument": "axis", "type": "integer", "label": "axis", "help": "Along which axis to calculate the scoring statistics:  * `0` (default) - calculate statistics along time axis * `1` - calculate statistics over multiple variables  See Notes section for a visual clarification of the workings of `axis` and `window`", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "flagByGrubbs", "options": [["flagByGrubbs: Flag outliers using the Grubbs algorithm", "flagByGrubbs", false], ["flagByStray: Flag outliers in 1-dimensional (score) data using the STRAY Algorithm", "flagByStray", false], ["flagLOF: Flag values where the Local Outlier Factor (LOF) exceeds cutoff", "flagLOF", false], ["flagMAD: Flag outiers using the modified Z-score outlier detection method", "flagMAD", false], ["flagMVScores: The algorithm implements a 3-step outlier detection procedure for", "flagMVScores", false], ["flagOffset: A basic outlier test that works on regularly and irregularly sampled data", "flagOffset", false], ["flagRaise: The function flags raises and drops in value courses, that exceed a certain threshold within a certain timespan", "flagRaise", false], ["flagRange: Function flags values exceeding the closed", "flagRange", false], ["flagUniLOF: Flag  univariate  Local Outlier Factor (LOF) exceeding cutoff", "flagUniLOF", false], ["flagZScore: Flag data where its (rolling) Zscore exceeds a threshold", "flagZScore", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "pattern", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "flagPatternByDTW", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "reference", "argument": "reference", "type": "text", "label": "The name in `data` which holds the pattern", "help": "The pattern must not have NaNs, have a datetime index and must not be empty", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "max_distance", "argument": "max_distance", "type": "float", "label": "max_distance", "help": "Maximum dtw-distance between chunk and pattern, if the distance is lower than ``max_distance`` the data gets flagged. With default, ``0.0``, only exact matches are flagged", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "normalize", "argument": "normalize", "type": "boolean", "label": "If `False`, return unmodified distances", "help": "If `True`, normalize distances by the number of observations of the reference. This helps to make it easier to find a good cutoff threshold for further processing. The distances then refer to the mean distance per datapoint, expressed in the datas units", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "normalize", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "plot", "argument": "plot", "type": "boolean", "label": "plot", "help": "Show a calibration plot, which can be quite helpful to find the right threshold for `max_distance`. It works best with `normalize=True`. Do not use in automatic setups / pipelines. The plot show three lines:  - data: the data the function was called on - distances: the calculated distances by the algorithm - indicator: have to distinct levels: `0` and the value of `max_distance`. If `max_distance` is `0.0` it defaults to `1`. Everywhere where the indicator is not `0` the data will be flagged", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "plot", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "flag", "argument": "flag", "type": "float", "label": "Any, optional The flag value the function uses to mark observations", "help": "Defaults to the ``BAD`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "flagPatternByDTW", "options": [["flagPatternByDTW: Pattern Recognition via Dynamic Time Warping", "flagPatternByDTW", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "resampling", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "concatFlags", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "method", "help": "Method to project the flags of `field` to the flags to `target`:  * ``'auto'``: invert the last alignment/resampling operation (that is not already inverted) * ``'nagg'``: project a flag of `field` to all timestamps of `target` within the range +/- `freq`/2. * ``'bagg'``: project a flag of `field` to all preceeding timestamps of `target` within the range `freq` * ``'fagg'``: project a flag of `field` to all succeeding timestamps of `target` within the range `freq` * ``'interpolation'`` - project a flag of `field` to all timestamps of `target` within the range +/- `freq` * ``'sshift'`` - same as interpolation * ``'nshift'`` - project a flag of `field` to the neaerest timestamps in `target` within the range +/- `freq`/2 * ``'bshift'`` - project a flag of `field` to nearest preceeding timestamps in `target` * ``'nshift'`` - project a flag of `field` to nearest succeeding timestamps in `target` * ``'match'`` - project a flag of `field` to all identical timestamps `target`", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["fagg", "fagg", false], ["bagg", "bagg", false], ["nagg", "nagg", false], ["fshift", "fshift", false], ["bshift", "bshift", false], ["nshift", "nshift", false], ["sshift", "sshift", false], ["match", "match", false], ["auto", "auto", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "invert", "argument": "invert", "type": "boolean", "label": "If True, not the actual method is applied, but its inversion-method", "help": "If True, not the actual method is applied, but its inversion-method", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "invert", "falsevalue": ""}, {"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "Projection range", "help": "If ``None`` the sampling frequency of `field` is used", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "drop", "argument": "drop", "type": "boolean", "label": "Remove `field` if ``True``", "help": "Remove `field` if ``True``", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "drop", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "squeeze", "argument": "squeeze", "type": "boolean", "label": "squeeze", "help": "Squeeze the history into a single column if ``True``, function specific flag information is lost", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "squeeze", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "override", "argument": "override", "type": "boolean", "label": "Overwrite existing flags if ``True``", "help": "Overwrite existing flags if ``True``", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "override", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "reindex", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "index", "argument": "index", "type": "text", "label": "Determines the new index", "help": "* If an `offset` string: new index will range from start to end of the original index of `field`, exhibting a uniform sampling rate of `idx` * If a `str` that matches a field present in the `SaQC` object, that fields index will be used as new index of `field` * If an `pd.index` object is passed, that will be the new index of `field`", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "method", "help": "Determines which of the origins indexes periods to comprise into the calculation of a new flag and a new data value at any period of the new index.  * Aggregations Reindexer. Aggregations are data and flags independent, (pure) index selection methods: * `'bagg'`/`'fagg'`:  backwards/forwards aggregation . Any new index period gets assigned an aggregation of the values at periods in the original index, that lie between itself and its successor/predecessor. * `'nagg'`:  nearest aggregation : Any new index period gets assigned an aggregation of the values at periods in the original index between its direcet predecessor and successor, it is the nearest neighbor to. * Rolling reindexer. Rolling reindexers are equal to aggregations, when projecting between regular and irregular sampling grids forth and back. But due to there simple rolling window construction, they are easier to comprehend, predict and parametrize. On the downside, they are much more expensive computationally and Also, periods can get included in the aggregation to multpiple target periods, (when rolling windows overlap). * `'broll'`/`'froll'`: Any new index period gets assigned an aggregation of all the values at periods of the original index, that fall into a directly preceeding/succeeding window of size `reindex_window`. * Shifts. Shifting methods are shortcuts for aggregation reindex methods, combined with selecting 'last' or 'first' as the `data_aggregation` method. Therefor, both, the `flags_aggregation` and the `data_aggregation` are ignored when using a `shift` reindexer. Also, periods where the data evaluates to `NaN` are dropped before shift index selection. * `'bshift'`/`fshift`:  backwards/forwards shift . Any new index period gets assigned the first/last valid (not a data NaN) value it succeeds/preceeds * `'nshift'`:  nearest shift : Any new index period gets assigned the value of its closest neighbor in the original index. * Pillar point Mappings. Index selection method designed to select indices suitable for linearly interpolating index values from surrounding pillar points in the original index, or inverting such a selection. Periods where the data evaluates to `NaN`, are dropped from consideration. * `'mshift'`:  Merge  predecessors and successors. Any new index period gets assigned an aggregation/interpolation comprising the last and the next valid period in the original index. * `'sshift'`:  Split -map values onto predecessors and successors. Same as `mshift`, but with a correction that prevents missing value flags from being mapped to continuous data chunk bounds. * Inversion of last method: try to select the method, that * `'invert``", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["fagg", "fagg", false], ["bagg", "bagg", false], ["nagg", "nagg", false], ["froll", "froll", false], ["broll", "broll", false], ["nroll", "nroll", false], ["fshift", "fshift", false], ["bshift", "bshift", false], ["nshift", "nshift", false], ["match", "match", false], ["sshift", "sshift", false], ["mshift", "mshift", false], ["invert", "invert", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "tolerance", "argument": "tolerance", "type": "text", "label": "Limiting the distance, values can be shifted or comprised into aggregation", "help": "Limiting the distance, values can be shifted or comprised into aggregation", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "data_aggregation", "argument": "data_aggregation", "type": "text", "label": "data_aggregation", "help": "Function string or custom Function, determining how to aggregate new data values from the values at the periods selected according to the `index_selection_method`. If a scalar value is passed, the new data series will just evaluate to that scalar at any new index", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "flags_aggregation", "argument": "flags_aggregation", "type": "text", "label": "flags_aggregation", "help": "Function string or custom Function, determining how to aggregate new flags values from the values at the periods selected according to the `index_selection_method`. If a scalar value is passed, the new flags series will just evaluate to that scalar at any new index", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "broadcast", "argument": "broadcast", "type": "boolean", "label": "broadcast", "help": "Weather to propagate aggregation result to full reindex window when using aggregation reindexer. (as opposed to only assign to next/previous/closest)", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "broadcast", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "squeeze", "argument": "squeeze", "type": "boolean", "label": "squeeze", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "squeeze", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "override", "argument": "override", "type": "boolean", "label": "override", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "override", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "resample", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "Offset string", "help": "Sampling rate of the target frequency grid", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "Aggregation function", "help": "See notes for performance considerations", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "mean", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "method", "argument": "method", "type": "select", "label": "Specifies which intervals to be aggregated for a certain timestamp", "help": "(preceding, succeeding or  surrounding  interval). See description above for more details", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["fagg", "fagg", false], ["bagg", "bagg", false], ["nagg", "nagg", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "maxna", "argument": "maxna", "type": "integer", "label": "Maximum number of allowed ``NaN``s in a resampling interval", "help": "If exceeded, the aggregation of the interval evaluates to ``NaN``", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxna_group", "argument": "maxna_group", "type": "integer", "label": "Same as `maxna` but for consecutive NaNs", "help": "Same as `maxna` but for consecutive NaNs", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "squeeze", "argument": "squeeze", "type": "boolean", "label": "squeeze", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "squeeze", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "concatFlags", "options": [["concatFlags: Project flags/history of `field` to `target` and adjust to the frequeny grid", "concatFlags", false], ["reindex: Change a variables index", "reindex", false], ["resample: Resample data points and flags to a regular frequency", "resample", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "residuals", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "calculatePolynomialResiduals", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "The size of the window you want to use for fitting", "help": "If an integer is passed, the size refers to the number of periods for every fitting window. If an offset string is passed, the size refers to the total temporal extension. The window will be centered around the vaule-to-be-fitted. For regularly sampled timeseries the period number will be casted down to an odd number if even", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "order", "argument": "order", "type": "integer", "label": "The degree of the polynomial used for fitting", "help": "The degree of the polynomial used for fitting", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "The minimum number of periods, that has to be available in every values fitting surrounding for the polynomial fit to be performed. If there are not enough values, np.nan gets assigned. Default (0) results in fitting regardless of the number of values present (results in overfitting for too sparse intervals). To automatically set the minimum number of periods to the number of values in an offset defined window size, pass np.nan", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "calculateRollingResiduals", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "The size of the window you want to roll with", "help": "If an integer is passed, the size refers to the number of periods for every fitting window. If an offset string is passed, the size refers to the total temporal extension. For regularly sampled timeseries, the period number will be casted down to an odd number if ``center=True``", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "default mean Function to roll with", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "mean", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "The minimum number of periods to get a valid value", "help": "The minimum number of periods to get a valid value", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "center", "argument": "center", "type": "boolean", "label": "If True, center the rolling window", "help": "If True, center the rolling window", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "center", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "calculatePolynomialResiduals", "options": [["calculatePolynomialResiduals: Fits a polynomial model to the data and calculate the residuals", "calculatePolynomialResiduals", false], ["calculateRollingResiduals: Calculate the diff of a rolling-window function and the data", "calculateRollingResiduals", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "rolling", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "rolling", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "The size of the window you want to roll with", "help": "If an integer is passed, the size refers to the number of periods for every fitting window. If an offset string is passed, the size refers to the total temporal extension. For regularly sampled timeseries, the period number will be casted down to an odd number if ``center=True``", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "default mean Function to roll with", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "mean", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "The minimum number of periods to get a valid value", "help": "The minimum number of periods to get a valid value", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "center", "argument": "center", "type": "boolean", "label": "If True, center the rolling window", "help": "If True, center the rolling window", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "center", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "rolling", "options": [["rolling: Calculate a rolling-window function on the data", "rolling", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "scores", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "assignKNNScore", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "n", "help": ": The number of nearest neighbors to which the distance is comprised in every datapoints scoring calculation", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "func", "help": "default sum A function that assigns a score to every one dimensional array, containing the distances to every datapoints `n` nearest neighbors", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "sum", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "freq_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "FloatToolParameter", "name": "freq", "argument": "freq", "type": "float", "label": "freq (Frequency as Value (float))", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "inf", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "offset", "inputs": [{"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "freq (Frequency as Offset string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "freq", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "freq_select_type", "argument": null, "type": "select", "label": "freq Input Mode", "help": "Determines the segmentation of the data into partitions, the kNN algorithm is applied onto individually.  * ``np.inf``: Apply Scoring on whole data set at once * ``x``   0 : Apply scoring on successive data chunks of periods length ``x`` * Offset String : Apply scoring on successive partitions of temporal extension matching the passed offset string", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Frequency as Value (float)", "number", false], ["Frequency as Offset string", "offset", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "The minimum number of periods that have to be present in a window for the kNN scoring to be applied. If the number of periods present is below `min_periods`, the score for the datapoints in that window will be np.nan", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "algorithm", "argument": "algorithm", "type": "select", "label": "The search algorithm to find each datapoints k nearest neighbors", "help": "The keyword just gets passed on to the underlying sklearn method. See reference [1] for more information on the algorithm", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["ball_tree", "ball_tree", false], ["kd_tree", "kd_tree", false], ["brute", "brute", false], ["auto", "auto", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "metric", "argument": "metric", "type": "text", "label": "The metric the distances to any datapoints neighbors is computed with", "help": "The default of `metric` together with the default of `p` result in the euclidian to be applied. The keyword just gets passed on to the underlying sklearn method. See reference [1] for more information on the algorithm", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "minkowski", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "p", "argument": "p", "type": "integer", "label": "p", "help": ": The grade of the metrice specified by parameter `metric`. The keyword just gets passed on to the underlying sklearn method. See reference [1] for more information on the algorithm", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "assignLOF", "inputs": [{"model_class": "Repeat", "name": "field_repeat", "type": "repeat", "title": "Field(s)", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Name for field", "help": "Name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "Number of periods to be included into the LOF calculation", "help": "Defaults to `20`, which is a value found to be suitable in the literature", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "20", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "freq_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "FloatToolParameter", "name": "freq", "argument": "freq", "type": "float", "label": "freq (Frequency as Value (float))", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "inf", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "offset", "inputs": [{"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "freq (Frequency as Offset string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "freq", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "freq_select_type", "argument": null, "type": "select", "label": "freq Input Mode", "help": "Determines the segmentation of the data into partitions, the kNN algorithm is applied onto individually", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Frequency as Value (float)", "number", false], ["Frequency as Offset string", "offset", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "algorithm", "argument": "algorithm", "type": "select", "label": "algorithm", "help": "Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["ball_tree", "ball_tree", false], ["kd_tree", "kd_tree", false], ["brute", "brute", false], ["auto", "auto", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "p", "argument": "p", "type": "integer", "label": "p", "help": "Degree of the metric ( Minkowski ), according to wich distance to neighbors is determined. Most important values are:  * `1` - Manhatten Metric * `2` - Euclidian Metric", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "assignUniLOF", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "n", "argument": "n", "type": "integer", "label": "Number of periods to be included into the LOF calculation", "help": "Defaults to `20`, which is a value found to be suitable in the literature.  * `n` determines the  locality  of an observation (its `n` nearest neighbors) and sets the upper limit of values of an outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n/2` may not be detected reliably. * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outliers points. Higher values greatly increase numerical costs", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "20", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "algorithm", "argument": "algorithm", "type": "select", "label": "algorithm", "help": "Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["ball_tree", "ball_tree", false], ["kd_tree", "kd_tree", false], ["brute", "brute", false], ["auto", "auto", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "IntegerToolParameter", "name": "p", "argument": "p", "type": "integer", "label": "p", "help": "Degree of the metric ( Minkowski ), according to wich distance to neighbors is determined. Most important values are:  * `1` - Manhatten Metric * `2` - Euclidian Metric", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "density_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "auto", "inputs": [{"model_class": "HiddenToolParameter", "name": "density", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "auto"}]}, {"model_class": "ConditionalWhen", "value": "float", "inputs": [{"model_class": "FloatToolParameter", "name": "density", "argument": "density", "type": "float", "label": "How to calculate the temporal distance/density for the variable-to-be-flagged (float value)", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "density", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "density_select_type", "argument": null, "type": "select", "label": "How to calculate the temporal distance/density for the variable-to-be-flagged Mode", "help": "* float - introduces linear density with an increment equal to `density` * Callable - calculates the density by applying the function passed onto the variable to be flagged (passed as Series)", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "auto", "options": [["Automatic ('auto')", "auto", false], ["Specific Value (float)", "float", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "fill_na", "argument": "fill_na", "type": "boolean", "label": "If True, NaNs in the data are filled with a linear interpolation", "help": "If True, NaNs in the data are filled with a linear interpolation", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "fill_na", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "assignZScore", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "window", "argument": "window", "type": "text", "label": "Size of the window", "help": "can be determined as: * Offset String, denoting the windows temporal extension * Integer, denoting the windows number of periods. * `None` (default), All data points share the same scoring window, which than equals the whole data", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "norm_func", "argument": "norm_func", "type": "text", "label": "norm_func", "help": "default mean Function to calculate the scaling for every window", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "std", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "model_func", "argument": "model_func", "type": "text", "label": "model_func", "help": "default std Function to calculate the center moment in every window", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "mean", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "center", "argument": "center", "type": "boolean", "label": "Weather or not to center the target value in the scoring window", "help": "If `False`, the target value is the last value in the window", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "center", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "min_periods", "argument": "min_periods", "type": "integer", "label": "min_periods", "help": "Minimum number of valid meassurements in a scoring window, to consider the resulting score valid", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "assignKNNScore", "options": [["assignKNNScore: Score datapoints by an aggregation of the distances to their `k` nearest neighbors", "assignKNNScore", false], ["assignLOF: Assign Local Outlier Factor (LOF)", "assignLOF", false], ["assignUniLOF: Assign  univariate  Local Outlier Factor (LOF)", "assignUniLOF", false], ["assignZScore: Calculate (rolling) Zscores", "assignZScore", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "tools", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "copyField", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "target", "argument": "target", "type": "text", "label": "Target", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "overwrite", "argument": "overwrite", "type": "boolean", "label": "overwrite", "help": "overwrite target, if already existant", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "overwrite", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "dropField", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "flagByClick", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "max_gap", "argument": "max_gap", "type": "text", "label": "max_gap", "help": "If ``None``, all data points will be connected, resulting in long linear lines, in case of large data gaps. ``NaN`` values will be removed before plotting. If an offset string is passed, only points that have a distance below ``max_gap`` are connected via the plotting line", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "gui_mode", "argument": "gui_mode", "type": "select", "label": "gui_mode", "help": "* `` GUI `` (default), spawns TK based pop-up GUI, enabling scrolling and binding for subplots * `` overlay ``, spawns matplotlib based pop-up GUI. May be less conflicting, but does not support scrolling or binding", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "options": [["GUI", "GUI", false], ["overlay", "overlay", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "FloatToolParameter", "name": "dfilter", "argument": "dfilter", "type": "float", "label": "dfilter", "help": "Any, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "255.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "plot", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "path", "argument": "path", "type": "text", "label": "path", "help": "If ``None`` is passed, interactive mode is entered; plots are shown immediatly and a user need to close them manually before execution continues. If a filepath is passed instead, store-mode is entered and the plot is stored unter the passed location", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "max_gap", "argument": "max_gap", "type": "text", "label": "max_gap", "help": "If ``None``, all data points will be connected, resulting in long linear lines, in case of large data gaps. ``NaN`` values will be removed before plotting. If an offset string is passed, only points that have a distance below ``max_gap`` are connected via the plotting line", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "mode", "argument": "mode", "type": "text", "label": "mode", "help": "How to process multiple variables to be plotted:  * ` oneplot ` : plot all variables with their flags in one axis (default) * ` subplots ` : generate subplot grid where each axis contains one variable plot with associated flags * ` biplot ` : plotting first and second variable in field against each other in a scatter plot  (point cloud)", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "oneplot", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "history_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "valid", "inputs": [{"model_class": "HiddenToolParameter", "name": "history", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "valid"}]}, {"model_class": "ConditionalWhen", "value": "complete", "inputs": [{"model_class": "HiddenToolParameter", "name": "history", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "complete"}]}, {"model_class": "ConditionalWhen", "value": "list", "inputs": [{"model_class": "TextToolParameter", "name": "history", "argument": "history", "type": "text", "label": "Discriminate the plotted flags with respect to the tests they originate from (comma-separated)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "history", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "history_select_type", "argument": null, "type": "select", "label": "Discriminate the plotted flags with respect to the tests they originate from Mode", "help": "* `` valid ``: Only plot flags, that are not overwritten by subsequent tests. Only list tests in the legend, that actually contributed flags to the overall result. * ``None``: Just plot the resulting flags for one variable, without any historical and/or meta information. * list of strings: List of tests. Plot flags from the given tests, only. * ``complete`` (not recommended, deprecated): Plot all the flags set by any test, independently from them being removed or modified by subsequent modifications. (this means: plotted flags do not necessarily match with flags ultimately assigned to the data)", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "valid", "options": [["Valid", "valid", false], ["Complete", "complete", false], ["Custom List", "list", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "TextToolParameter", "name": "xscope", "argument": "xscope", "type": "text", "label": "Determine a chunk of the data to be plotted", "help": "``xscope`` can be anything, that is a valid argument to the ``pandas.Series.__getitem__`` method", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "yscope", "argument": "yscope", "type": "text", "label": "yscope", "help": "Either a tuple of 2 scalars that determines all plots' y-view limits, or a list of those tuples, determining the different variables y-view limits (must match number of variables) or a dictionary with variables as keys and the y-view tuple as values", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "ax", "argument": "ax", "type": "text", "label": "ax", "help": "If not ``None``, plot into the given ``matplotlib.Axes`` instance, instead of a newly created ``matplotlib.Figure``. This option offers a possibility to integrate ``SaQC`` plots into custom figure layouts", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "dfilter", "argument": "dfilter", "type": "float", "label": "dfilter", "help": "Any, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "inf", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "renameField", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "new_name", "argument": "new_name", "type": "text", "label": "String, field is to be replaced with", "help": "String, field is to be replaced with", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "selectTime", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "mode", "argument": "mode", "type": "select", "label": "The masking mode", "help": "-  periodic : parameters  period_start ,  end  are evaluated to generate a periodical mask -  mask_var : data[mask_var] is expected to be a boolean valued timeseries and is used as mask", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "periodic", "options": [["periodic", "periodic", false], ["selection_field", "selection_field", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "selection_field", "argument": "selection_field", "type": "text", "label": "selection_field", "help": "Only effective if mode ==  mask_var  Fieldname of the column, holding the data that is to be used as mask. (must be boolean series) Neither the series` length nor its labels have to match data[field]`s index and length. An inner join of the indices will be calculated and values get masked where the values of the inner join are ``True``", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "start", "argument": "start", "type": "text", "label": "start", "help": "Only effective if mode ==  seasonal  String denoting starting point of every period. Formally, it has to be a truncated instance of  mm-ddTHH:MM:SS . Has to be of same length as `end` parameter. See examples section below for some examples", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "end", "argument": "end", "type": "text", "label": "end", "help": "Only effective if mode ==  periodic  String denoting starting point of every period. Formally, it has to be a truncated instance of  mm-ddTHH:MM:SS . Has to be of same length as `end` parameter. See examples section below for some examples", "help_format": "html", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "closed", "argument": "closed", "type": "boolean", "label": "Wheather or not to include the mask defining bounds to the mask", "help": "Wheather or not to include the mask defining bounds to the mask", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "closed", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "copyField", "options": [["copyField: Make a copy of the data and flags of `field`", "copyField", false], ["dropField: Drops field from the data and flags", "dropField", false], ["flagByClick: Pop up GUI for adding or removing flags by selection of points in the data plot", "flagByClick", false], ["plot: Plot data and flags or store plot to file", "plot", false], ["renameField: Rename field in data and flags", "renameField", false], ["selectTime: Realizes masking within saqc", "selectTime", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "transformation", "inputs": [{"model_class": "Conditional", "name": "method_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "transform", "inputs": [{"model_class": "TextToolParameter", "name": "field", "argument": "field", "type": "text", "label": "Field", "help": "The name of the variable to process.", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "func", "argument": "func", "type": "text", "label": "Transformation function", "help": "Transformation function", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "freq_cond", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "number", "inputs": [{"model_class": "FloatToolParameter", "name": "freq", "argument": "freq", "type": "float", "label": "Size of the data window (Frequency as Value (float))", "help": "", "help_format": "html", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "offset", "inputs": [{"model_class": "TextToolParameter", "name": "freq", "argument": "freq", "type": "text", "label": "Size of the data window (Frequency as Offset string)", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "none", "inputs": [{"model_class": "HiddenToolParameter", "name": "freq", "argument": null, "type": "hidden", "label": "", "help": "", "help_format": "html", "refresh_on_change": false, "optional": false, "hidden": true, "is_dynamic": false, "value": "__none__"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "freq_select_type", "argument": null, "type": "select", "label": "Size of the data window Input Mode", "help": "The transformation is applied on each window individually  * ``None``: Apply transformation on the entire data set at once * ``int`` : Apply transformation on successive data chunks of the given length. Must be grater than 0. * Offset String : Apply transformation on successive data chunks of the given temporal extension", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "number", "options": [["Frequency as Value (float)", "number", false], ["Frequency as Offset string", "offset", false], ["None (use default)", "none", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method_select", "argument": null, "type": "select", "label": "Method", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "transform", "options": [["transform: Transform data by applying a custom function on data chunks of variable size. Existing flags are preserved", "transform", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "module_select", "argument": null, "type": "select", "label": "Select SaQC module", "help": "", "help_format": "html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "breaks", "options": [["breaks: Detecting breaks in data", "breaks", false], ["changepoints: changepoints", "changepoints", false], ["constants: constants", "constants", false], ["curvefit: curvefit", "curvefit", false], ["drift: drift", "drift", false], ["flagtools: flagtools", "flagtools", false], ["generic: generic", "generic", false], ["interpolation: interpolation", "interpolation", false], ["noise: noise", "noise", false], ["outliers: outliers", "outliers", false], ["pattern: pattern", "pattern", false], ["resampling: resampling", "resampling", false], ["residuals: residuals", "residuals", false], ["rolling: rolling", "rolling", false], ["scores: scores", "scores", false], ["tools: tools", "tools", false], ["transformation: transformation", "transformation", false]], "display": null, "multiple": false, "textable": false}}]}], "outputs": [{"model_class": "ToolOutputCollection", "name": "plots", "format": null, "label": "${tool.name} on ${on_string}: Plots (if any generated)", "hidden": false, "output_type": "collection", "default_format": "data", "default_format_source": null, "default_metadata_source": null, "inherit_format": false, "inherit_metadata": false, "structure": {"collection_type": "list", "collection_type_source": null, "collection_type_from_rules": null, "structured_like": null, "discover_datasets": [{"discover_via": "pattern", "format": "png", "visible": true, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "sort_reverse": false, "pattern": "(?P<name>.*)\\.png"}]}}, {"model_class": "ToolOutput", "name": "output", "format": "csv", "label": "${tool.name} on ${on_string}: Processed Data", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": null, "parent": null, "count": 1, "from_work_dir": "output.csv", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "config_out", "format": "txt", "label": "${tool.name} on ${on_string}: Generated SaQC Configuration", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": null, "parent": null, "count": 1, "from_work_dir": "config.csv", "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": []}], "panel_section_id": "statistics", "panel_section_name": "Statistics", "form_style": "regular"}