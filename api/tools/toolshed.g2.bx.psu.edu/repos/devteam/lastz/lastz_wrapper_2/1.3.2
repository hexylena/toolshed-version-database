{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/devteam/lastz/lastz_wrapper_2/1.3.2", "name": "LASTZ", "version": "1.3.2", "description": ": align long sequences", "labels": [], "edam_operations": [], "edam_topics": [], "hidden": "", "is_workflow_compatible": true, "xrefs": [], "tool_shed_repository": {"name": "lastz", "owner": "devteam", "changeset_revision": "e7f19d6a9af8", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "Conditional", "name": "source", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "cached", "inputs": [{"model_class": "SelectToolParameter", "name": "target_2bit", "argument": null, "type": "select", "label": "Using reference genome", "help": "If your genome of interest is not listed, contact the Galaxy team", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": true, "value": "hg19", "options": [["Human (Homo sapiens): hg19", "hg19", false], ["Human (Homo sapiens): hg18", "hg18", false], ["Mouse (Mus musculus): mm10", "mm10", false], ["Mouse (Mus musculus): mm9", "mm9", false], ["Drosophila melanogaster: dm3", "dm3", false], ["White-tailed deer Apr 2017 (Odocoileus virginianus) (GCF_002102435.1, Ovir.te_1.0)", "GCF_002102435.1", false], ["Cat Nov. 2017 (Felis catus, domestic cat): felCat9", "felCat9", false], ["Dog (canFam3)", "canFam3", false], ["Rat Jul. 2014 (RGSC 6.0/rn6) (rn6)", "rn6", false], ["S. cerevisiae Apr. 2011 (SacCer_Apr2011/sacCer3) (sacCer3)", "sacCer3", false], ["Zebrafish Jul. 2010 (Zv9/danRer7) (danRer7)", "danRer7", false], ["Zebrafish Sep. 2014 (GRCz10/danRer10) (danRer10)", "danRer10", false], ["Human Feb. 2009 (GRCh37/hg19) (hg19)", "hg19", false], ["Human Dec. 2013 (GRCh38/hg38) (hg38)", "hg38", false], ["Arabidopsis thaliana (TAIR10)", "TAIR10", false], ["Mouse (Mus musculus): mm9 with ERCC spike-in", "mm9_ERCC", false], ["Mouse (Mus Musculus): mm10 Full", "mm10", false], ["Mouse (Mus Musculus): mm9 Full", "mm9", false], ["Caenorhabditis elegans: ce6", "ce6", false], ["Oikopleura dioica (od01)", "od01", false], ["SARS-CoV-2 isolate Wuhan-Hu-1, complete genome (NC_045512)", "NC_045512.2", false], ["Zebrafish May 2017 (GRCz11/danRer11) (danRer11)", "danRer11", false], ["Influenza A virus (A/seal/Mass/1-SC35M/1980(H7N7))", "h7n7_360722", false], ["bosTau9", "bosTau9", false], ["bosTau8", "bosTau8", false], ["A. mellifera genome (apiMel3, Baylor HGSC Amel_3.0)", "apiMel3", false], ["African Clawed Frog (xenLae9.2)", "xenLae9.2", false], ["Mouse (Mus Musculus): mm39 Full", "mm39", false], ["galGal6", "galGal6", false], ["Human Jan. 2021 isolate CHM13 (T2T Consortium) female", "CHM13_T2T_v1.0", false], ["Rattus norvegicus Nov. 2020 (mRatBN7.2/rn7)", "rn7", false], ["Rock pigeon Dec 2017 (Cliv_2.1/colLiv2)", "colLiv2.1", false], ["Xenopus tropicalis (xenTro9.1)", "xenTro9.1", false], ["Horse Jan. 2018 (EquCab3.0/equCab3)", "equCab3", false], ["Caenorhabditis elegans Feb. 2013 (WBcel235/ce11)", "ce11", false], ["S. lycopersicum (Tomato) Feb 2019 (SL4.0)", "SL4.0", false], ["Human CHM13 2.0 (T2T Consortium) Jan. 2022", "CHM13_T2T_v2.0", false], ["Pig Aug. 2011 (SGSC Sscrofa10.2/susScr3) (susScr3)", "susScr3", false], ["Dog Oct. 2020 (Dog10K_Boxer_Tasha/canFam6) (canFam6)", "canFam6", false], ["Chicken Oct. 2021 (bGalGal1.pat.whiteleghornlayer.GRCg7w_WZ) (GCF_016700215.2)", "GCF_016700215.2", false], ["West African lungfish Jul 2021 (Protopterus annectens, PAN1.0) (GCF_019279795.1)", "GCF_019279795.1", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "history", "inputs": [{"model_class": "DataToolParameter", "name": "target", "argument": null, "type": "data", "label": "Select a reference dataset", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta", "fasta.gz"], "edam": {"edam_formats": ["format_1929", "format_1929"], "edam_data": ["data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "ref_source", "argument": null, "type": "select", "label": "Select TARGET sequnce(s) to align against", "help": "If your TARGET is in history, choose 'from your history' option", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "cached", "options": [["locally cached", "cached", false], ["from your history", "history", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "DataToolParameter", "name": "query", "argument": null, "type": "data", "label": "Select QUERY sequence(s)", "help": "These are the sequences that you are aligning against TARGET", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta", "fastq", "fasta.gz", "fastq.gz", "fastq.bz2"], "edam": {"edam_formats": ["format_1929", "format_1930", "format_1929", "format_1930", "format_1930"], "edam_data": ["data_2044", "data_2044", "data_2044", "data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Section", "name": "where_to_look", "type": "section", "title": "Where to look", "help": null, "expanded": false, "inputs": [{"model_class": "SelectToolParameter", "name": "strand", "argument": "--strand", "type": "select", "label": "which strand to search", "help": "Search both strands or choose plus or minus", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "--strand=both", "options": [["Both", "--strand=both", true], ["Plus", "--strand=plus", false], ["Minus", "--strand=minus", false]], "display": "radio", "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "self", "argument": "--self", "type": "boolean", "label": "Perform a self-alignment: the target sequence is also the query.", "help": "Computation is more efficient than it would be without this option, since only one of each mirror-image pair of alignment blocks is processed (the other, redundant one is skipped during processing, but re-created in the output). Also, the trivial self-alignment block along the main diagonal is omitted from the output. THIS OPTION CANNOT BE USED IF THE TARGET IS COMPRIZED OF MULTIPLE SEQUENCES", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--self", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "nomirror", "argument": "--nomirror", "type": "boolean", "label": "Inhibit the re-creation of mirror-image alignments.", "help": "Output consists of only one copy of each meaningful alignment block in a self-alignment. This option is only applicable when the \u2011\u2011self option is used.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--nomirror", "falsevalue": ""}, {"model_class": "Conditional", "name": "qhsplimit", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "qhsplimit_n", "argument": null, "type": "integer", "label": "Discard queries that have more than N HSPs", "help": "Any queries that exceed this limit are reported as a warning (to stderr), and no alignments are reported. This is useful for mapping reads to a reference genome, when some reads align to too many places in the reference.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "qhsplimit_nowarn", "argument": null, "type": "boolean", "label": " Withhold warnings for queries that exceed the limit set above", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "nowarn", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "qhsplimit_keep", "argument": null, "type": "boolean", "label": "Keep queries that exceed the limit and supress warnings", "help": "For such a query, the first N HSPs found are passed along to downstream processing. Note that the HSPs reported are not the best N HSPs. They are simply the first N found; they very likely have a positional bias.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "keep", "falsevalue": "false"}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "qhsplimit_selector", "argument": "--queryhsplimit", "type": "select", "label": "Set HSP limit", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Yes", "yes", false], ["No", "no", true]], "display": "radio", "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "qhspbest", "argument": null, "type": "integer", "label": "For queries that have more than N HSPs, discard any HSPs that score below the Nth best.", "help": "This is useful for mapping reads to a reference genome, when some reads align to too many places in the reference.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "Conditional", "name": "qdepth", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "qdepth_n", "argument": null, "type": "integer", "label": "Stop processing gapped alignments for a query/strand if its ratio of aligned bases to query length exceeds", "help": "This is a real number that corresponds to a depth of coverage threshold. For example, a value of 5.0 would cause termination once a query/strand has an average of five alignments for every base in the query. The numerator is the number of matches or substitutions (but not gaps); the denominator is the length of the query sequence. The purpose of this option is one of saving time. It is useful for automatically terminating the processing of queries with high repeat content, for which other methods of dealing with repetitive content fail. Moreover, back-end filtering options are not considered. In other words, matches are counted for any alignment that meets the scoring threshold, regardless of whether that alignment would be reported. The justification is that we are trying to abort the processing of queries that have too many bounding alignments in the DP matrix, and back-end filtering occurs later in the process.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "qdepth_keep", "argument": null, "type": "boolean", "label": "Warnings for queries that exceed the limit are witheld", "help": "Note that the alignments reported are not guaranteed to be the highest scoring alignments that would achieve the threshold. They are simply the first alignments found. In other words, the purpose of this option is one of saving time, not one of finding optimal alignments.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "keep", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "qdepth_nowarn", "argument": null, "type": "boolean", "label": "Same as above but any alignments discovered for this query/strand, before it exceeds the threshold, are reported.", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "nowarn", "falsevalue": "false"}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "qdepth_selector", "argument": "--querydepth", "type": "select", "label": "Set ratio of aligned bases to query length", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Yes", "yes", false], ["No", "no", true]], "display": "radio", "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "scoring", "type": "section", "title": "Scoring", "help": null, "expanded": false, "inputs": [{"model_class": "DataToolParameter", "name": "score_file", "argument": "--scores", "type": "data", "label": "Read the substitution scores and gap penalties (and possibly other options) from a scoring file (see help below for file fomat description).", "help": "This option cannot be used in conjunction with \u2011\u2011match or inference.", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["txt"], "edam": {"edam_formats": ["format_2330"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "match", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "match_reward", "argument": null, "type": "integer", "label": "Score value for a match", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "match_penalty", "argument": null, "type": "integer", "label": "Score value for a mismatch", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "match_selector", "argument": "--match", "type": "select", "label": "Set the score values for a match and mismatch", "help": "Note that specifying \u2011\u2011match changes the defaults for some of the other options (e.g. the scoring penalties for gaps, and various extension thresholds), as described in respective sections of LASTZ manual. The regular defaults are chosen for compatibility with BLASTZ, but since BLASTZ doesn't support \u2011\u2011match, LASTZ infers that you are not expecting BLASTZ compatibility for this run, so it is free to use improved defaults. THIS OPTION CANNOT BE USED WITH --scores", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Yes", "yes", false], ["No", "no", true]], "display": "radio", "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "gap", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "gap_open", "argument": null, "type": "integer", "label": "Gap opening penalty", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "gap_extend", "argument": null, "type": "integer", "label": "Gap extension penalty", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "gap_selector", "argument": "--gap", "type": "select", "label": "Set the score penalties for opening and extending a gap", "help": "These are specified as positive values; subtraction is implicitly assumed. Note that the first base in a gap incurs the sum of both penalties. This option is only valid if gapped extension is being performed, and cannot be used in conjunction with inference. These values specified on the command line override any corresponding values from a file provided with \u2011\u2011scores.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Yes", "yes", false], ["No", "no", true]], "display": "radio", "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "ambigN", "argument": "--ambiguous=n", "type": "boolean", "label": "Treat each N in the input sequences as an ambiguous nucleotide", "help": "Substitutions with N are scored as zero, instead of using the fill_score value from the scoring file (which is -100 by default).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--ambiguous=n", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "ambigIUPAC", "argument": "--ambiguous=iupac", "type": "boolean", "label": "Treat each of the IUPAC-IUB ambiguity codes (B, D, H, K, M, R, S, V, W, and Y, as well as N) in the input sequences as a completely ambiguous nucleotide.", "help": "Substitutions with these characters are scored as zero, instead of using the fill_score value from the scoring file (which is -100 by default).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": true, "truevalue": "--ambiguous=iupac", "falsevalue": "false"}]}, {"model_class": "Section", "name": "seeding", "type": "section", "title": "Seeding", "help": null, "expanded": false, "inputs": [{"model_class": "Conditional", "name": "seed", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "defaults", "inputs": []}, {"model_class": "ConditionalWhen", "value": "pre_set", "inputs": [{"model_class": "SelectToolParameter", "name": "pre_set_seeds", "argument": "--seed=12of19,--seed=14of22", "type": "select", "label": "Select seed pattern", "help": "Select between 12of19 seed (19-bp word with matches in 12 specific positions: 1110100110010101111) or 14of22 seed (22-bp word with matches in 14 specific positions: 1110101100110010101111). 0 = mismatch, 1 = match", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "--seed=12of19", "options": [["12of19", "--seed=12of19", false], ["14of22", "--seed=14of22", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "len", "inputs": [{"model_class": "IntegerToolParameter", "name": "seed_match", "argument": "--seed=match", "type": "integer", "label": "Set seed length", "help": "Seeds require a N-bp word with matches in all positions", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "half_len", "inputs": [{"model_class": "IntegerToolParameter", "name": "seed_half", "argument": "--seed=half", "type": "integer", "label": "Set seed length", "help": "Seeds requires N-bp word with matches or transitions in all positions", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "pattern", "inputs": [{"model_class": "TextToolParameter", "name": "pattern", "argument": "--seed=PATTERN", "type": "text", "label": "Specify an arbitrary pattern", "help": "Use 1s, 0s, and Ts for seed discovery (e.g., 1110100110010101111 where 1 = match, 0 = mismatch, T = transition)", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "seed_selector", "argument": null, "type": "select", "label": "Select seed type", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "defaults", "options": [["Use defaults", "defaults", true], ["Use pre-set values", "pre_set", false], ["Set length", "len", false], ["Set half length", "half_len", false], ["Set pattern", "pattern", false]], "display": "radio", "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "transitions", "argument": null, "type": "select", "label": "Allow transitions", "help": "In each seed, specify how many match positions can be transition(s) instead", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "--transition", "options": [["One", "--transition", true], ["Two", "--transition=2", false], ["None", "--notransition", false]], "display": "radio", "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "seed_filer", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "filter_tr", "argument": null, "type": "integer", "label": "Number of transitions", "help": "Allowing no more than this number of transversions. If not specified, any number of transversions is allowed (they are not limited)", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "filter_match", "argument": null, "type": "integer", "label": "Number of matches", "help": "Require at least this many exact matches", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "seed_filer_selector", "argument": "--filter", "type": "select", "label": "Filter seeds", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Yes", "yes", false], ["No", "no", true]], "display": "radio", "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "hsp", "type": "section", "title": "HSPs (Gap-free extension)", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "gfextend", "argument": "--gfextend", "type": "boolean", "label": "Perform gap-free extension of seeds to HSPs", "help": "This will take into account other papermeters in this section", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--gfextend", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "nogfextend", "argument": "--nogfextend", "type": "boolean", "label": "Skip the gap-free extension stage", "help": "Instead, pass the seeds along to the next specified stage.It is not recommended to use --nogfextend without also using --nogapped.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--nogfextend", "falsevalue": "false"}, {"model_class": "Conditional", "name": "hsp_method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "none", "inputs": []}, {"model_class": "ConditionalWhen", "value": "match", "inputs": [{"model_class": "IntegerToolParameter", "name": "exact", "argument": "--exact", "type": "integer", "label": "Find HSPs using the exact match extension method with the given length threshold", "help": "This is instead of using the x-drop method", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "mismatch", "inputs": [{"model_class": "IntegerToolParameter", "name": "mismatch_count", "argument": null, "type": "integer", "label": "Specify number of mismatches", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "mismatch_length", "argument": "--mismatch", "type": "integer", "label": "Specify length threshold", "help": "Find HSPs using the mismatch extension method with the given length threshold and allowing specified number of mismatches", "refresh_on_change": false, "min": 1, "max": 50, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "x", "inputs": [{"model_class": "IntegerToolParameter", "name": "xdrop", "argument": "--xdrop", "type": "integer", "label": "Find HSPs using the x-drop extension method with this threshold", "help": "The dropoff setting determines the endpoints of each gap-free segment: the extension of each seed is stopped when its cumulative score drops off by more than the given threshold from the maximum seen so far.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "hspthresh", "argument": "--hspthresh", "type": "integer", "label": "Set the score threshold for the x-drop extension method", "help": "HSPs scoring lower are discarded", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "hspthresh_top", "argument": "--hspthresh=top", "type": "integer", "label": "Set an adaptive score threshold for the x-drop extension method", "help": "HSPs scoring lower are discarded. The score threshold is chosen to limit the number of target sequence bases in HSPs to about this value (or possibly a little higher in case of ties, etc.).", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "hspthresh_top_percent", "argument": "--hspthresh=top%", "type": "integer", "label": "Set an adaptive score threshold for the x-drop extension method", "help": "HSPs scoring lower are discarded. The score threshold is chosen to limit the number of target sequence bases in HSPs to about this perentage value (or possibly a little higher in case of ties, etc.).", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "hsp_method_selector", "argument": null, "type": "select", "label": "Select HSP finding method", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "none", "options": [["None", "none", true], ["Match extension", "match", false], ["Mismatch extension", "mismatch", false], ["X-drop extension", "x", false]], "display": "radio", "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "entropy", "argument": null, "type": "boolean", "label": "Adjust for entropy when qualifying HSPs in the x-drop extension method", "help": "Those that score just slightly above the HSP threshold are adjusted downward according to the entropy of their nucleotides, and any that then fall below the threshold are discarded.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--entropy", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "entropy_report", "argument": null, "type": "boolean", "label": "Adjust for entropy when qualifying HSPs in the x-drop extension method, and report (to stderr) any HSPs that are discarded as a result.", "help": "Reported HSPs are printed to stderr", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--entropy=report", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "noentropy", "argument": null, "type": "boolean", "label": "Don't adjust for entropy when qualifying HSPs", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noentropy", "falsevalue": "false"}]}, {"model_class": "Section", "name": "chaining", "type": "section", "title": "Chaining", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "chain", "argument": "--chain", "type": "boolean", "label": "Perform chaining of HSPs with no penalties", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--chain", "falsevalue": "false"}, {"model_class": "Conditional", "name": "chaning_penalties", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "diag", "argument": null, "type": "integer", "label": "Penalty for diagonal in dynamic programming matrix", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "anti", "argument": null, "type": "integer", "label": "Penalty for anti-diagonal in dynamic programming matrix", "help": "These are specified as positive values; subtraction from the score is implicitly assumed.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "chaning_penalties_selector", "argument": "--chain=", "type": "select", "label": "Perform chaining with penalties", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["Yes", "yes", false], ["No", "no", true]], "display": "radio", "multiple": false, "textable": false}}]}, {"model_class": "Section", "name": "gap_ext", "type": "section", "title": "Gapped extension", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "gapped", "argument": "--gapped", "type": "boolean", "label": "Perform gapped extension of HSPs", "help": "Extension of HSPs (or seeds, if gap-free extension is not performed), is performed after first reducing them to anchor points.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--gapped", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "nogapped", "argument": "--nogapped", "type": "boolean", "label": "Skip the gapped extension stage", "help": "This means that interpolation must also be skipped, since it is not allowed without gapped extension", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--nogapped", "falsevalue": "false"}, {"model_class": "IntegerToolParameter", "name": "ydrop", "argument": "--ydrop", "type": "integer", "label": "Set the threshold for terminating gapped extension", "help": "This restricts the endpoints of each local alignment by limiting the local region around each anchor in which extension is performed. The boundary of this region in the dynamic programming matrix is formed by the points where the cumulative score has dropped off by more than the given threshold from the maximum seen so far.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "noytrim", "argument": "--noytrim", "type": "boolean", "label": "If y-drop extension encounters the end of the sequence, extend the alignment to the end of the sequence rather than trimming it back to the location giving the maximum score", "help": "This is highly recommended when either the target or query sequences are short reads (say, less than 100 bases), to prevent y-drop mismatch shadow.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noytrim", "falsevalue": "false"}, {"model_class": "IntegerToolParameter", "name": "gappedthresh", "argument": "--gappedthresh", "type": "integer", "label": "Set the threshold for gapped extension", "help": "Alignments scoring lower than that value are discarded. When used along with the x-drop method for gap-free extension, this value is generally set at least as high as the HSP threshold. Setting it lower has no effect, since at worst the HSP itself would always qualify (both extension stages use the same scoring matrix).", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "allgappedbounds", "argument": "--allgappedbounds", "type": "boolean", "label": "Revert to handling bounding alignments the way they were handled in BLASTZ.", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--allgappedbounds", "falsevalue": "false"}]}, {"model_class": "Section", "name": "filters", "type": "section", "title": "Filtering", "help": null, "expanded": false, "inputs": [{"model_class": "Section", "name": "identity", "type": "section", "title": "Filter alignments by percent identity", "help": null, "expanded": true, "inputs": [{"model_class": "IntegerToolParameter", "name": "id_min", "argument": null, "type": "integer", "label": "Minimum identity", "help": "", "refresh_on_change": false, "min": 0, "max": 100, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "id_max", "argument": "--filter=identity", "type": "integer", "label": "Maximum identity (optional)", "help": "0 \u2264 min \u2264 max \u2264 100 percent. Identity is the percentage of aligned bases that are matches. Alignment blocks outside the given range are discarded.", "refresh_on_change": false, "min": 0, "max": 100, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "Section", "name": "continuity", "type": "section", "title": "Filter alignments by continuity", "help": null, "expanded": false, "inputs": [{"model_class": "IntegerToolParameter", "name": "cont_min", "argument": null, "type": "integer", "label": "Minimum continuity", "help": "", "refresh_on_change": false, "min": 0, "max": 100, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "cont_max", "argument": "--filter=continuity", "type": "integer", "label": "Maximum continuity (optional)", "help": "0 \u2264 min \u2264 max \u2264 100 percent. Continuity is the percentage of alignment columns that are not gaps. Alignment blocks outside the given range are discarded.", "refresh_on_change": false, "min": 0, "max": 100, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "Section", "name": "coverage", "type": "section", "title": "Filter alignments by coverage", "help": null, "expanded": false, "inputs": [{"model_class": "IntegerToolParameter", "name": "cov_min", "argument": null, "type": "integer", "label": "Minimum coverage", "help": "", "refresh_on_change": false, "min": 0, "max": 100, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "cov_max", "argument": "--filter=coverage", "type": "integer", "label": "Maximum coverage (optional)", "help": " 0 \u2264 min \u2264 max \u2264 100 percent. Coverage is the percentage of the entire target or query sequence (whichever is shorter) that is included in the alignment block. Blocks outside the given range are discarded.", "refresh_on_change": false, "min": 0, "max": 100, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "IntegerToolParameter", "name": "filter_nmatch", "argument": "--filter=nmatch", "type": "integer", "label": "Filter alignments by how many bases match", "help": "Requiring at least this number of matched bases, min > 0. Match count is the number of matched bases in the alignment.", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "filter_nmatch_percent", "argument": "--filter=nmatch%", "type": "integer", "label": "Filter alignments by how many bases match expressed as percentage", "help": "e.g., percentage of the query length.", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "filter_nmismatch", "argument": "--filter=nmismatch:0..", "type": "integer", "label": "Filter alignments by the number of mismatches", "help": "Allow no more than this number of mismatched bases. Mismatch count, or nmismatch, is the number of aligned bases in the alignment that are mismatches (substitutions).", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "filter_ngap", "argument": "--filter=ngap:0..", "type": "integer", "label": "Filter alignments by the number of gaps", "help": "Allow no more than this number of gaps. Gap count, or ngap, is the number of runs of gapped columns in the alignment (each run is counted as one gap).", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "filter_cgap", "argument": "--filter=cgap:0..", "type": "integer", "label": "Filter alignments by the number of gap columns", "help": "Allow no more than this number of gaps. Gap column count, or cgap, is the number of gapped columns in the alignment (each column is counted as one gap).", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "notrivial", "argument": "--notrivial", "type": "boolean", "label": "Do not output a trivial self-alignment block if the target and query sequences are identical", "help": "Note that using \u2011\u2011self automatically enables this option.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--notrivial", "falsevalue": "false"}]}, {"model_class": "Section", "name": "interpolation", "type": "section", "title": "Interpolation", "help": null, "expanded": false, "inputs": [{"model_class": "IntegerToolParameter", "name": "inner", "argument": "--inner", "type": "integer", "label": "Perform additional alignment between the gapped alignment blocks, using (presumably) more sensitive alignment parameters", "help": "This value is used as the threshold for both the gap-free and gapped extension sub-stages; see the discussion of interpolation for more details. This option is only valid if gapped extension is performed.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "Section", "name": "output_format", "type": "section", "title": "Output", "help": null, "expanded": false, "inputs": [{"model_class": "Conditional", "name": "out", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "bam", "inputs": [{"model_class": "SelectToolParameter", "name": "bam_options", "argument": "--format=sam, --format=softsam", "type": "select", "label": "Select a BAM flavor to output", "help": "Lastz actually outputs SAM data but Galaxy converts it into BAM to save space. For alignments that don't reach the end of a query, \u2011\u2011format=sam uses 'hard clipping', while \u2011\u2011format=softsam uses 'soft clipping'. See the section on 'clipped alignment' in the SAM specification for an explanation of what this means. The options \u2011\u2011format=sam- and \u2011\u2011format=softsam- suppress the SAM header lines. This makes them suitable for concatenating output from multiple runs. If you need to specify readgroup information: use AddOrEplaceReadGroups from Picard package", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "sam", "options": [["BAM", "sam", true], ["soft-clipped BAM", "softsam", false], ["BAM without header", "sam-", false], ["soft-clipped BAM without header", "softsam-", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "general_def", "inputs": []}, {"model_class": "ConditionalWhen", "value": "general_full", "inputs": [{"model_class": "SelectToolParameter", "name": "fields", "argument": "--format=general-[:fields]", "type": "select", "label": "Select which fields to include", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": ["score", "name1", "strand1", "size1", "zstart1", "end1", "name2", "strand2", "size2", "zstart2", "end2", "identity", "id%", "coverage", "cov%"], "options": [["score: Score of the alignment block", "score", true], ["name1: Name of the target sequence", "name1", true], ["number1: Number of the target sequence within the target file", "number1", false], ["strand1: Target sequence strand ", "strand1", true], ["size1: Size of the entire target sequence", "size1", true], ["start1: Starting position of the alignment block in the target, origin-one", "start1", false], ["zstart1: Starting position of the alignment block in the target, origin-zero", "zstart1", true], ["end1: Ending position of the alignment block in the target", "end1", true], ["length1: Length of the alignment block in the target (excluding gaps)", "length1", false], ["text1: Aligned characters in the target, including gap characters", "text1", false], ["qalign1: The target quality sequence (if there is one) correpsonding to aligned characters", "qalign1", false], ["nucs1: The entire target sequence", "nucs1", false], ["name2: Name of the query sequence", "name2", true], ["number2: Number of the query sequence within the query file", "number2", false], ["strand2: Query sequence strand", "strand2", true], ["size2: Size of the entire query sequence", "size2", true], ["start2: Starting position of the alignment block in the query, origin-one", "start2", false], ["zstart2: Starting position of the alignment block in the query, origin-one", "zstart2", true], ["end2: Ending position of the alignment block in the query", "end2", true], ["length2: Length of the alignment block in the query (excluding gaps)", "length2", false], ["text2: Aligned characters in the query, including gap characters", "text2", false], ["qalign2: The query quality sequence (if there is one) correpsonding to aligned characters", "qalign2", false], ["nucs2: The entire query sequence", "nucs2", false], ["nmatch: Match count", "nmatch", false], ["nmismatch: Mismatch count", "nmismatch", false], ["ncolumn: Number of columns in the block. This includes matches, mismatches (substitutions), and gaps", "ncolumn", false], ["npair: Number of aligned bases in the block that are matches or mismatches (substitutions)", "npair", false], ["ngap: Gap count, the number of gaps in the block, counting each run of gapped columns as a single gap", "ngap", false], ["cgap: Gap column count, the number of gaps in the block, counting each gapped column as a separate gap", "cgap", false], ["diff: Differences between what would be written for text1 and text2", "diff", false], ["cigar: A CIGAR-like representation of the alignment\u2019s path", "cigar", false], ["cigarx: Same as cigar, but uses a newer syntax that distinguishes matches from substitutions", "cigarx", false], ["identity: Fraction of aligned bases in the block that are matches ", "identity", true], ["idfrac: Fraction of aligned bases in the block that are matches ", "idfrac", false], ["id% Fraction of aligned bases in the block that are matches (as %)", "id%", true], ["blastid%: Fraction of the alignment block that is matches, as would be reported by NCBI BLAST", "blastid%", false], ["continuity: Rate of non-gaps (non-indels) in the alignment block", "continuity", false], ["confrac: Rate of non-gaps (non-indels) in the alignment block (as fraction)", "confrac", false], ["con%: Rate of non-gaps (non-indels) in the alignment block (as %)", "con%", false], ["coverage: Fraction of the entire input sequence (target or query, whichever is shorter) that is covered by the alignment block", "coverage", true], ["covfrac: Fraction of the entire input sequence (target or query, whichever is shorter) that is covered by the alignment block (as fraction)", "covfrac", false], ["cov%: Fraction of the entire input sequence (target or query, whichever is shorter) that is covered by the alignment block (as %)", "cov%", true], ["diagonal: The diagonal of the start of the alignment block in the DP matrix, expressed as an identifying number start1-start2", "diagonal", false], ["shingle: A measurement of the shingle overlap between the target and the query", "shingle", false], ["number: The alignment number, counted as alignments are written to output (1-base)", "number", false], ["znumber: The alignment number, counted as alignments are written to output (0-base)", "znumber", false]], "display": "checkboxes", "multiple": true, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "maf", "inputs": [{"model_class": "SelectToolParameter", "name": "maf_type", "argument": "--format=maf", "type": "select", "label": "Seleat MAF flavor", "help": "MAF is a multiple alignment format developed at UCSC", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "maf", "options": [["MAF", "maf", false], ["MAF with additional stats", "maf+", false], ["MAF without header and comments", "maf-", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "blastn", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "format", "argument": null, "type": "select", "label": "Specify the output format", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "bam", "options": [["BAM --format=sam)", "bam", true], ["General default (--format=general)", "general_def", false], ["Customized general (\u2011\u2011format=general[:fields])", "general_full", false], ["MAF (--format=maf)", "maf", false], ["blastn (--format=BLASTN)", "blastn", false]], "display": "radio", "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "rplot", "argument": "--rdotplot", "type": "boolean", "label": "Create a dotplot representation of alignments?", "help": "The dotplot is only useful if query and target contain exactly one sequence each", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--rdotplot=plot.r", "falsevalue": ""}]}], "outputs": [{"model_class": "ToolOutput", "name": "output", "format": "tabular", "label": "${tool.name} on ${on_string}: mapped reads", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "out_plot", "format": "png", "label": "${tool.name} on ${on_string}: dot plot", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3603", "edam_data": "data_2968", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "mapping", "panel_section_name": "Mapping", "form_style": "regular"}