{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/bgruening/deeptools_compute_matrix/deeptools_compute_matrix/2.4.1.0", "name": "computeMatrix", "version": "2.4.1.0", "description": "prepares data for plotting a heatmap or a profile of given regions", "labels": [], "edam_operations": ["operation_0337", "operation_3435"], "edam_topics": ["topic_3169", "topic_0622"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "deeptools", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "deeptools_compute_matrix", "owner": "bgruening", "changeset_revision": "6f334c8bd52f", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "Repeat", "name": "regionsFiles", "type": "repeat", "title": "Select regions", "help": null, "default": 1, "min": 1, "max": "__Infinity__", "inputs": [{"model_class": "DataToolParameter", "name": "regionsFile", "argument": null, "type": "data", "label": "Regions to plot", "help": "File, in BED format, containing the regions to plot.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bed", "gtf"], "edam": {"edam_formats": ["format_3003", "format_2306"], "edam_data": ["data_3002", "data_1255"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}, {"model_class": "DataToolParameter", "name": "scoreFileName", "argument": null, "type": "data", "label": "Score file", "help": "You can generate a bigWig file from a BAM file using the             bamCoverage tool. (--scoreFileName)", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bigwig"], "edam": {"edam_formats": ["format_3006"], "edam_data": ["data_3002"]}, "multiple": true, "min": null, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "mode", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "scale-regions", "inputs": [{"model_class": "IntegerToolParameter", "name": "regionBodyLength", "argument": "--regionBodyLength", "type": "integer", "label": "Distance in bases to which all regions are going to be fit", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "500", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "regionStartLength", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "beforeRegionStartLength", "argument": "--beforeRegionStartLength", "type": "integer", "label": "Distance upstream of the region start position", "help": "If the regions are genes, this would be the                             distance upstream of the transcription start site.", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "afterRegionStartLength", "argument": "--afterRegionStartLength", "type": "integer", "label": "Distance downstream of the region end position", "help": "If the regions are genes, this would be the                             distance downstream of the transcription end site.", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "unscaled5prime", "argument": "--unscaled5prime", "type": "integer", "label": "Number of bases within the gene body at the 5-prime end to exclude from scaling.", "help": "By default, each region is scaled to a given length (see the --regionBodyLength                              option). In some cases it is useful to look at unscaled signals around region boundaries, so this                              setting specifies the number of unscaled bases on the 5-prime end of each boundary.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "unscaled3prime", "argument": "--unscaled3prime", "type": "integer", "label": "Number of bases within the gene body at the 3-prime end to exclude from scaling.", "help": "As with --unscaled5prime, but for the 3-prime end.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "regionStartLength_select", "argument": null, "type": "select", "label": "Set distance up- and downstream of the given regions", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["yes", "yes", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "reference-point", "inputs": [{"model_class": "SelectToolParameter", "name": "referencePoint", "argument": null, "type": "select", "label": "The reference point for the plotting", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "TSS", "options": [["beginning of region (e.g. TSS)", "TSS", true], ["end of region (e.g. TES)", "TES", false], ["center of region", "center", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "nanAfterEnd", "argument": null, "type": "boolean", "label": "Discard any values after the region end", "help": "This is useful to visualize the region end when not using the                     scale-regions mode and when the reference-point is set to the TSS. (--nanAfterEnd)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--nanAfterEnd", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "beforeRegionStartLength", "argument": null, "type": "integer", "label": "Distance upstream of the start site of the regions defined in the region file", "help": "If the regions are genes, this would be the distance upstream of the transcription start site. (--beforeRegionStartLength)", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "afterRegionStartLength", "argument": null, "type": "integer", "label": "Distance downstream of the end site of the given regions", "help": "If the regions are genes, this would be the distance downstream of the transcription end site. (--afterRegionStartLength)", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "mode_select", "argument": null, "type": "select", "label": "computeMatrix has two main output options", "help": "In the scale-regions mode, all regions in the BED file are                 stretched or shrunken to the same length (in bases) that is indicated                 by the user. Reference-point refers to a position within the BED                 regions (start or end of each region). In the reference-point mode only                 those genomic positions before (upstream) and/or after (downstream)                 the reference point will be considered.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "scale-regions", "options": [["scale-regions", "scale-regions", true], ["reference-point", "reference-point", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "output", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "BooleanToolParameter", "name": "saveMatrix", "argument": "--saveMatrix", "type": "boolean", "label": "Save the matrix of values underlying the heatmap", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}, {"model_class": "BooleanToolParameter", "name": "saveSortedRegions", "argument": null, "type": "boolean", "label": "Save the regions after skipping zeros or min/max threshold values", "help": "The order of the regions in the file follows the sorting order selected. This is useful,                        for example, to generate other heatmaps keeping the sorting of the first heatmap.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "true", "falsevalue": "false"}]}], "test_param": {"model_class": "SelectToolParameter", "name": "showOutputSettings", "argument": null, "type": "select", "label": "Show advanced output settings", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["yes", "yes", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "advancedOpt", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "binSize", "argument": null, "type": "integer", "label": "Length, in bases, of non-overlapping bins used for averaging the score over the regions length", "help": "(--binSize)", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "sortRegions", "argument": "--sortRegions", "type": "select", "label": "Sort regions", "help": "Whether the heatmap should present the regions sorted. The default is to sort in descending order based on the mean value per region.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "keep", "options": [["no ordering", "no", false], ["maintain the same ordering as the input files", "keep", true], ["descending order", "descend", false], ["ascending order", "ascend", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "sortUsing", "argument": "--sortUsing", "type": "select", "label": "Method used for sorting", "help": "For each row the method is computed.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "mean", "options": [["mean", "mean", true], ["median", "median", false], ["min", "min", false], ["max", "max", false], ["sum", "sum", false], ["region length", "region_length", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "averageTypeBins", "argument": null, "type": "select", "label": "Define the type of statistic that should be displayed.", "help": "The value is computed for each bin. (--averageTypeBins)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "mean", "options": [["mean", "mean", true], ["median", "median", false], ["min", "min", false], ["max", "max", false], ["sum", "sum", false], ["std", "std", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "missingDataAsZero", "argument": null, "type": "boolean", "label": "Convert missing values to 0?", "help": "If set to 'yes', missing values (NAs) are converted                      to 0. If you want to use clustering with plotHeatmap                      or plotProfile, set this to 'yes'.                           The default is to ignore missing values, which will be                           depicted as black areas once a heatmap is created.                            (--missingDataAsZero)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--missingDataAsZero", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "skipZeros", "argument": "--skipZeros", "type": "boolean", "label": "Skip zeros", "help": "If set, then zero counts that happen for *all* BAM files given are ignored. This may result in fewer considered regions.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--skipZeros", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "minThreshold", "argument": null, "type": "float", "label": "Minimum threshold", "help": "Any region containing a value that is equal or less than this numeric                     value will be skipped. This is useful to skip, for example, genes where the                     read count is zero for any of the bins which could be the result of                     unmappable areas and can bias the overall results. (--minThreshold)", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "maxThreshold", "argument": null, "type": "float", "label": "Maximum threshold", "help": "Any region containing a value that is equal or higher that this                     numeric value will be skipped. The max threshold is useful to skip those                     few regions with very high read counts (e.g. major satellites) that may                     bias the average values. (--maxThreshold)", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "scale", "argument": null, "type": "float", "label": "Scaling factor", "help": "If set, all values are multiplied by this number. (--scale)", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "metagene", "argument": "--metagene", "type": "boolean", "label": "Use a metagene model", "help": "If set and a BED12 or GTF file or files is used to provide regions, only exons will be used. This is convenient for looking at coverage over mature mRNA transcripts or similar uses where introns should be ignored.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--boolean", "falsevalue": ""}, {"model_class": "TextToolParameter", "name": "transcriptID", "argument": "--transcriptID", "type": "text", "label": "trascript designator", "help": "When a GTF file is used to provide regions, only entries with this value as their feature (column 2) will be processed as transcripts. Default: transcript", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "transcript", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "exonID", "argument": "--exonID", "type": "text", "label": "exon designator", "help": "When a GTF file is used to provide regions, only entries with this value as their feature (column 2) will be processed as exons. CDS would be another common value for this. Default: exon", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "exon", "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "transcript_id_designator", "argument": "--transcript_id_designator", "type": "text", "label": "transcriptID key designator", "help": "Each region has an ID (e.g., ACTB) assigned to it, which for BED files is either column 4 (if it exists)                   or the interval bounds. For GTF files this is instead stored in the last column as a key:value pair (e.g.,                   as 'transcript_id ACTB', for a key of transcript_id and a value of ACTB). In some cases it can be                   convenient to use a different identifier. To do so, set this to the desired key. Default: transcript_id", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "transcript_id", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "blackListFileName", "argument": "--blackListFileName", "type": "data", "label": "Blacklisted regions in BED/GTF format", "help": "One or more files containing regions to exclude from the analysis", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bed", "gtf"], "edam": {"edam_formats": ["format_3003", "format_2306"], "edam_data": ["data_3002", "data_1255"]}, "multiple": true, "min": 0, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "showAdvancedOpt", "argument": null, "type": "select", "label": "Show advanced options", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["yes", "yes", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutput", "name": "outFileName", "format": "deeptools_compute_matrix_archive", "label": "${tool.name} on ${on_string}: Matrix", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_2333", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "outFileSortedRegions", "format": "bed", "label": "${tool.name} on ${on_string}: sorted/filtered regions", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3003", "edam_data": "data_3002", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}, {"model_class": "ToolOutput", "name": "outFileNameMatrix", "format": "tabular", "label": "${tool.name} on ${on_string}: Heatmap values", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "deeptools", "panel_section_name": "deepTools", "form_style": "regular"}