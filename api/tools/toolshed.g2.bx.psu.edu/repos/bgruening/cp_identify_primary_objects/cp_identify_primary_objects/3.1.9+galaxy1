{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/bgruening/cp_identify_primary_objects/cp_identify_primary_objects/3.1.9+galaxy1", "name": "IdentifyPrimaryObjects", "version": "3.1.9+galaxy1", "description": "identify biological objects of interest", "labels": [], "edam_operations": [], "edam_topics": [], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "CellProfiler", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "cp_identify_primary_objects", "owner": "bgruening", "changeset_revision": "b6eec6087271", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "input_pipeline", "argument": null, "type": "data", "label": "Select the input CellProfiler pipeline", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["data"], "edam": {"edam_formats": ["format_1915"], "edam_data": ["data_0006"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "con_advanced", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "TextToolParameter", "name": "input_from_nat", "argument": null, "type": "text", "label": "Enter the name of the input image (from NamesAndTypes)", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "name_to_be_identified", "argument": null, "type": "text", "label": "Enter the name of the primary objects to be identified", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_diameter", "argument": null, "type": "integer", "label": "Typical minimum diameter of objects, in pixel units (Min)", "help": "The min and max diameters are crucial for two reasons: first, the module uses it to calculate certain automatic settings in order to identify your objects of interest properly (see below). Second, when used in conjunction with the 'Discard objects outside the diameter range?' setting below, you can choose to remove objects outside the size range you provide here.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_diameter", "argument": null, "type": "integer", "label": "Typical maximum diameter of objects, in pixel units (Max)", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "40", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "discard_outside_border", "argument": null, "type": "select", "label": "Discard objects outside the diameter range?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "discard_touching_border", "argument": null, "type": "select", "label": "Discard objects touching the border of the image?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": [{"model_class": "TextToolParameter", "name": "input_from_nat", "argument": null, "type": "text", "label": "Enter the name of the input image (from NamesAndTypes)", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "name_to_be_identified", "argument": null, "type": "text", "label": "Enter the name of the primary objects to be identified", "help": "", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "min_diameter", "argument": null, "type": "integer", "label": "Typical minimum diameter of objects, in pixel units (Min)", "help": "The min and max diameters are crucial for two reasons: first, the module uses it to calculate certain automatic settings in order to identify your objects of interest properly (see below). Second, when used in conjunction with the 'Discard objects outside the diameter range?' setting below, you can choose to remove objects outside the size range you provide here.", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "10", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "max_diameter", "argument": null, "type": "integer", "label": "Typical maximum diameter of objects, in pixel units (Max)", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "40", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "discard_outside_border", "argument": null, "type": "select", "label": "Discard objects outside the diameter range?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "discard_touching_border", "argument": null, "type": "select", "label": "Discard objects touching the border of the image?", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "con_threshold_strategy", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Adaptive", "inputs": [{"model_class": "Conditional", "name": "con_threshold_method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Otsu", "inputs": [{"model_class": "Conditional", "name": "con_threshold_class", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Three classes", "inputs": [{"model_class": "SelectToolParameter", "name": "assign_pixel", "argument": null, "type": "select", "label": "Assign pixels in the middle intensity class to the foreground or the background?", "help": "Choose whether you want the pixels with middle grayscale intensities to be assigned to the foreground class or the background class.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Foreground", "options": [["Foreground", "Foreground", false], ["Background", "Background", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Two classes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "threshold_class", "argument": null, "type": "select", "label": "Two-class or three-class thresholding?", "help": "- Two classes: Select this option if the grayscale levels are readily distinguishable into only two classes: foreground (i.e., regions of interest) and background.                            <br> - Three classes: Choose this option if the grayscale levels fall instead into three classes: foreground, background and a middle intensity between the two. You will then be asked whether the middle intensity class should be added to the foreground or background class in order to generate the final two-class output.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Two classes", "options": [["Two classes", "Two classes", false], ["Three classes", "Three classes", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "threshold_method", "argument": null, "type": "select", "label": "Thresholding method", "help": "The intensity threshold affects the decision of whether each pixel will be considered foreground (region(s) of interest) or background.                    A higher threshold value will result in only the brightest regions being identified, whereas a lower threshold value will include dim regions.                    When using the strategy \"Global\", you can have the threshold automatically calculated from a choice of several methods, however, when you choose \"Adaptive\" as the thresholding strategy, your only option is Otsu automatic thresholding.                    The threshold that is used for each image is recorded as a per-image measurement, so if you are surprised by unusual measurements from one of your images, you might check whether the automatically calculated threshold was unusually high or low compared to the other images. See the FlagImage module if you would like to flag an image based on the threshold value.                    <br> - Otsu: This approach calculates the threshold separating the two classes of pixels (foreground and background) by minimizing the variance within the each class.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Otsu", "options": [["Otsu", "Otsu", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "adaptive_window", "argument": null, "type": "integer", "label": "Size of the adaptive window", "help": "Often a good choice is some multiple of the largest expected object size.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_smoothing_scale", "argument": null, "type": "float", "label": "Threshold smoothing scale", "help": "This setting controls the scale used to smooth the input image before the threshold is applied.                        The input image can be optionally smoothed before being thresholded.                        Smoothing can improve the uniformity of the resulting objects, by removing holes and jagged edges caused by noise in the acquired image.                        Smoothing is most likely not appropriate if the input image is binary, if it has already been smoothed or if it is an output of a pixel-based classifier.                        The scale should be approximately the size of the artifacts to be eliminated by smoothing.                        A Gaussian is used with a sigma adjusted so that 1/2 of the Gaussian\u2019s distribution falls within the diameter given by the scale (sigma = scale / 0.674) Use a value of 0 for no smoothing.                        Use a value of 1.3488 for smoothing with a sigma of 1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.3488", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_correction_factor", "argument": null, "type": "float", "label": "Threshold correction factor", "help": "The value entered here adjusts the threshold either upwards or downwards, by multiplying it by this value.                        A value of 1 means no adjustment, 0 to 1 makes the threshold more lenient and greater than 1 makes the threshold more stringent.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_lower", "argument": null, "type": "float", "label": "Lower bound on threshold", "help": "This is helpful as a safety precaution: when the threshold as calculated automatically is clearly outside a reasonable range, the min/max allowable threshold will override the automatic threshold.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_upper", "argument": null, "type": "float", "label": "Upper bound on threshold", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Global", "inputs": [{"model_class": "Conditional", "name": "con_threshold_method", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Otsu", "inputs": [{"model_class": "Conditional", "name": "con_threshold_class", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Three classes", "inputs": [{"model_class": "SelectToolParameter", "name": "assign_pixel", "argument": null, "type": "select", "label": "Assign pixels in the middle intensity class to the foreground or the background?", "help": "Choose whether you want the pixels with middle grayscale intensities to be assigned to the foreground class or the background class.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Foreground", "options": [["Foreground", "Foreground", false], ["Background", "Background", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Two classes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "threshold_class", "argument": null, "type": "select", "label": "Two-class or three-class thresholding?", "help": "- Two classes: Select this option if the grayscale levels are readily distinguishable into only two classes: foreground (i.e., regions of interest) and background.                            <br> - Three classes: Choose this option if the grayscale levels fall instead into three classes: foreground, background and a middle intensity between the two. You will then be asked whether the middle intensity class should be added to the foreground or background class in order to generate the final two-class output.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Two classes", "options": [["Two classes", "Two classes", false], ["Three classes", "Three classes", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "FloatToolParameter", "name": "threshold_smoothing_scale", "argument": null, "type": "float", "label": "Threshold smoothing scale", "help": "This setting controls the scale used to smooth the input image before the threshold is applied.                        The input image can be optionally smoothed before being thresholded.                        Smoothing can improve the uniformity of the resulting objects, by removing holes and jagged edges caused by noise in the acquired image.                        Smoothing is most likely not appropriate if the input image is binary, if it has already been smoothed or if it is an output of a pixel-based classifier.                        The scale should be approximately the size of the artifacts to be eliminated by smoothing.                        A Gaussian is used with a sigma adjusted so that 1/2 of the Gaussian\u2019s distribution falls within the diameter given by the scale (sigma = scale / 0.674) Use a value of 0 for no smoothing.                        Use a value of 1.3488 for smoothing with a sigma of 1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.3488", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_correction_factor", "argument": null, "type": "float", "label": "Threshold correction factor", "help": "The value entered here adjusts the threshold either upwards or downwards, by multiplying it by this value.                        A value of 1 means no adjustment, 0 to 1 makes the threshold more lenient and greater than 1 makes the threshold more stringent.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_lower", "argument": null, "type": "float", "label": "Lower bound on threshold", "help": "This is helpful as a safety precaution: when the threshold as calculated automatically is clearly outside a reasonable range, the min/max allowable threshold will override the automatic threshold.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_upper", "argument": null, "type": "float", "label": "Upper bound on threshold", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Manual", "inputs": [{"model_class": "FloatToolParameter", "name": "manual_threshold", "argument": null, "type": "float", "label": "Enter the value that will act as an absolute threshold for the images", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "RobustBackground", "inputs": [{"model_class": "FloatToolParameter", "name": "lower_outlier_fraction", "argument": null, "type": "float", "label": "Lower outlier fraction", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "upper_outlier_fraction", "argument": null, "type": "float", "label": "Upper outlier fraction", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.05", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "avg_method", "argument": null, "type": "select", "label": "Averaging method", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Mean", "options": [["Mean", "Mean", false], ["Median", "Median", false], ["Mode", "Mode", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "SelectToolParameter", "name": "variance_method", "argument": null, "type": "select", "label": "Variance", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Standard deviation", "options": [["Standard deviation", "Standard deviation", false], ["Median absolute deviation", "Median absolute deviation", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "FloatToolParameter", "name": "no_of_deviations", "argument": null, "type": "float", "label": "# of deviations", "help": "Robust background calculates the variance, multiplies it by the value given by this setting and adds it to the average.                                        Adding several deviations raises the threshold well above the average. Use a larger number to be more stringent about identifying foreground pixels.                                        Use a smaller number to be less stringent. It\u2019s even possible to use a negative number if you want the threshold to be lower than the average (e.g., for images that are densely covered by foreground).", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "2.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_smoothing_scale", "argument": null, "type": "float", "label": "Threshold smoothing scale", "help": "This setting controls the scale used to smooth the input image before the threshold is applied.                        The input image can be optionally smoothed before being thresholded.                        Smoothing can improve the uniformity of the resulting objects, by removing holes and jagged edges caused by noise in the acquired image.                        Smoothing is most likely not appropriate if the input image is binary, if it has already been smoothed or if it is an output of a pixel-based classifier.                        The scale should be approximately the size of the artifacts to be eliminated by smoothing.                        A Gaussian is used with a sigma adjusted so that 1/2 of the Gaussian\u2019s distribution falls within the diameter given by the scale (sigma = scale / 0.674) Use a value of 0 for no smoothing.                        Use a value of 1.3488 for smoothing with a sigma of 1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.3488", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_correction_factor", "argument": null, "type": "float", "label": "Threshold correction factor", "help": "The value entered here adjusts the threshold either upwards or downwards, by multiplying it by this value.                        A value of 1 means no adjustment, 0 to 1 makes the threshold more lenient and greater than 1 makes the threshold more stringent.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_lower", "argument": null, "type": "float", "label": "Lower bound on threshold", "help": "This is helpful as a safety precaution: when the threshold as calculated automatically is clearly outside a reasonable range, the min/max allowable threshold will override the automatic threshold.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_upper", "argument": null, "type": "float", "label": "Upper bound on threshold", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Measurement", "inputs": [{"model_class": "SelectToolParameter", "name": "global_measurement_threshold_cat", "argument": null, "type": "select", "label": "Select the measurement category to threshold with", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "FileName", "options": [["File Name", "FileName", false], ["Frame", "Frame", false], ["Height", "Height", false], ["MD5Digest", "MD5Digest", false], ["Path Name", "PathName", false], ["Scaling", "Scaling", false], ["Series", "Series", false], ["URL", "URL", false], ["Width", "Width", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "global_measurement_threshold_measurement", "argument": null, "type": "text", "label": "Select the measurement to threshold with", "help": "Measurement corresponds to the names in Starting modules.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_correction_factor", "argument": null, "type": "float", "label": "Threshold correction factor", "help": "The value entered here adjusts the threshold either upwards or downwards, by multiplying it by this value.                        A value of 1 means no adjustment, 0 to 1 makes the threshold more lenient and greater than 1 makes the threshold more stringent.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_lower", "argument": null, "type": "float", "label": "Lower bound on threshold", "help": "This is helpful as a safety precaution: when the threshold as calculated automatically is clearly outside a reasonable range, the min/max allowable threshold will override the automatic threshold.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_upper", "argument": null, "type": "float", "label": "Upper bound on threshold", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Minimum cross entropy", "inputs": [{"model_class": "FloatToolParameter", "name": "threshold_smoothing_scale", "argument": null, "type": "float", "label": "Threshold smoothing scale", "help": "This setting controls the scale used to smooth the input image before the threshold is applied.                        The input image can be optionally smoothed before being thresholded.                        Smoothing can improve the uniformity of the resulting objects, by removing holes and jagged edges caused by noise in the acquired image.                        Smoothing is most likely not appropriate if the input image is binary, if it has already been smoothed or if it is an output of a pixel-based classifier.                        The scale should be approximately the size of the artifacts to be eliminated by smoothing.                        A Gaussian is used with a sigma adjusted so that 1/2 of the Gaussian\u2019s distribution falls within the diameter given by the scale (sigma = scale / 0.674) Use a value of 0 for no smoothing.                        Use a value of 1.3488 for smoothing with a sigma of 1.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.3488", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_correction_factor", "argument": null, "type": "float", "label": "Threshold correction factor", "help": "The value entered here adjusts the threshold either upwards or downwards, by multiplying it by this value.                        A value of 1 means no adjustment, 0 to 1 makes the threshold more lenient and greater than 1 makes the threshold more stringent.", "refresh_on_change": false, "min": 0.0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_lower", "argument": null, "type": "float", "label": "Lower bound on threshold", "help": "This is helpful as a safety precaution: when the threshold as calculated automatically is clearly outside a reasonable range, the min/max allowable threshold will override the automatic threshold.", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "threshold_upper", "argument": null, "type": "float", "label": "Upper bound on threshold", "help": "", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "threshold_method", "argument": null, "type": "select", "label": "Thresholding method", "help": "The intensity threshold affects the decision of whether each pixel will be considered foreground (region(s) of interest) or background.                    A higher threshold value will result in only the brightest regions being identified, whereas a lower threshold value will include dim regions.                    When using the strategy \"Global\", you can have the threshold automatically calculated from a choice of several methods, however, when you choose \"Adaptive\" as the thresholding strategy, your only option is Otsu automatic thresholding.                    The threshold that is used for each image is recorded as a per-image measurement, so if you are surprised by unusual measurements from one of your images, you might check whether the automatically calculated threshold was unusually high or low compared to the other images. See the FlagImage module if you would like to flag an image based on the threshold value.                    <br> - Otsu: This approach calculates the threshold separating the two classes of pixels (foreground and background) by minimizing the variance within the each class.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Otsu", "options": [["Manual", "Manual", false], ["Measurement", "Measurement", false], ["Minimum cross entropy", "Minimum cross entropy", false], ["Otsu", "Otsu", true], ["Robust background", "RobustBackground", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "threshold_strategy", "argument": null, "type": "select", "label": "Threshold strategy", "help": "The thresholding strategy determines the type of input that is used to calculate the threshold. These options allow you to calculate a threshold based on the whole image or based on image sub-regions.                                The choices for the threshold strategy are:                                <br> - Global: Calculates a single threshold value based on the unmasked pixels of the input image and use that value to classify pixels above the threshold as foreground and below as background.                                image0 This strategy is fast and robust, especially if the background is relatively uniform (for example, after illumination correction).                                <br> - Adaptive: Calculates a different threshold for each pixel, thus adapting to changes in foreground/background intensities across the image. For each pixel, the threshold is calculated based on the pixels within a given neighborhood (or window) surrounding that pixel.                                image1 This method is slower but can produce better results for non-uniform backgrounds. However, for significant illumination variation, using the CorrectIllumination modules is preferable.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Adaptive", "options": [["Global", "Global", false], ["Adaptive", "Adaptive", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "con_distinguish_clumped_objects", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Shape", "inputs": [{"model_class": "Conditional", "name": "con_dividing_lines", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Shape", "inputs": [{"model_class": "Conditional", "name": "con_smoothing_filter", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "size_smoothing_filter", "argument": null, "type": "integer", "label": "Size of smoothing filter", "help": "If you see too many objects merged that ought to be separated (under-segmentation), this value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                Note that splitting and merging is also affected by your choice of settings for the setting, Automatically calculate minimum allowed distance between local maxima? It is an art to balance these two settings; read the help carefully for both.                                Reducing the texture of objects by increasing the smoothing increases the chance that each real, distinct object has only one peak of intensity but also increases the chance that two distinct objects will be recognized as only one object. Note that increasing the size of the smoothing filter increases the processing time exponentially.                                Enter 0 to prevent any image smoothing in certain cases; for example, for low resolution images with small objects ( < ~5 pixels in diameter).", "refresh_on_change": false, "min": 0, "max": 1, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "smoothing_filter", "argument": null, "type": "select", "label": "Automatically calculate size of smoothing filter for declumping?", "help": "Select 'Yes' to automatically calculate the amount of smoothing applied to the image to assist in declumping. Select \"No\" to manually enter the smoothing filter size.                            This setting, along with the Minimum allowed distance between local maxima setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background.                            Please note that this smoothing setting is applied after thresholding, and is therefore distinct from the threshold smoothing method setting above, which is applied before thresholding.                            The size of the smoothing filter is automatically calculated based on the Typical diameter of objects, in pixel units (Min,Max) setting above. If you see too many objects merged that ought to be separate or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "con_min_distance", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "min_allowed_distance", "argument": null, "type": "integer", "label": "Supress local maxima that are closer than this minimum allowed distance", "help": "Enter a positive integer, in pixel units. If you see too many objects merged that ought to be separated (under-segmentation), the value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                The maxima suppression distance should be set to be roughly equivalent to the radius of the smallest object of interest that you would expect to see in the experiment.                                Any distinct 'objects' that are found but are within two times this distance from each other will be assumed to be actually two lumpy parts of the same object, and they will be merged.                                Note that splitting and merging is also affected by your choice of settings for the setting 'Size of smoothing filter'.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "7", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "min_distance", "argument": null, "type": "select", "label": "Automatically calculate minimum allowed distance between local maxima?", "help": "Select \"Yes\" to automatically calculate the distance between intensity maxima to assist in declumping. Select \"No\" to manually enter the permissible maxima distance.                            This setting, along with the Size of smoothing filter setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background. Local maxima that are closer together than the minimum allowed distance will be suppressed (the local intensity histogram is smoothed to remove the peaks within that distance).                            The distance can be automatically calculated based on the minimum entered for the Typical diameter of objects, in pixel units (Min,Max) setting above, but if you see too many objects merged that ought to be separate, or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "speed_up", "argument": null, "type": "select", "label": "Speed up by using lower-resolution image to find local maxima?", "help": "Select 'Yes' to down-sample the image for declumping. This can be helpful for saving processing time on large images.                        Note that if you have entered a minimum object diameter of 10 or less, checking this box will have no effect.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Intensity", "inputs": [{"model_class": "Conditional", "name": "con_smoothing_filter", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "size_smoothing_filter", "argument": null, "type": "integer", "label": "Size of smoothing filter", "help": "If you see too many objects merged that ought to be separated (under-segmentation), this value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                Note that splitting and merging is also affected by your choice of settings for the setting, Automatically calculate minimum allowed distance between local maxima? It is an art to balance these two settings; read the help carefully for both.                                Reducing the texture of objects by increasing the smoothing increases the chance that each real, distinct object has only one peak of intensity but also increases the chance that two distinct objects will be recognized as only one object. Note that increasing the size of the smoothing filter increases the processing time exponentially.                                Enter 0 to prevent any image smoothing in certain cases; for example, for low resolution images with small objects ( < ~5 pixels in diameter).", "refresh_on_change": false, "min": 0, "max": 1, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "smoothing_filter", "argument": null, "type": "select", "label": "Automatically calculate size of smoothing filter for declumping?", "help": "Select 'Yes' to automatically calculate the amount of smoothing applied to the image to assist in declumping. Select \"No\" to manually enter the smoothing filter size.                            This setting, along with the Minimum allowed distance between local maxima setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background.                            Please note that this smoothing setting is applied after thresholding, and is therefore distinct from the threshold smoothing method setting above, which is applied before thresholding.                            The size of the smoothing filter is automatically calculated based on the Typical diameter of objects, in pixel units (Min,Max) setting above. If you see too many objects merged that ought to be separate or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "con_min_distance", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "min_allowed_distance", "argument": null, "type": "integer", "label": "Supress local maxima that are closer than this minimum allowed distance", "help": "Enter a positive integer, in pixel units. If you see too many objects merged that ought to be separated (under-segmentation), the value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                The maxima suppression distance should be set to be roughly equivalent to the radius of the smallest object of interest that you would expect to see in the experiment.                                Any distinct 'objects' that are found but are within two times this distance from each other will be assumed to be actually two lumpy parts of the same object, and they will be merged.                                Note that splitting and merging is also affected by your choice of settings for the setting 'Size of smoothing filter'.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "7", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "min_distance", "argument": null, "type": "select", "label": "Automatically calculate minimum allowed distance between local maxima?", "help": "Select \"Yes\" to automatically calculate the distance between intensity maxima to assist in declumping. Select \"No\" to manually enter the permissible maxima distance.                            This setting, along with the Size of smoothing filter setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background. Local maxima that are closer together than the minimum allowed distance will be suppressed (the local intensity histogram is smoothed to remove the peaks within that distance).                            The distance can be automatically calculated based on the minimum entered for the Typical diameter of objects, in pixel units (Min,Max) setting above, but if you see too many objects merged that ought to be separate, or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "speed_up", "argument": null, "type": "select", "label": "Speed up by using lower-resolution image to find local maxima?", "help": "Select 'Yes' to down-sample the image for declumping. This can be helpful for saving processing time on large images.                        Note that if you have entered a minimum object diameter of 10 or less, checking this box will have no effect.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Propagate", "inputs": []}, {"model_class": "ConditionalWhen", "value": "None", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "dividing_lines", "argument": null, "type": "select", "label": "Method to draw dividing lines between clumped objects", "help": "This setting allows you to choose the method that is used to draw the line between segmented objects, provided that you have chosen to declump the objects. To decide between these methods, you can run Test mode to see the results of each.                            <br> - Intensity: Works best where the dividing lines between clumped objects are dimmer than the remainder of the objects.                            <br> - Technical description: Using the previously identified local maxima as seeds, this method is a watershed (Vincent and Soille, 1991) on the intensity image.                            <br> - Shape: Dividing lines between clumped objects are based on the shape of the clump. For example, when a clump contains two objects, the dividing line will be placed where indentations occur between the two objects. The intensity patterns in the original image are largely irrelevant: the cells need not be dimmer along the lines between clumped objects. Technical description: Using the previously identified local maxima as seeds, this method is a watershed on the distance-transformed thresholded image.                            <br> - Propagate: This method uses a propagation algorithm instead of a watershed. The image is ignored and the pixels are assigned to the objects by repeatedly adding unassigned pixels to the objects that are immediately adjacent to them. This method is suited in cases such as objects with branching extensions, for instance neurites, where the goal is to trace outward from the cell body along the branch, assigning pixels in the branch along the way. See the help for the IdentifySecondaryObjects module for more details on this method.                            <br> - None: If objects are well separated and bright relative to the background, it may be unnecessary to attempt to separate clumped objects. Using the very fast None option, a simple threshold will be used to identify objects.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Intensity", "options": [["Intensity", "Intensity", false], ["Shape", "Shape", false], ["Propagate", "Propagate", false], ["None", "None", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "Intensity", "inputs": [{"model_class": "Conditional", "name": "con_dividing_lines", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Shape", "inputs": [{"model_class": "Conditional", "name": "con_smoothing_filter", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "size_smoothing_filter", "argument": null, "type": "integer", "label": "Size of smoothing filter", "help": "If you see too many objects merged that ought to be separated (under-segmentation), this value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                Note that splitting and merging is also affected by your choice of settings for the setting, Automatically calculate minimum allowed distance between local maxima? It is an art to balance these two settings; read the help carefully for both.                                Reducing the texture of objects by increasing the smoothing increases the chance that each real, distinct object has only one peak of intensity but also increases the chance that two distinct objects will be recognized as only one object. Note that increasing the size of the smoothing filter increases the processing time exponentially.                                Enter 0 to prevent any image smoothing in certain cases; for example, for low resolution images with small objects ( < ~5 pixels in diameter).", "refresh_on_change": false, "min": 0, "max": 1, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "smoothing_filter", "argument": null, "type": "select", "label": "Automatically calculate size of smoothing filter for declumping?", "help": "Select 'Yes' to automatically calculate the amount of smoothing applied to the image to assist in declumping. Select \"No\" to manually enter the smoothing filter size.                            This setting, along with the Minimum allowed distance between local maxima setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background.                            Please note that this smoothing setting is applied after thresholding, and is therefore distinct from the threshold smoothing method setting above, which is applied before thresholding.                            The size of the smoothing filter is automatically calculated based on the Typical diameter of objects, in pixel units (Min,Max) setting above. If you see too many objects merged that ought to be separate or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "con_min_distance", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "min_allowed_distance", "argument": null, "type": "integer", "label": "Supress local maxima that are closer than this minimum allowed distance", "help": "Enter a positive integer, in pixel units. If you see too many objects merged that ought to be separated (under-segmentation), the value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                The maxima suppression distance should be set to be roughly equivalent to the radius of the smallest object of interest that you would expect to see in the experiment.                                Any distinct 'objects' that are found but are within two times this distance from each other will be assumed to be actually two lumpy parts of the same object, and they will be merged.                                Note that splitting and merging is also affected by your choice of settings for the setting 'Size of smoothing filter'.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "7", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "min_distance", "argument": null, "type": "select", "label": "Automatically calculate minimum allowed distance between local maxima?", "help": "Select \"Yes\" to automatically calculate the distance between intensity maxima to assist in declumping. Select \"No\" to manually enter the permissible maxima distance.                            This setting, along with the Size of smoothing filter setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background. Local maxima that are closer together than the minimum allowed distance will be suppressed (the local intensity histogram is smoothed to remove the peaks within that distance).                            The distance can be automatically calculated based on the minimum entered for the Typical diameter of objects, in pixel units (Min,Max) setting above, but if you see too many objects merged that ought to be separate, or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "speed_up", "argument": null, "type": "select", "label": "Speed up by using lower-resolution image to find local maxima?", "help": "Select 'Yes' to down-sample the image for declumping. This can be helpful for saving processing time on large images.                        Note that if you have entered a minimum object diameter of 10 or less, checking this box will have no effect.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Intensity", "inputs": [{"model_class": "Conditional", "name": "con_smoothing_filter", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "size_smoothing_filter", "argument": null, "type": "integer", "label": "Size of smoothing filter", "help": "If you see too many objects merged that ought to be separated (under-segmentation), this value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                Note that splitting and merging is also affected by your choice of settings for the setting, Automatically calculate minimum allowed distance between local maxima? It is an art to balance these two settings; read the help carefully for both.                                Reducing the texture of objects by increasing the smoothing increases the chance that each real, distinct object has only one peak of intensity but also increases the chance that two distinct objects will be recognized as only one object. Note that increasing the size of the smoothing filter increases the processing time exponentially.                                Enter 0 to prevent any image smoothing in certain cases; for example, for low resolution images with small objects ( < ~5 pixels in diameter).", "refresh_on_change": false, "min": 0, "max": 1, "optional": false, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "smoothing_filter", "argument": null, "type": "select", "label": "Automatically calculate size of smoothing filter for declumping?", "help": "Select 'Yes' to automatically calculate the amount of smoothing applied to the image to assist in declumping. Select \"No\" to manually enter the smoothing filter size.                            This setting, along with the Minimum allowed distance between local maxima setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background.                            Please note that this smoothing setting is applied after thresholding, and is therefore distinct from the threshold smoothing method setting above, which is applied before thresholding.                            The size of the smoothing filter is automatically calculated based on the Typical diameter of objects, in pixel units (Min,Max) setting above. If you see too many objects merged that ought to be separate or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "con_min_distance", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "No", "inputs": [{"model_class": "IntegerToolParameter", "name": "min_allowed_distance", "argument": null, "type": "integer", "label": "Supress local maxima that are closer than this minimum allowed distance", "help": "Enter a positive integer, in pixel units. If you see too many objects merged that ought to be separated (under-segmentation), the value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.                                The maxima suppression distance should be set to be roughly equivalent to the radius of the smallest object of interest that you would expect to see in the experiment.                                Any distinct 'objects' that are found but are within two times this distance from each other will be assumed to be actually two lumpy parts of the same object, and they will be merged.                                Note that splitting and merging is also affected by your choice of settings for the setting 'Size of smoothing filter'.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "7", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Yes", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "min_distance", "argument": null, "type": "select", "label": "Automatically calculate minimum allowed distance between local maxima?", "help": "Select \"Yes\" to automatically calculate the distance between intensity maxima to assist in declumping. Select \"No\" to manually enter the permissible maxima distance.                            This setting, along with the Size of smoothing filter setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background. Local maxima that are closer together than the minimum allowed distance will be suppressed (the local intensity histogram is smoothed to remove the peaks within that distance).                            The distance can be automatically calculated based on the minimum entered for the Typical diameter of objects, in pixel units (Min,Max) setting above, but if you see too many objects merged that ought to be separate, or too many objects split up that ought to be merged, you may want to override the automatically calculated value.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "speed_up", "argument": null, "type": "select", "label": "Speed up by using lower-resolution image to find local maxima?", "help": "Select 'Yes' to down-sample the image for declumping. This can be helpful for saving processing time on large images.                        Note that if you have entered a minimum object diameter of 10 or less, checking this box will have no effect.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "Yes", "options": [["Yes", "Yes", false], ["No", "No", false]], "display": "radio", "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "Propagate", "inputs": []}, {"model_class": "ConditionalWhen", "value": "None", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "dividing_lines", "argument": null, "type": "select", "label": "Method to draw dividing lines between clumped objects", "help": "This setting allows you to choose the method that is used to draw the line between segmented objects, provided that you have chosen to declump the objects. To decide between these methods, you can run Test mode to see the results of each.                            <br> - Intensity: Works best where the dividing lines between clumped objects are dimmer than the remainder of the objects.                            <br> - Technical description: Using the previously identified local maxima as seeds, this method is a watershed (Vincent and Soille, 1991) on the intensity image.                            <br> - Shape: Dividing lines between clumped objects are based on the shape of the clump. For example, when a clump contains two objects, the dividing line will be placed where indentations occur between the two objects. The intensity patterns in the original image are largely irrelevant: the cells need not be dimmer along the lines between clumped objects. Technical description: Using the previously identified local maxima as seeds, this method is a watershed on the distance-transformed thresholded image.                            <br> - Propagate: This method uses a propagation algorithm instead of a watershed. The image is ignored and the pixels are assigned to the objects by repeatedly adding unassigned pixels to the objects that are immediately adjacent to them. This method is suited in cases such as objects with branching extensions, for instance neurites, where the goal is to trace outward from the cell body along the branch, assigning pixels in the branch along the way. See the help for the IdentifySecondaryObjects module for more details on this method.                            <br> - None: If objects are well separated and bright relative to the background, it may be unnecessary to attempt to separate clumped objects. Using the very fast None option, a simple threshold will be used to identify objects.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Intensity", "options": [["Intensity", "Intensity", false], ["Shape", "Shape", false], ["Propagate", "Propagate", false], ["None", "None", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "None", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "distinguish_clumped_objects", "argument": null, "type": "select", "label": "Method to distinguish clumped objects", "help": "This setting allows you to choose the method that is used to distinguish between individual objects that are touching each other (and not properly delineated as two objects by thresholding alone). In other words, this setting allows you to \u201cdeclump\u201d a large, merged object into individual objects of interest. To decide between these methods, you can run Test mode to see the results of each.                                <br> - Intensity: For objects that tend to have only a single peak of brightness (e.g., objects that are brighter towards their interiors and dimmer towards their edges), this option counts each intensity peak as a separate object. The objects can be any shape, so they need not be round and uniform in size as would be required for the Shape option.                                <br> - Shape: For cases when there are definite indentations separating objects. The image is converted to black and white (binary) and the shape determines whether clumped objects will be distinguished. The declumping results of this method are affected by the thresholding method you choose.                                <br> - None: If objects are well separated and bright relative to the background, it may be unnecessary to attempt to separate clumped objects. Using the very fast None option, a simple threshold will be used to identify objects.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Intensity", "options": [["Shape", "Shape", false], ["Intensity", "Intensity", true], ["None", "None", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "fill_hole", "argument": null, "type": "select", "label": "Fill holes in identified objects", "help": "This option controls how holes (regions of background surrounded by one or more objects) are filled in:                            <br> - After both thresholding and declumping: Fill in holes that are smaller than the maximum object size prior to declumping and to fill in any holes after declumping.                            <br> - After declumping only: Fill in holes located within identified objects after declumping.                            <br> - Never: Leave holes within objects. Please note that if an object is located within a hole and this option is enabled, the object will be lost when the hole is filled in.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "After both thresholding and declumping", "options": [["Never", "Never", false], ["After both thresholding and declumping", "After both thresholding and declumping", true], ["After declumping only", "After declumping only", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "Conditional", "name": "con_handling_excessive", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "Erase", "inputs": [{"model_class": "IntegerToolParameter", "name": "max_obj", "argument": null, "type": "integer", "label": "Maximum number of objects", "help": "This setting limits the number of objects in the image.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "500", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "Continue", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "excessive_handling", "argument": null, "type": "select", "label": "Handling of objects if excessive number of objects identified", "help": "This setting deals with images that are segmented into an unreasonable number of objects. This might happen if the module calculates a low threshold or if the image has unusual artifacts. IdentifyPrimaryObjects can handle this condition in one of three ways:                                <br> - Continue: Continue processing regardless if large numbers of objects are found.                                <br> - Erase: Erase all objects if the number of objects exceeds the maximum. This results in an image with no primary objects. This option is a good choice if a large number of objects indicates that the image should not be processed; it can save a lot of time in subsequent Measure modules.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "Continue", "options": [["Continue", "Continue", false], ["Erase", "Erase", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "advanced", "argument": null, "type": "select", "label": "Use advanced settings?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "No", "options": [["No, use basic settings", "No", false], ["Yes, use advanced settings", "Yes", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutput", "name": "output_pipeline", "format": "txt", "label": "", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "output.cppipe", "edam_format": "format_2330", "edam_data": "data_0006", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "imaging", "panel_section_name": "Imaging", "form_style": "regular"}