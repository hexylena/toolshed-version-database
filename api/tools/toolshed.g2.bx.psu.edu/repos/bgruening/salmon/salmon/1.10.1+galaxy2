{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/bgruening/salmon/salmon/1.10.1+galaxy2", "name": "Salmon quant", "version": "1.10.1+galaxy2", "description": "Perform dual-phase, reads or mapping-based estimation of transcript abundance from RNA-seq reads", "labels": [], "edam_operations": ["operation_0236", "operation_3800", "operation_2495"], "edam_topics": ["topic_3170", "topic_3308", "topic_0203"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "salmon", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "salmon", "owner": "bgruening", "changeset_revision": "f4d5237a84f6", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "Conditional", "name": "quant_type", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "reads", "inputs": [{"model_class": "Conditional", "name": "refTranscriptSource", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "indexed", "inputs": [{"model_class": "SelectToolParameter", "name": "index", "argument": null, "type": "select", "label": "Select a reference transcriptome", "help": "If your transcriptome of interest is not listed, contact your Galaxy admin", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": true, "value": "hg38", "options": [["Human Dec. 2013 (GRCh38/hg38) (hg38)", "hg38", false], ["Human Feb. 2009 (GRCh37/hg19) (hg19)", "hg19", false], ["Mouse (Mus Musculus): mm10 Full", "mm10", false]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "history", "inputs": [{"model_class": "Section", "name": "s_index", "type": "section", "title": "Salmon index", "help": null, "expanded": true, "inputs": [{"model_class": "DataToolParameter", "name": "fasta", "argument": null, "type": "data", "label": "Transcripts FASTA file", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta"], "edam": {"edam_formats": ["format_1929"], "edam_data": ["data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "DataToolParameter", "name": "genome", "argument": null, "type": "data", "label": "Reference genome", "help": "The reference genome is required for generating a decoy-away index. The decoy sequences are regions of the target genome                              that are sequence similar to annotated transcripts. These are the regions of the genome most likely to cause mismapping.", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta"], "edam": {"edam_formats": ["format_1929"], "edam_data": ["data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "kmer", "argument": null, "type": "integer", "label": "Kmer length", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "31", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "phash", "argument": null, "type": "boolean", "label": "Perfect Hash", "help": "Build the index using a perfect hash rather than a dense hash.  This will require less memory (especially during quantification),                              but will take longer to construct", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--perfectHash", "falsevalue": ""}]}]}], "test_param": {"model_class": "SelectToolParameter", "name": "TranscriptSource", "argument": null, "type": "select", "label": "Select a reference transcriptome from your history or use a built-in index?", "help": "Built-ins were indexed using default options", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "history", "options": [["Use a built-in index", "indexed", false], ["Use one from the history", "history", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Section", "name": "input", "type": "section", "title": "Data input", "help": null, "expanded": true, "inputs": [{"model_class": "Conditional", "name": "single_or_paired", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "single", "inputs": [{"model_class": "DataToolParameter", "name": "input_singles", "argument": null, "type": "data", "label": "FASTQ/FASTA file", "help": "FASTQ file.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fastq", "fasta", "fastq.gz", "fastq.bz2"], "edam": {"edam_formats": ["format_1930", "format_1929", "format_1930", "format_1930"], "edam_data": ["data_2044", "data_2044", "data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "libtype", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "A", "inputs": []}, {"model_class": "ConditionalWhen", "value": "U", "inputs": []}, {"model_class": "ConditionalWhen", "value": "SF", "inputs": []}, {"model_class": "ConditionalWhen", "value": "SR", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "strandedness", "argument": null, "type": "select", "label": "Specify the strandedness of the reads", "help": "--libtype", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "A", "options": [["Infer automatically (A)", "A", true], ["Not stranded (U)", "U", false], ["read comes from the forward strand (SF)", "SF", false], ["read comes from the reverse strand (SR)", "SR", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "paired", "inputs": [{"model_class": "DataToolParameter", "name": "input_mate1", "argument": null, "type": "data", "label": "Mate pair 1", "help": "FASTQ file.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fastq", "fasta", "fastq.gz", "fastq.bz2", "fastqsanger", "fastqsanger.gz", "fastqsanger.bz2"], "edam": {"edam_formats": ["format_1930", "format_1929", "format_1930", "format_1930", "format_1932", "format_1932", "format_1932"], "edam_data": ["data_2044", "data_2044", "data_2044", "data_2044", "data_2044", "data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "DataToolParameter", "name": "input_mate2", "argument": null, "type": "data", "label": "Mate pair 2", "help": "FASTQ file.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fastq", "fasta", "fastq.gz", "fastq.bz2", "fastqsanger", "fastqsanger.gz", "fastqsanger.bz2"], "edam": {"edam_formats": ["format_1930", "format_1929", "format_1930", "format_1930", "format_1932", "format_1932", "format_1932"], "edam_data": ["data_2044", "data_2044", "data_2044", "data_2044", "data_2044", "data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "libtype", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "A", "inputs": []}, {"model_class": "ConditionalWhen", "value": "U", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "SF", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "SR", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}], "test_param": {"model_class": "SelectToolParameter", "name": "strandedness", "argument": null, "type": "select", "label": "Specify the strandedness of the reads", "help": "--libtype", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "A", "options": [["Infer automatically (A)", "A", true], ["Not stranded (U)", "U", false], ["read comes from the forward strand (SF)", "SF", false], ["read comes from the reverse strand (SR)", "SR", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "paired_collection", "inputs": [{"model_class": "DataCollectionToolParameter", "name": "input_1", "argument": null, "type": "data_collection", "label": "FASTQ Paired Dataset", "help": "Must be of datatype \"fastqsanger\" or \"fasta\"", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fastq", "fasta", "fastq.gz", "fastq.bz2", "fastqsanger", "fastqsanger.gz", "fastqsanger.bz2"], "multiple": false, "options": {"hda": [], "hdca": [], "dce": []}, "tag": null}, {"model_class": "Conditional", "name": "libtype", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "A", "inputs": []}, {"model_class": "ConditionalWhen", "value": "U", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "SF", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "SR", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}], "test_param": {"model_class": "SelectToolParameter", "name": "strandedness", "argument": null, "type": "select", "label": "Specify the strandedness of the reads", "help": "--libtype", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "A", "options": [["Infer automatically (A)", "A", true], ["Not stranded (U)", "U", false], ["read comes from the forward strand (SF)", "SF", false], ["read comes from the reverse strand (SR)", "SR", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "ConditionalWhen", "value": "paired_interleaved", "inputs": [{"model_class": "DataToolParameter", "name": "input_1", "argument": null, "type": "data", "label": "Interleaved FASTQ file", "help": "Must be of datatype \"fastqsanger\" or \"fasta\". --interleaved", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fastq", "fasta", "fastq.gz", "fastq.bz2", "fastqsanger", "fastqsanger.gz", "fastqsanger.bz2"], "edam": {"edam_formats": ["format_1930", "format_1929", "format_1930", "format_1930", "format_1932", "format_1932", "format_1932"], "edam_data": ["data_2044", "data_2044", "data_2044", "data_2044", "data_2044", "data_2044", "data_2044"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "libtype", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "A", "inputs": []}, {"model_class": "ConditionalWhen", "value": "U", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "SF", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}, {"model_class": "ConditionalWhen", "value": "SR", "inputs": [{"model_class": "SelectToolParameter", "name": "orientation", "argument": null, "type": "select", "label": "Relative orientation of reads within a pair", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "I", "options": [["Mates are oriented in the same direction (M = matching)", "M", false], ["Mates are oriented away from each other (O = outward)", "O", false], ["Mates are oriented toward each other (I = inward)", "I", true]], "display": null, "multiple": false, "textable": false}]}], "test_param": {"model_class": "SelectToolParameter", "name": "strandedness", "argument": null, "type": "select", "label": "Specify the strandedness of the reads", "help": "--libtype", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "A", "options": [["Infer automatically (A)", "A", true], ["Not stranded (U)", "U", false], ["read comes from the forward strand (SF)", "SF", false], ["read comes from the reverse strand (SR)", "SR", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "single_or_paired_opts", "argument": null, "type": "select", "label": "Is this library mate-paired?", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "single", "options": [["Single-end", "single", false], ["Paired-end", "paired", false], ["Paired-end Dataset Collection", "paired_collection", false], ["Paired-end data from single interleaved dataset", "paired_interleaved", false]], "display": null, "multiple": false, "textable": false}}]}, {"model_class": "SelectToolParameter", "name": "type", "argument": "--type", "type": "select", "label": "Type of index", "help": "When using quasi, orphaned reads will be considered when performing lightweight-alignment.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "quasi", "options": [["quasi", "quasi", true]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "discardOrphansQuasi", "argument": null, "type": "boolean", "label": "Discard orphan quasi", "help": "Discard orphan mappings in quasi-mapping mode. If this flag is passed then only paired mappings will be considered toward quantification estimates.  The default behavior is to consider orphan mappings if no valid paired mappings exist.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--discardOrphansQuasi", "falsevalue": ""}, {"model_class": "Conditional", "name": "validmap", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "--validateMappings", "inputs": [{"model_class": "FloatToolParameter", "name": "minScoreFraction", "argument": null, "type": "float", "label": "Min Score Fraction", "help": "The fraction of the optimal possible alignment score that a mapping must achieve in order to be considered valid. Should be in (0,1].", "refresh_on_change": false, "min": 0.0, "max": 0.99, "optional": false, "hidden": false, "is_dynamic": false, "value": "0.65", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxMMPExtension", "argument": null, "type": "integer", "label": "Sets the maximum allowable MMP extension when collecting suffix array intervals to be used in chaining. This prevents MMPs from becoming too long, and potentially masking intervals that would uncover other good quasi-mappings for the read. This heuristic mimics the idea of the maximum mappable safe prefix (MMSP) in selective alignment.  Setting a smaller value will potentially allow for more sensitive, but slower, mapping.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "matchScore", "argument": "--ma", "type": "integer", "label": "Match Score", "help": "The value given to a match between read and reference nucleotides in an alignment.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "2", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "mismatchPenalty", "argument": "--mp", "type": "integer", "label": "Mismatch Penalty", "help": "The value given to a mis-match between read and reference nucleotides in an alignment. This will be cast to a negative value.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "4", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "gapOpenPenalty", "argument": "--go", "type": "integer", "label": "Gap Open Penalty", "help": "The value given to a gap opening in an alignment.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "gapExtensionPenalty", "argument": "--ge", "type": "integer", "label": "Gap Extension Penalty", "help": "The value given to a gap extension in an alignment.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "3", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "mimicBT2", "argument": null, "type": "boolean", "label": "Mimic Bowtie 2", "help": " Set flags to mimic parameters similar to Bowtie2 with --no-discordant and --no-mixed flags. This increases disallows dovetailing reads, and discards orphans. Note, this does not impose the very strict parameters assumed by RSEM+Bowtie2, like gapless alignments. For that behavior, use the --mimiStrictBT2 flag ", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--mimicBT2", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "mimicStrictBT2", "argument": null, "type": "boolean", "label": "Mimic Strict Bowtie 2", "help": "Set flags to mimic the very strict parameters used by RSEM+Bowtie2. This increases --minScoreFraction to 0.8, disallows dovetailing reads, discards orphans, and disallows gaps in alignments.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--mimicStrictBT2", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "hardFilter", "argument": null, "type": "boolean", "label": "Hard Filter", "help": "Instead of weighting mappings by their alignment score, this flag will discard any mappings with sub-optimal alignment score. The default option of soft-filtering (i.e. weighting mappings by their alignment score) usually yields slightly more accurate abundance estimates but this flag may be desirable if you want more accurate 'naive' equivalence classes, rather than range factorized equivalence classes.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--hardFilter", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "validateMappings", "argument": null, "type": "select", "label": "Validate mappings", "help": "Validate mappings using alignment-based verifcation. If this flag is passed, quasi-mappings will be validated to ensure that they could give rise to a reasonable alignment before they are further used for quantification.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["True", "--validateMappings", false], ["False", "", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "IntegerToolParameter", "name": "consensusSlack", "argument": null, "type": "integer", "label": "Consensus Slack", "help": "The amount of slack allowed in the quasi-mapping consensus mechanism.  Normally, a transcript must cover all hits to be considered for mapping. If this is set to a value, X, greater than 0, then a transcript can fail to cover up to X hits before it is discounted as a mapping candidate.  The default value of this option is 1 if --validateMappings is given and 0 otherwise.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "dovetail", "argument": null, "type": "boolean", "label": "Allow Dovetail", "help": "Allow dovetail mappings", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--allowDovetail", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "recoverOrphans", "argument": null, "type": "boolean", "label": "Recover Orphans", "help": "Attempt to recover the mates of orphaned reads. This uses edlib for orphan recovery, and so introduces some computational overhead, but it can improve sensitivity.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--recoverOrphans", "falsevalue": ""}, {"model_class": "Conditional", "name": "bam_options", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "--writeMappings=./output/samout.sam", "inputs": [{"model_class": "BooleanToolParameter", "name": "writeQualities", "argument": "--writeQualities", "type": "boolean", "label": "Write qualities", "help": "If this flag is                  provided, then the output SAM file will contain quality strings as well as read sequences.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--writeQualities", "falsevalue": ""}]}, {"model_class": "ConditionalWhen", "value": "", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "writeMappings", "argument": "--writeMappings", "type": "select", "label": "Write Mappings to BAM File", "help": "If this option is provided, then the quasi-mapping results will be written out in SAM-compatible format.  By default, output will be directed to stdout, but an alternative file name can be provided instead", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "options": [["Enabled", "--writeMappings=./output/samout.sam", false], ["Disabled", "", true]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "consistentHits", "argument": null, "type": "boolean", "label": "Consistent Hits", "help": "Force hits gathered during quasi-mapping to be 'consistent' (i.e. co-linear and approximately the right distance apart).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--consistentHits", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "quasiCoverage", "argument": null, "type": "integer", "label": "Quasi Coverage", "help": "[Experimental]: The fraction of the read that must be covered by MMPs (of length >= 31) if this read is to be considered as 'mapped'. This may help to avoid 'spurious' mappings. A value of 0 (the default) denotes no coverage threshold (a single 31-mer can yield a mapping). Since coverage by exact matching, large, MMPs is a rather strict condition, this value should likely be set to something low, if used.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "alignment", "inputs": [{"model_class": "DataToolParameter", "name": "afile", "argument": null, "type": "data", "label": "Alignment file", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["qname_input_sorted.bam", "qname_sorted.bam"], "edam": {"edam_formats": ["format_2572", "format_2572"], "edam_data": ["data_0863", "data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "BooleanToolParameter", "name": "ont", "argument": "--ont", "type": "boolean", "label": "Is this Alignment file a Oxford Nanopore Technologies (ONT) dataset ?", "help": "Select this for both cDNA and direct RNA ONT datasets. Enables an alignment error model designed to work with long-read alignments and disables the length effect in the generative model when computing the conditional probability of observing a fragment given that it arises from a specific transcript. This is because in long-read sequencing, we do not expect to observe (i.e. sequence) multiple fragments from the same molecule, and thus we do not expect the transcript length to directly affect the observed fragment count directly", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--ont", "falsevalue": ""}, {"model_class": "DataToolParameter", "name": "transcript", "argument": null, "type": "data", "label": "Transcript file", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["fasta", "fa"], "edam": {"edam_formats": ["format_1929", null], "edam_data": ["data_2044", null]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "Conditional", "name": "libtype", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "A", "inputs": []}, {"model_class": "ConditionalWhen", "value": "U", "inputs": []}, {"model_class": "ConditionalWhen", "value": "SF", "inputs": []}, {"model_class": "ConditionalWhen", "value": "SR", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "strandedness", "argument": null, "type": "select", "label": "Specify the strandedness of the reads", "help": "--libtype", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "A", "options": [["Infer automatically (A)", "A", true], ["Not stranded (U)", "U", false], ["read comes from the forward strand (SF)", "SF", false], ["read comes from the reverse strand (SR)", "SR", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "discardOrphans", "argument": null, "type": "boolean", "label": "Discard orphans", "help": "Discard orphan alignments in the input. If this flag is passed, then only paired alignments will be considered toward quantification estimates. The default behavior is to consider orphan alignments if no valid paired mappings exist.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--discardOrphans", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "noErrorModel", "argument": null, "type": "boolean", "label": "No Error Model", "help": "Turn off the alignment error model, which takes into account the the observed frequency of different types of mismatches / indels when computing the likelihood of a given alignment. Turning this off can speed up alignment-based salmon, but can harm quantification accuracy.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noErrorModel", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "numErrorBins", "argument": null, "type": "integer", "label": "Number of Error Bins", "help": "The number of bins into which to divideeach read when learning and applying the error model. For example, a value of 10 would mean that effectively, a separate error model is learned and applied to each 10th of the read, whilea value of 3 would mean that a separate error model is applied to the read beginning (first third), middle (second third) and end (final third).", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "6", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "sampleOut", "argument": null, "type": "boolean", "label": "Sample out", "help": "Write a 'postSample.bam' file in the output directory that will sample the input alignments according to the estimated transcript abundances. If you're going to perform downstream analysis of the alignments with tools which don't, themselves, take fragment assignment ambiguity into account, you should use this output", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--sampleOut", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "sampleUnaligned", "argument": null, "type": "boolean", "label": "Sample unaligned", "help": "In addition to sampling the aligned reads, also write the un-aligned reads to 'postSample.bam'.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--sampleUnaligned", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "gencode", "argument": null, "type": "boolean", "label": "Gencode", "help": "This flag will expect the input transcript fasta to be in GENCODE format, and will split the transcript name at the first '|' character.  These reduced names will be used in the output and when looking for these transcripts in a gene to transcript GTF.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--gencode", "falsevalue": ""}]}], "test_param": {"model_class": "SelectToolParameter", "name": "qtype", "argument": null, "type": "select", "label": "Select salmon quantification mode:", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "reads", "options": [["Reads", "reads", true], ["Alignment", "alignment", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "DataToolParameter", "name": "geneMap", "argument": null, "type": "data", "label": "File containing a mapping of transcripts to genes", "help": "If this file is provided Salmon will output both quant.sf and quant.genes.sf files, where the latter contains aggregated gene-level abundance estimates. The transcript to gene mapping should be provided as either a GTF file, or a in a simple tab-delimited format where each line contains the name of a transcript and the gene to which it belongs separated by a tab.", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["tabular", "gff", "gtf"], "edam": {"edam_formats": ["format_3475", "format_2305", "format_2306"], "edam_data": ["data_0006", "data_1255", "data_1255"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "BooleanToolParameter", "name": "seqBias", "argument": null, "type": "boolean", "label": "Perform sequence-specific bias correction", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--seqBias", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "gcBias", "argument": null, "type": "boolean", "label": "Perform fragment GC bias correction", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--gcBias", "falsevalue": ""}, {"model_class": "FloatToolParameter", "name": "incompatPrior", "argument": null, "type": "float", "label": "", "help": "Sets the prior probability that an alignment that disagrees with the specified library type (orientation and strandedness) results from the true fragment origin. Setting this to 0 specifies that alignments that disagree with the library type should be 'impossible', while setting it to 1 says that alignments that disagree with the library type are no less likely than those that do", "refresh_on_change": false, "min": 0.0, "max": 1.0, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "meta", "argument": null, "type": "boolean", "label": "Meta", "help": "If you're using Salmon on a metagenomic dataset, consider setting this flag to disable parts of the abundance estimation model that make less sense for metagenomic data.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--meta", "falsevalue": ""}, {"model_class": "Section", "name": "adv", "type": "section", "title": "Additional Options", "help": null, "expanded": false, "inputs": [{"model_class": "BooleanToolParameter", "name": "skipQuant", "argument": null, "type": "boolean", "label": "skipQuant", "help": "Skip performing the actual transcript quantification (including any Gibbs sampling or bootstrapping).", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--skipQuant", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "dumpEq", "argument": null, "type": "boolean", "label": "Dump equivalence class counts", "help": "Dump the equivalence class counts that were computed during quasi-mapping.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--dumpEq", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "dumpEqWeights", "argument": null, "type": "boolean", "label": "Dump equivalence class counts including rich weights", "help": "Includes 'rich' equivlance class weights in the output when equivalence class information is being dumped to file.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--dumpEqWeights", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "minAssignedFrags", "argument": null, "type": "integer", "label": "Minimum assigned fragments", "help": "The minimum number of fragments that must be assigned to the transcriptome for quantification to proceed.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "biasSpeedSamp", "argument": null, "type": "integer", "label": "The value at which the fragment length PMF is down-sampled when evaluating GC fragment bias.", "help": "Larger values speed up effective length correction, but may decrease the fidelity of bias modeling results.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "5", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "fldMax", "argument": null, "type": "integer", "label": "The maximum fragment length to consider when building the empirical distribution.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "fldMean", "argument": null, "type": "integer", "label": "The mean used in the fragment length distribution prior", "help": "If single end reads are being used for quantification, or there are an insufficient number of uniquely mapping reads when performing paired-end quantification to estimate the empirical fragment length distribution, then use this value to calculate effective lengths.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "250", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "fldSD", "argument": null, "type": "integer", "label": "Standard deviation", "help": "The standard deviation used in the fragment length distribution prior.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "25", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "forgettingFactor", "argument": null, "type": "float", "label": "The forgetting factor used in the online learning schedule.", "help": " A smaller value results in quicker learning, but higher variance and may be unstable. A larger value results in slower learning but may be more stable.  Value should be in the interval (0.5, 1.0].", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0.65", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "initUniform", "argument": null, "type": "boolean", "label": "Initialization with uniform parameters", "help": "initialize the offline inference with uniform parameters, rather than seeding with online parameters.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--initUniform", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "maxReadOcc", "argument": null, "type": "integer", "label": "Maximal read mapping occurence", "help": "Reads mapping to more than this many places won't be considered.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "100", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "noLengthCorrection", "argument": null, "type": "boolean", "label": "No length correction", "help": "[experimental] : Entirely disables length correction when estimating the abundance of transcripts.  This option can be used with protocols where one expects that fragments derive from their underlying targets without regard to that target's length (e.g. QuantSeq)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noLengthCorrection", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "noEffectiveLengthCorrection", "argument": null, "type": "boolean", "label": "Disable effective length correction", "help": "Disables effective length correction when computing the probability that a fragment was generated from a transcript. If this flag is passed in, the fragment length distribution is not taken into account when computing this probability.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noEffectiveLengthCorrection", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "noFragLengthDist", "argument": null, "type": "boolean", "label": "Ignore fragment length distribution", "help": "[experimental] : Don't consider concordance with the learned fragment length distribution when trying to determine the probability that a fragment has originated from a specified location.  Normally, Fragments with unlikely lengths will be assigned a smaller relative probability than those with more likely lengths. When this flag is passed in, the observed fragment length has no effect on that fragment's a priori probability.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noFragLengthDist", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "noBiasLengthThreshold", "argument": null, "type": "boolean", "label": "[experimental] : If this option is enabled, then no (lower) threshold will be set on how short bias correction can make effecctive lengths.", "help": "This can increase the precision of bias correction, but harm robustness. The default correction applies a threshold.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noBiasLengthThreshold", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "numBiasSamples", "argument": null, "type": "integer", "label": "Number of fragment mappings to use when learning the sequence-specific bias model.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "2000000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "numAuxModelSamples", "argument": null, "type": "integer", "label": "The first numAuxModelSamples are used to train the auxiliary model parameters.", "help": "(e.g. fragment length distribution, bias, etc.). After ther first numAuxModelSamples observations the auxiliary model parameters will be assumed to have converged and will be fixed.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "5000000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "numPreAuxModelSamples", "argument": null, "type": "integer", "label": "The first numPreAuxModelSamples will have their assignment likelihoods and contributions to the transcript abundances computed without applying any auxiliary models.", "help": " The purpose of ignoring the auxiliary models for the first numPreAuxModelSamples observations is to avoid applying these models before thier parameters have been learned sufficiently well.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "5000", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "useEM", "argument": null, "type": "boolean", "label": "Use the traditional EM algorithm for optimization in the batch passes.", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--useEM", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "rangeFactorizationBins", "argument": null, "type": "integer", "label": "Range of factorization bins", "help": "Factorizes the likelihood used in quantification by adopting a new notion of equivalence classes based on the conditional probabilities with which fragments are generated from different transcripts. This is a more fine-grained factorization than the normal rich equivalence classes. The default value (0) corresponds to the standard rich equivalence classes, and larger values imply a more fine-grained factorization. If range factorization is enabled, a common value to select for this parameter is 4.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "numGibbsSamples", "argument": null, "type": "integer", "label": "Number of Gibbs sampling rounds to perform.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "noGammaDraw", "argument": null, "type": "boolean", "label": "No gamma draw", "help": "This switch will disable drawing transcript fractions from a Gamma distribution during Gibbs sampling. In this case the sampler does not account for shot-noise, but only assignment ambiguity", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--noGammaDraw", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "numBootstraps", "argument": null, "type": "integer", "label": "Number of bootstrap samples to generate. Note: This is mutually exclusive with Gibbs sampling.", "help": "", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "bootstrapReproject", "argument": null, "type": "boolean", "label": "Bootstrap reproject", "help": "This switch will learn the parameter distribution from the bootstrapped counts for each sample, but will reproject those parameters onto the original equivalence class counts.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--bootstrapReproject", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "thinningFactor", "argument": null, "type": "integer", "label": "Thinning factor", "help": "Number of steps to discard for every sample kept from the Gibbs chain. The larger this number, the less chance that subsequent samples are auto-correlated, but the slower sampling becomes.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "16", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "perTranscriptPrior", "argument": null, "type": "boolean", "label": "The prior will be interpreted as a transcript-level prior.", "help": "either the default or the argument provided via --vbPrior", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--perTranscriptPrior", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "sigDigits", "argument": null, "type": "integer", "label": "Significant Digits", "help": "The number of significant digits to write when outputting the EffectiveLength and NumReads columns.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "3", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "vbPrior", "argument": null, "type": "float", "label": "The prior that will be used in the VBEM algorithm.", "help": "This is interpreted as a per-nucleotide prior, unless the --perTranscriptPrior flag is also given, in which case this is used as a transcript-level prior.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1e-05", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "writeOrphanLinks", "argument": null, "type": "boolean", "label": "Write orphan links", "help": "Write the transcripts that are linked by orphaned reads.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--writeOrphanLinks", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "writeUnmappedNames", "argument": null, "type": "boolean", "label": "Write the names of un-mapped reads to the file unmapped_names.txt.", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--writeUnmappedNames", "falsevalue": ""}]}], "outputs": [{"model_class": "ToolOutput", "name": "output_quant", "format": "tabular", "label": "${tool.name} on ${on_string}: transcript quantification", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "output/quant.sf", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_gene_quant", "format": "tabular", "label": "${tool.name} on ${on_string}: gene quantification", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "output/quant.genes.sf", "edam_format": "format_3475", "edam_data": "data_0006", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "output_bam", "format": "bam", "label": "${tool.name} on ${on_string}: BAM", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "output/bamout.bam", "edam_format": "format_2572", "edam_data": "data_0863", "discover_datasets": []}, {"model_class": "ToolOutput", "name": "postSample", "format": "bam", "label": "${tool.name} on ${on_string}: sampled input alignments", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": "output/bamout.bam", "edam_format": "format_2572", "edam_data": "data_0863", "discover_datasets": []}], "panel_section_id": "rna_analysis", "panel_section_name": "RNA Analysis", "form_style": "regular"}