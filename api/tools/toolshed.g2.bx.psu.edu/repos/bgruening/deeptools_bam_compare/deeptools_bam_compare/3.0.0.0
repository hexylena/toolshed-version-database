{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/bgruening/deeptools_bam_compare/deeptools_bam_compare/3.0.0.0", "name": "bamCompare", "version": "3.0.0.0", "description": "normalizes and compares two BAM or CRAM files to obtain the ratio, log2ratio or difference between them", "labels": [], "edam_operations": ["operation_0337", "operation_3435"], "edam_topics": ["topic_0622", "topic_3169"], "hidden": true, "is_workflow_compatible": true, "xrefs": [{"value": "deeptools", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "deeptools_bam_compare", "owner": "bgruening", "changeset_revision": "2a1b4e95bdf7", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "bamFile1", "argument": "--bamFile1", "type": "data", "label": "First BAM/CRAM file (e.g. treated sample)", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam", "cram"], "edam": {"edam_formats": ["format_2572", "format_3462"], "edam_data": ["data_0863", "data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "DataToolParameter", "name": "bamFile2", "argument": "--bamFile2", "type": "data", "label": "Second BAM/CRAM file (e.g. control sample)", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam", "cram"], "edam": {"edam_formats": ["format_2572", "format_3462"], "edam_data": ["data_0863", "data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "binSize", "argument": "--binSize", "type": "integer", "label": "Bin size in bases", "help": "The genome will be divided into bins of the specified size. For each bin, the overlapping number of fragments (or reads) will be reported.                 If only half a fragment overlaps then this fraction will be reported.", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "scaling", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "SES", "inputs": [{"model_class": "IntegerToolParameter", "name": "sampleLength", "argument": "--sampleLength", "type": "integer", "label": "Length in bases used to sample the genome and compute the size or scaling factors.", "help": "The default is fine. Only change it if you know what you are doing.", "refresh_on_change": false, "min": 10, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "numberOfSamples", "argument": "--numberOfSamples", "type": "integer", "label": "Number of samplings taken from the genome to compute the scaling factors", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100000", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "readCount", "inputs": []}, {"model_class": "ConditionalWhen", "value": "own", "inputs": [{"model_class": "FloatToolParameter", "name": "scaleFactor1", "argument": null, "type": "float", "label": "Scale factor for treatment", "help": "(--scaleFactors)", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "scaleFactor2", "argument": null, "type": "float", "label": "Scale factor for input", "help": "(--scaleFactors)", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "None", "inputs": [{"model_class": "SelectToolParameter", "name": "type", "argument": null, "type": "select", "label": "Normalization method", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "RPKM", "options": [["Normalize to fragments (reads) per kilobase per million (RPKM)", "RPKM", false], ["Normalize to counts per million (CPM), same as CPM in RNA-seq", "CPM", false], ["Normalize to bins per million (BPM), same as TPM in RNA-seq", "BPM", false], ["Do not normalize or scale", "", false]], "display": null, "multiple": false, "textable": false}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": null, "type": "select", "label": "Method to use for scaling the largest sample to the smallest", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "readCount", "options": [["read count", "readCount", true], ["signal extraction scaling (SES), check with plotFingerprint before using it!", "SES", false], ["enter own scaling factors", "own", false], ["Don't scale reads. Samples can instead be normalized using one of the normalization methods", "None", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "comparison", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "log2", "inputs": [{"model_class": "FloatToolParameter", "name": "pseudocount", "argument": "--pseudocount", "type": "float", "label": "Pseudocount", "help": "Small number to avoid dividing by zero.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "ratio", "inputs": [{"model_class": "FloatToolParameter", "name": "pseudocount", "argument": "--pseudocount", "type": "float", "label": "Pseudocount", "help": "Small number to avoid dividing by zero.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "add", "inputs": []}, {"model_class": "ConditionalWhen", "value": "subtract", "inputs": []}, {"model_class": "ConditionalWhen", "value": "mean", "inputs": []}, {"model_class": "ConditionalWhen", "value": "first", "inputs": []}, {"model_class": "ConditionalWhen", "value": "second", "inputs": []}, {"model_class": "ConditionalWhen", "value": "reciprocal_ratio", "inputs": [{"model_class": "FloatToolParameter", "name": "pseudocount", "argument": "--pseudocount", "type": "float", "label": "Pseudocount", "help": "Small number to avoid dividing by zero.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "type", "argument": null, "type": "select", "label": "How to compare the two files", "help": "The default is to output the log2ratio between the two samples.                 The reciprocal ratio returns the negative of the inverse of the ratio if                 the ratio is less than 0. The resulting values are interpreted as negative                 fold changes. To output the scaled values from the first or second BAM file,                 select 'first' or 'second'.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "log2", "options": [["Compute log2 of the number of reads ratio", "log2", true], ["Compute the ratio of the number of reads", "ratio", false], ["Compute difference (subtract input from treatment) of the number of reads", "subtract", false], ["Compute the sum of number of reads", "add", false], ["Compute the mean of the number of reads between the two files", "mean", false], ["Computes the fold change. If the fold change is less than 1, the negative of the inverse is reported. E.g. A fold change of 10 to 5 would be reported not as 0.5 but as -2", "reciprocal_ratio", false], ["Returns the scaled value of the first BAM file", "first", false], ["Returns the scaled value of the second BAM file", "second", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "outFileFormat", "argument": null, "type": "select", "label": "Coverage file format", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "bigwig", "options": [["bigwig", "bigwig", true], ["bedgraph", "bedgraph", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "region", "argument": "--region", "type": "text", "label": "Region of the genome to limit the operation to", "help": "This is useful when testing parameters to reduce the time required. The format is chr:start:end, for example \"chr10\" or \"chr10:456700:891000\".", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "advancedOpt", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "smoothLength", "argument": "--smoothLength", "type": "integer", "label": "Smooth values using the following length (in bases)", "help": "The smooth length defines a window, larger than the bin size, over which the number of reads is to be averaged. For example, if the bin size is set to 20 and the smooth length is 60, then, for each bin, its value is set to the average of it and its left and right neighbors. Any value smaller than the bin size will be ignored and no smoothing will be applied.", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "Conditional", "name": "doExtendCustom", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": []}, {"model_class": "ConditionalWhen", "value": "custom", "inputs": [{"model_class": "IntegerToolParameter", "name": "extendReadsValue", "argument": null, "type": "integer", "label": "Extend reads to the given average fragment size", "help": "Extend all reads to this length", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "300", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "doExtend", "argument": null, "type": "select", "label": "Extend reads to the given average fragment size.", "help": "If selected : Single-end reads and singletons are extended to match the given length and Paired-end reads are extended to match the fragment size.                      By default *each* read mate is extended.                      This can be modified using the SAM flags (see --samFlagInclude and --samFlagExclude options) to keep only the first or the second mate.                      Unmated reads, mate reads that map to different chromosomes or too far apart are extended to the given value.                      Reads are only extended if --extendReads is set to a value greater than the read length. *NOTE*: For spliced-read data, this option is not                      recommended as it will extend reads over skipped regions, e.g. introns in RNA-seq data.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["No extension. The default value and most typically appropriate.", "no", true], ["Paired-end extension. Suitable only for paired-end datasets.", "yes", false], ["A custom length, which will be applied to ALL reads.", "custom", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "ignoreDuplicates", "argument": "--ignoreDuplicates", "type": "boolean", "label": "Ignore duplicates", "help": "If set, reads that have the same orientation and start position will be considered only once. If reads are paired, the mate position also has to coincide to ignore a read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--ignoreDuplicates", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "centerReads", "argument": "--centerReads", "type": "boolean", "label": "Center regions with respect to the fragment length", "help": "For paired-end data the fragment is defined by the bounds of the reads. For single-end data the bounds are defined by the read and the user-definable fragment/extension length. This option is useful to get a sharper signal around enriched regions.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--centerReads", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "minMappingQuality", "argument": "--minMappingQuality", "type": "integer", "label": "Minimum mapping quality", "help": "If set, only reads with a mapping quality score at least this high are considered.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "samFlagInclude", "argument": "--samFlagInclude", "type": "integer", "label": "Include reads based on the SAM flag", "help": "For example, to get only reads that are the first mate use a flag of 64. This is useful to count properly paired reads only once, otherwise the second mate will be also considered for the coverage.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "samFlagExclude", "argument": "--samFlagExclude", "type": "integer", "label": "Exclude reads based on the SAM flag", "help": "For example, to get only reads that map to the forward strand, use --samFlagExclude 16, where 16 is the SAM flag for reads that map to the reverse strand.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "minFragmentLength", "argument": "--minFragmentLength", "type": "integer", "label": "Minimum fragment length for inclusion.", "help": "This is primarily useful in things like ATACseq, where one would like to look specifically at mono- or di-nucleosome fragments.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxFragmentLength", "argument": "--maxFragmentLength", "type": "integer", "label": "Maximum fragment length for inclusion.", "help": "A value of 0 (the default) is equivalent to no maximum.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "skipNAs", "argument": "--skipNAs", "type": "boolean", "label": "Ignore missing data?", "help": "This parameter determines if non-covered regions                  (regions without overlapping reads) in a bam/bigWig file                  should be skipped. The default is to treat those                  regions as having a value of zero. The decision to                  skip non-covered regions depends on the interpretation                  of the data. Non-covered regions may represent, for                  example, repetitive regions that should be ignored.                  (default: False)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--skipNAs", "falsevalue": ""}, {"model_class": "TextToolParameter", "name": "ignoreForNormalization", "argument": "--ignoreForNormalization", "type": "text", "label": "regions that should be excluded for calculating the scaling factor", "help": "Sometimes it makes sense to exclude certain regions when calculating the scaling factor.                         For example, if you know of copy number variations between samples then you may want to exclude these.                         Another typical example is the difference in chromosome X copies between males and females in many species.                         Example inputs are chrX,chrY,chr3 or chr10:12220-128932", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "DataToolParameter", "name": "blackListFileName", "argument": "--blackListFileName", "type": "data", "label": "Blacklisted regions in BED/GTF format", "help": "One or more files containing regions to exclude from the analysis", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bed", "gtf"], "edam": {"edam_formats": ["format_3003", "format_2306"], "edam_data": ["data_3002", "data_1255"]}, "multiple": true, "min": 0, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "showAdvancedOpt", "argument": null, "type": "select", "label": "Show advanced options", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["yes", "yes", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutput", "name": "outFileName", "format": "bigwig", "label": "", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3006", "edam_data": "data_3002", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "deeptools", "panel_section_name": "deepTools", "form_style": "regular"}