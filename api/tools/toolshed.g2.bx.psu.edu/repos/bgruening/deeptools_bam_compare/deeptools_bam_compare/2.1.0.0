{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/bgruening/deeptools_bam_compare/deeptools_bam_compare/2.1.0.0", "name": "bamCompare", "version": "2.1.0.0", "description": "normalizes and compares two BAM files to obtain the ratio, log2ratio or difference between them", "labels": [], "edam_operations": ["operation_3435", "operation_0337"], "edam_topics": ["topic_0622", "topic_3169"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "deeptools", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "deeptools_bam_compare", "owner": "bgruening", "changeset_revision": "075ac65129b5", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "bamFile1", "argument": "--bamFile1", "type": "data", "label": "First BAM file (e.g. treated sample)", "help": "The BAM file must be sorted.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam"], "edam": {"edam_formats": ["format_2572"], "edam_data": ["data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "DataToolParameter", "name": "bamFile2", "argument": "--bamFile2", "type": "data", "label": "Second BAM file (e.g. control sample)", "help": "The BAM file must be sorted.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam"], "edam": {"edam_formats": ["format_2572"], "edam_data": ["data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "binSize", "argument": "--binSize", "type": "integer", "label": "Bin size in bases", "help": "The genome will be divided into bins of the specified size. For each bin, the overlaping number of fragments (or reads) will be reported.                 If only half a fragment overlaps then this fraction will be reported.", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "scaling", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "SES", "inputs": [{"model_class": "IntegerToolParameter", "name": "sampleLength", "argument": "--sampleLength", "type": "integer", "label": "Length in bases used to sample the genome and compute the size or scaling factors.", "help": "The default is fine. Only change it if you know what you are doing.", "refresh_on_change": false, "min": 10, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1000", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "numberOfSamples", "argument": "--numberOfSamples", "type": "integer", "label": "Number of samplings taken from the genome to compute the scaling factors", "help": "", "refresh_on_change": false, "min": 0, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "100000", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "readCount", "inputs": []}, {"model_class": "ConditionalWhen", "value": "own", "inputs": [{"model_class": "FloatToolParameter", "name": "scaleFactor1", "argument": null, "type": "float", "label": "Scale factor for treatment", "help": "(--scaleFactors)", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "FloatToolParameter", "name": "scaleFactor2", "argument": null, "type": "float", "label": "Scale factor for input", "help": "(--scaleFactors)", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "method", "argument": null, "type": "select", "label": "Method to use for scaling the largest sample to the smallest", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "readCount", "options": [["read count", "readCount", true], ["signal extraction scaling (SES), check with plotFingerprint before using it!", "SES", false], ["enter own scaling factors", "own", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "Conditional", "name": "comparison", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "log2", "inputs": [{"model_class": "FloatToolParameter", "name": "pseudocount", "argument": "--pseudocount", "type": "float", "label": "Pseudocount", "help": "Small number to avoid dividing by zero.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "ratio", "inputs": [{"model_class": "FloatToolParameter", "name": "pseudocount", "argument": "--pseudocount", "type": "float", "label": "Pseudocount", "help": "Small number to avoid dividing by zero.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "add", "inputs": []}, {"model_class": "ConditionalWhen", "value": "reciprocal_ratio", "inputs": [{"model_class": "FloatToolParameter", "name": "pseudocount", "argument": "--pseudocount", "type": "float", "label": "Pseudocount", "help": "Small number to avoid dividing by zero.", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "subtract", "inputs": [{"model_class": "Conditional", "name": "normalization", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "rpkm", "inputs": []}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "1x", "inputs": [{"model_class": "Conditional", "name": "effectiveGenomeSize", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "specific", "inputs": [{"model_class": "IntegerToolParameter", "name": "effectiveGenomeSize", "argument": "--effectiveGenomeSize", "type": "integer", "label": "Effective genome size", "help": "e.g. ce10: 93260000, dm3: 121400000, hg19: 2451960000, mm9: 2150570000", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "2150570000", "inputs": []}, {"model_class": "ConditionalWhen", "value": "2451960000", "inputs": []}, {"model_class": "ConditionalWhen", "value": "121400000", "inputs": []}, {"model_class": "ConditionalWhen", "value": "93260000", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "effectiveGenomeSize_opt", "argument": null, "type": "select", "label": "Effective genome size", "help": "The effective genome size is the portion of the genome that is mappable. Large fractions of the genome are stretches of NNNN that should be discarded.                     Also, if repetitive regions were not included in the mapping of reads, the effective genome size needs to be adjusted accordingly.                     See Table 2 of http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0030377 or http://www.nature.com/nbt/journal/v27/n1/fig_tab/nbt.1518_T1.html for several effective genome sizes.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "2451960000", "options": [["ce10 (93260000)", "93260000", false], ["dm3 (121400000)", "121400000", false], ["hg19 (2451960000)", "2451960000", true], ["mm9 (2150570000)", "2150570000", false], ["user specified", "specific", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "type", "argument": null, "type": "select", "label": "Normalization method", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "1x", "options": [["Normalize coverage to 1x", "1x", false], ["Normalize to fragments (reads) per kilobase per million (RPKM)", "rpkm", false], ["Do not normalize or scale", "no", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "type", "argument": null, "type": "select", "label": "How to compare the two files", "help": "The default is to output the log2ratio between the two samples.                 The reciprocal ratio returns the negative of the inverse of the ratio if                 the ratio is less than 0. The resulting values are interpreted as negative fold changes.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "log2", "options": [["Compute log2 of the number of reads ratio", "log2", true], ["Compute the ratio of the number of reads", "ratio", false], ["Compute difference (subtract input from treatment) of the number of reads", "subtract", false], ["Compute the sum of number of reads", "add", false], ["Computes the fold change. If the fold change is less than 1, the negative of the inverse is reported. E.g. A fold change of 10 to 5 would be reported not as 0.5 but as -2", "reciprocal_ratio", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "outFileFormat", "argument": null, "type": "select", "label": "Coverage file format", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "bigwig", "options": [["bigwig", "bigwig", true], ["bedgraph", "bedgraph", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "TextToolParameter", "name": "region", "argument": "--region", "type": "text", "label": "Region of the genome to limit the operation to", "help": "This is useful when testing parameters to reduce the time required. The format is chr:start:end, for example \"chr10\" or \"chr10:456700:891000\".", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "advancedOpt", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "IntegerToolParameter", "name": "smoothLength", "argument": "--smoothLength", "type": "integer", "label": "Smooth values using the following length (in bases)", "help": "The smooth length defines a window, larger than the bin size, over which the number of reads is to be averaged. For example, if the bin size is set to 20 and the smooth length is 60, then, for each bin, its value is set to the average of it and its left and right neighbors. Any value smaller than the bin size will be ignored and no smoothing will be applied.", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "Conditional", "name": "doExtendCustom", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": []}, {"model_class": "ConditionalWhen", "value": "custom", "inputs": [{"model_class": "IntegerToolParameter", "name": "extendReadsValue", "argument": null, "type": "integer", "label": "Extend reads to the given average fragment size", "help": "Extend all reads to this length", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "300", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "doExtend", "argument": null, "type": "select", "label": "Extend reads to the given average fragment size.", "help": "(1) Single-end reads and singletons are extended to match this length. (2) Paired-end reads are extended to match the fragment size, regardless of what is set here.                      By default *each* read mate is extended.                      This can be modified using the SAM flags (see --samFlagInclude and --samFlagExclude options) to keep only the first or the second mate.                      Unmated reads, mate reads that map to different chromosomes or too far apart are extended to the given value.                      Reads are only extended if --extendReads is set to a value greater than the read length. *NOTE*: For spliced-read data, this option is not                      recommended as it will extend reads over skipped regions, e.g. introns in RNA-seq data.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["No extension. The default value and most typically appropriate.", "no", true], ["Paired-end extension. Suitable only for paired-end datasets.", "yes", false], ["A custom length, which will be applied to ALL reads.", "custom", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "ignoreDuplicates", "argument": "--ignoreDuplicates", "type": "boolean", "label": "Ignore duplicates", "help": "If set, reads that have the same orientation and start position will be considered only once. If reads are paired, the mate position also has to coincide to ignore a read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--ignoreDuplicates", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "centerReads", "argument": "--centerReads", "type": "boolean", "label": "Center regions with respect to the fragment length", "help": "For paired-end data the fragment is defined by the bounds of the reads. For single-end data the bounds are defined by the read and the user-definable fragment/extension length. This option is useful to get a sharper signal around enriched regions.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--centerReads", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "minMappingQuality", "argument": "--minMappingQuality", "type": "integer", "label": "Minimum mapping quality", "help": "If set, only reads with a mapping quality score higher than this value are considered.", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "samFlagInclude", "argument": "--samFlagInclude", "type": "integer", "label": "Include reads based on the SAM flag", "help": "For example, to get only reads that are the first mate use a flag of 64. This is useful to count properly paired reads only once, otherwise the second mate will be also considered for the coverage.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "samFlagExclude", "argument": "--samFlagExclude", "type": "integer", "label": "Exclude reads based on the SAM flag", "help": "For example, to get only reads that map to the forward strand, use --samFlagExclude 16, where 16 is the SAM flag for reads that map to the reverse strand.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "skipNAs", "argument": "--skipNAs", "type": "boolean", "label": "Ignore missing data?", "help": "This parameter determines if non-covered regions                  (regions without overlapping reads) in a bam/bigWig file                  should be skipped. The default is to treat those                  regions as having a value of zero. The decision to                  skip non-covered regions depends on the interpretation                  of the data. Non-covered regions may represent, for                  example, repetitive regions that should be ignored.                  (default: False)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--skipNAs", "falsevalue": ""}, {"model_class": "TextToolParameter", "name": "ignoreForNormalization", "argument": "--ignoreForNormalization", "type": "text", "label": "regions that should be excluded for calculating the scaling factor", "help": "Sometimes it makes sense to exclude certain regions when calculating the scaling factor.                         For example, if you know of copy number variations between samples then you may want to exclude these.                         Another typical example is the difference in chromosome X copies between males and females in many species.                         Example inputs are chrX,chrY,chr3 or chr10:12220-128932", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "showAdvancedOpt", "argument": null, "type": "select", "label": "Show advanced options", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["yes", "yes", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutput", "name": "outFileName", "format": "bigwig", "label": "", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3006", "edam_data": "data_3002", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "deeptools", "panel_section_name": "deepTools", "form_style": "regular"}