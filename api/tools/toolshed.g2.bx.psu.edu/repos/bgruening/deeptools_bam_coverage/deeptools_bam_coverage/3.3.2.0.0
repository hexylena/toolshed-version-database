{"model_class": "Tool", "id": "toolshed.g2.bx.psu.edu/repos/bgruening/deeptools_bam_coverage/deeptools_bam_coverage/3.3.2.0.0", "name": "bamCoverage", "version": "3.3.2.0.0", "description": "generates a coverage bigWig file from a given BAM or CRAM file", "labels": [], "edam_operations": ["operation_3435", "operation_0337"], "edam_topics": ["topic_0622", "topic_3169"], "hidden": "", "is_workflow_compatible": true, "xrefs": [{"value": "deeptools", "reftype": "bio.tools"}], "tool_shed_repository": {"name": "deeptools_bam_coverage", "owner": "bgruening", "changeset_revision": "bb1e4f63e0e6", "tool_shed": "toolshed.g2.bx.psu.edu"}, "inputs": [{"model_class": "DataToolParameter", "name": "bamInput", "argument": null, "type": "data", "label": "BAM/CRAM file", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bam", "cram"], "edam": {"edam_formats": ["format_2572", "format_3462"], "edam_data": ["data_0863", "data_0863"]}, "multiple": false, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}, {"model_class": "IntegerToolParameter", "name": "binSize", "argument": null, "type": "integer", "label": "Bin size in bases", "help": "The genome will be divided into bins of the specified size. For each bin, the overlaping number of fragments (or reads)  will be reported. If only half a fragment overlaps, this fraction will be reported. ", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "50", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "scaling", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "rpkm", "inputs": []}, {"model_class": "ConditionalWhen", "value": "cpm", "inputs": []}, {"model_class": "ConditionalWhen", "value": "bpm", "inputs": []}, {"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "1x", "inputs": [{"model_class": "Conditional", "name": "effectiveGenomeSize", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "specific", "inputs": [{"model_class": "IntegerToolParameter", "name": "effectiveGenomeSize", "argument": "--effectiveGenomeSize", "type": "integer", "label": "Effective genome size", "help": "e.g. ce10: 93260000, dm3: 130428560, hg19: 2685511504, mm9: 2304947926", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}]}, {"model_class": "ConditionalWhen", "value": "93260000", "inputs": []}, {"model_class": "ConditionalWhen", "value": "130428560", "inputs": []}, {"model_class": "ConditionalWhen", "value": "125464728", "inputs": []}, {"model_class": "ConditionalWhen", "value": "2685511504", "inputs": []}, {"model_class": "ConditionalWhen", "value": "2701495761", "inputs": []}, {"model_class": "ConditionalWhen", "value": "2304947926", "inputs": []}, {"model_class": "ConditionalWhen", "value": "2308125349", "inputs": []}], "test_param": {"model_class": "SelectToolParameter", "name": "effectiveGenomeSize_opt", "argument": null, "type": "select", "label": "Effective genome size", "help": "The effective genome size is the portion of the genome that is mappable. Large fractions of the genome are stretches of NNNN that should be discarded.                     Also, if repetitive regions were not included in the mapping of reads, the effective genome size needs to be adjusted accordingly.                     We provide a table of useful sizes here: http://deeptools.readthedocs.io/en/latest/content/feature/effectiveGenomeSize.html", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "2685511504", "options": [["ce10 (93260000)", "93260000", false], ["dm3 (130428560)", "130428560", false], ["dm6 (125464728)", "125464728", false], ["hg19/GRCh37 (2685511504)", "2685511504", true], ["GRCh38/hg38 (2701495761)", "2701495761", false], ["GRCm37/mm9 (2304947926)", "2304947926", false], ["GRCm38/mm10 (2308125349)", "2308125349", false], ["user specified", "specific", false]], "display": null, "multiple": false, "textable": false}}]}], "test_param": {"model_class": "SelectToolParameter", "name": "type", "argument": null, "type": "select", "label": "Scaling/Normalization method", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "1x", "options": [["Normalize coverage to 1x", "1x", false], ["Normalize to reads per kilobase per million (RPKM)", "rpkm", false], ["Normalize to counts per million (CPM), same as CPM in RNA-seq", "cpm", false], ["Normalize to bins per million (BPM), same as TPM in RNA-seq", "bpm", false], ["Do not normalize or scale", "no", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "SelectToolParameter", "name": "outFileFormat", "argument": null, "type": "select", "label": "Coverage file format", "help": "", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "bigwig", "options": [["bigwig", "bigwig", true], ["bedgraph", "bedgraph", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "BooleanToolParameter", "name": "exactScaling", "argument": "--exactScaling", "type": "boolean", "label": "Compute an exact scaling factor", "help": "Compute an exact scaling factor rather than one based on                   sampled reads. This is only useful in cases where you are                   filtering some alignments out AND this are both rare and                   tend to clump together in the genome. In such cases the                   region-based sampling employed by deepTools would produce                   inaccurate scaling factors. Note that this option results                   in the process taking significantly more time to complete.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--exactScaling", "falsevalue": ""}, {"model_class": "TextToolParameter", "name": "region", "argument": "--region", "type": "text", "label": "Region of the genome to limit the operation to", "help": "This is useful when testing parameters to reduce the time required. The format is chr:start:end, for example \"chr10\" or \"chr10:456700:891000\".", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "Conditional", "name": "advancedOpt", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": [{"model_class": "FloatToolParameter", "name": "scaleFactor", "argument": "--scaleFactor", "type": "float", "label": "Scaling factor", "help": "The computed scaling factor will be multiplied by this (default 1).", "refresh_on_change": false, "min": null, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "1.0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "smoothLength", "argument": "--smoothLength", "type": "integer", "label": "Smooth values using the following length (in bases)", "help": "The smooth length defines a window, larger than the bin size, over which the number of reads is to be averaged. For example, if the bin size is set to 20 and the smooth length is 60, then, for each bin, its value is set to the average of it and its left and right neighbors. Any value smaller than the bin size will be ignored and no smoothing will be applied.", "refresh_on_change": false, "min": 1, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "TextToolParameter", "name": "ignoreForNormalization", "argument": "ignoreForNormalization", "type": "text", "label": "Regions that should be excluded for normalization", "help": "A list of chromosome names separated by spaces                         containing those chromosomes that should be excluded                         during normalization. This is useful when                         considering samples with unequal coverage across                         chromosomes, like male and female samples. Example: chrX chrM", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "skipNAs", "argument": "--skipNAs", "type": "boolean", "label": "Ignore missing data?", "help": "This parameter determines if non-covered regions                  (regions without overlapping reads) in a bam/bigWig file                  should be skipped. The default is to treat those                  regions as having a value of zero. The decision to                  skip non-covered regions depends on the interpretation                  of the data. Non-covered regions may represent, for                  example, repetitive regions that should be ignored.                  (default: False)", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--skipNAs", "falsevalue": ""}, {"model_class": "Conditional", "name": "doExtendCustom", "type": "conditional", "cases": [{"model_class": "ConditionalWhen", "value": "no", "inputs": []}, {"model_class": "ConditionalWhen", "value": "yes", "inputs": []}, {"model_class": "ConditionalWhen", "value": "custom", "inputs": [{"model_class": "IntegerToolParameter", "name": "extendReadsValue", "argument": null, "type": "integer", "label": "Extend reads to the given average fragment size", "help": "Extend all reads to this length", "refresh_on_change": false, "min": 1, "max": null, "optional": false, "hidden": false, "is_dynamic": false, "value": "300", "area": false, "datalist": []}]}], "test_param": {"model_class": "SelectToolParameter", "name": "doExtend", "argument": null, "type": "select", "label": "Extend reads to the given average fragment size.", "help": "If selected : Single-end reads and singletons are extended to match the given length and Paired-end reads are extended to match the fragment size.                      By default *each* read mate is extended.                      This can be modified using the SAM flags (see --samFlagInclude and --samFlagExclude options) to keep only the first or the second mate.                      Unmated reads, mate reads that map to different chromosomes or too far apart are extended to the given value.                      Reads are only extended if --extendReads is set to a value greater than the read length. *NOTE*: For spliced-read data, this option is not                      recommended as it will extend reads over skipped regions, e.g. introns in RNA-seq data.", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["No extension. The default value and most typically appropriate.", "no", true], ["Paired-end extension. Suitable only for paired-end datasets.", "yes", false], ["A custom length, which will be applied to ALL reads.", "custom", false]], "display": null, "multiple": false, "textable": false}}, {"model_class": "BooleanToolParameter", "name": "ignoreDuplicates", "argument": "--ignoreDuplicates", "type": "boolean", "label": "Ignore duplicates", "help": "If set, reads that have the same orientation and start position will be considered only once. If reads are paired, the mate position also has to coincide to ignore a read.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--ignoreDuplicates", "falsevalue": ""}, {"model_class": "BooleanToolParameter", "name": "centerReads", "argument": "--centerReads", "type": "boolean", "label": "Center regions with respect to the fragment length", "help": "For paired-end data the fragment is defined by the bounds of the reads. For single-end data the bounds are defined by the read and the user-definable fragment/extension length. This option is useful to get a sharper signal around enriched regions.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--centerReads", "falsevalue": ""}, {"model_class": "IntegerToolParameter", "name": "minMappingQuality", "argument": "--minMappingQuality", "type": "integer", "label": "Minimum mapping quality", "help": "If set, only reads with a mapping quality score at least this high are considered.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "1", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "samFlagInclude", "argument": "--samFlagInclude", "type": "integer", "label": "Include reads based on the SAM flag", "help": "For example, to get only reads that are the first mate use a flag of 64. This is useful to count properly paired reads only once, otherwise the second mate will be also considered for the coverage.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "samFlagExclude", "argument": "--samFlagExclude", "type": "integer", "label": "Exclude reads based on the SAM flag", "help": "For example, to get only reads that map to the forward strand, use --samFlagExclude 16, where 16 is the SAM flag for reads that map to the reverse strand.", "refresh_on_change": false, "min": null, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "minFragmentLength", "argument": "--minFragmentLength", "type": "integer", "label": "Minimum fragment length for inclusion.", "help": "This is primarily useful in things like ATACseq, where one would like to look specifically at mono- or di-nucleosome fragments.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "IntegerToolParameter", "name": "maxFragmentLength", "argument": "--maxFragmentLength", "type": "integer", "label": "Maximum fragment length for inclusion.", "help": "A value of 0 (the default) is equivalent to no maximum.", "refresh_on_change": false, "min": 0, "max": null, "optional": true, "hidden": false, "is_dynamic": false, "value": "0", "area": false, "datalist": []}, {"model_class": "BooleanToolParameter", "name": "MNase", "argument": "--MNase", "type": "boolean", "label": "Determine nucleosome positions from MNase-seq data", "help": "Only the 3 nucleotides at the center of each fragment are counted. The fragment ends are defined by the two mate reads. *NOTE*: Requires paired-end data. By default, only fragments between 130 and 200 bases will be used, though this can be changed with the --minFragmentLength and --maxFragmentLength options.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": false, "truevalue": "--MNase", "falsevalue": ""}, {"model_class": "TextToolParameter", "name": "Offset", "argument": "--Offset", "type": "text", "label": "Offset inside each alignment to use for the signal location.", "help": "Uses this offset inside of each read as the signal. This is useful in                         cases like RiboSeq or GROseq, where only the 12th, 15th or 1st base aligned                         should be used to denote where the signal is (rather than the span of the                         whole alignment). This can be paired with the --filterRNAstrand option. Note                         that negative values indicate offsets from the end of each read. A value of                         1 indicates the first base of the alignment (taking alignment orientation                         into account). Likewise, a value of -1 is the last base of the alignment. An                         offset of 0 is not permitted. If two values (separated by spaces) are specified, then they will be                         used to specify a range of positions. Note that specifying something like                         --Offset 5 -1 will result in the 5th through last position being used, which                         is equivalent to trimming 4 bases from the 5-prime end of alignments.", "refresh_on_change": false, "optional": true, "hidden": false, "is_dynamic": false, "value": "", "area": false, "datalist": []}, {"model_class": "SelectToolParameter", "name": "filterRNAstrand", "argument": "filterRNAstrand", "type": "select", "label": "Only include reads originating from fragments from the forward or reverse strand.", "help": "By default (the no option), all reads are processed, regardless of the strand they originated from. For RNAseq, it can be useful to separately create bigWig files for the forward or reverse strands.                           Note that this tools assumes that a dUTP-based method was used, so fragments will be assigned to the reverse strand if the second read in a pair is reverse complemented.", "refresh_on_change": false, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["forward", "forward", false], ["reverse", "reverse", false]], "display": null, "multiple": false, "textable": false}, {"model_class": "DataToolParameter", "name": "blackListFileName", "argument": "--blackListFileName", "type": "data", "label": "Blacklisted regions in BED/GTF format", "help": "One or more files containing regions to exclude from the analysis", "refresh_on_change": true, "optional": true, "hidden": false, "is_dynamic": false, "value": null, "extensions": ["bed", "gtf"], "edam": {"edam_formats": ["format_3003", "format_2306"], "edam_data": ["data_3002", "data_1255"]}, "multiple": true, "min": 0, "max": null, "options": {"dce": [], "ldda": [], "hda": [], "hdca": []}, "tag": null}]}], "test_param": {"model_class": "SelectToolParameter", "name": "showAdvancedOpt", "argument": null, "type": "select", "label": "Show advanced options", "help": "", "refresh_on_change": true, "optional": false, "hidden": false, "is_dynamic": false, "value": "no", "options": [["no", "no", true], ["yes", "yes", false]], "display": null, "multiple": false, "textable": false}}], "outputs": [{"model_class": "ToolOutput", "name": "outFileName", "format": "bigwig", "label": "", "hidden": false, "output_type": "data", "format_source": null, "default_identifier_source": "None", "metadata_source": "", "parent": null, "count": 1, "from_work_dir": null, "edam_format": "format_3006", "edam_data": "data_3002", "discover_datasets": [{"discover_via": "pattern", "dbkey": "__input__", "format": null, "visible": false, "assign_primary_output": false, "directory": null, "recurse": false, "match_relative_path": false, "sort_key": "filename", "sort_comp": "lexical", "pattern": "primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?", "sort_by": "filename"}]}], "panel_section_id": "deeptools", "panel_section_name": "deepTools", "form_style": "regular"}